#!/usr/bin/perl
# Perl - v: 5.16.3
#------------------------------------------------------------------------------#
# Extract.pl  : XL-Parser process for extraction and log analysis (must be packaged as .exe)
# Website     : http://le-tools.com/XL-Parser.html
# SourceForge : https://sourceforge.net/p/xl-parser
# GitHub      : https://github.com/arioux/XL-Parser
# Creation    : 2016-07-15
# Modified    : 2018-01-06
my $VERSION   = '1.2';
# Author      : Alain Rioux (admin@le-tools.com)
#
# Copyright (C) 2016-2018 Alain Rioux (le-tools.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#------------------------------------------------------------------------------#
# Modules
#------------------------------------------------------------------------------#
use strict;
use warnings;
use Win32::API();
use Win32::GUI();
use Win32::GUI::BitmapInline();
use Win32::GUI::Grid;
use Win32::Clipboard;
use Win32::DriveInfo;
use Win32::Process;
use threads;
use threads::shared;
use JSON qw(encode_json decode_json);
use Time::Local 'timelocal';
use B::Hooks::EndOfScope::PP::FieldHash;
use B::Hooks::EndOfScope::PP;
use Params::Validate::PP;
use DateTime;
use DateTime::Format::Duration;
use DateTime::Format::Strptime;
use DateTime::TimeZone;
use Encode qw(encode);
use Extract::Regex;                  # This is a personal module
use IO::Handle;
use IO::HTML;                        # HTML encodings
use Encode::Guess;                   # Other encodings (ascii/utf8/BOMed UTF)
use Win32::OLE;
use Win32::OLE::Enum;                # Use MS Word
use Text::Extract::Word;             # If MS Word is not installed (parser for .doc)
use XML::LibXML::Reader;             # If MS Word is not installed (for docx, unzip and parse XML)
use Spreadsheet::ParseExcel::Simple; # MS Excel (old format, xls)
use Spreadsheet::XLSX;               # MS Excel (new format, xlsx)
use Parse::EventLog;                 # Event logs (old format)
use Win32::EventLog;
use CAM::PDF;
use Email::Outlook::Message;         # For Msg
use Archive::Zip;
use Regexp::IPv6 qw($IPv6_re);
use Business::CreditCard;
use Domain::PublicSuffix;
use Net::DNS;
use base qw/Net::DNS::Resolver::Base/;
use Net::CIDR;
use Geo::IP;
use DBI;
use Woothee;
use Parse::HTTP::UserAgent;
use Parse::HTTP::UserAgent::Base::IS;
use Parse::HTTP::UserAgent::Base::Parsers;
use Parse::HTTP::UserAgent::Base::Dumper;
use Parse::HTTP::UserAgent::Base::Accessors;
use HTTP::BrowserDetect;
use HTML::ParseBrowser;
use Excel::Writer::XLSX;
require "XL-ParserLang.pl";
require "XL-Parser-processGraph.pl";

#------------------------------------------------------------------------------#
# Global variables
#------------------------------------------------------------------------------#
my $REF_ARG     = \@ARGV;                                                      # Parameters
my $PROCESSNAME = $$REF_ARG[0];                                                # Current process name
my $PROCESSID   = $$REF_ARG[1];                                                # Current process ID
my $PROGDIR     = $$REF_ARG[2];                                                # Program directory
my $REPORTDIR   = $$REF_ARG[3];                                                # Report dir
my $USERDIR     = $$REF_ARG[4];                                                # User path
my $LANG_FILE   = "$USERDIR\\Lang.ini";                                        # Langage file
my %STR;                                                                       # Strings for GUI
my $ARROW       :shared;                                                       # Arrow pointer
my $HOURGLASS   :shared;                                                       # Hourglass pointer
my $THR;                                                                       # Thread

#------------------------------------------------------------------------------#
# Strings
#------------------------------------------------------------------------------#
&loadDefaultStr(\%STR);                                                        # Load default language (en)
&loadStr(\%STR, $LANG_FILE) if -e $LANG_FILE and -T $LANG_FILE;                # If language file, load translated strings

#------------------------------------------------------------------------------#
# Graphic elements
#------------------------------------------------------------------------------#
my ($winICO, $logo128Bmp, $options128, $openDirBmp, $browseBmp, $datetime16Bmp) = &loadGraph();

#------------------------------------------------------------------------------#
# Windows utils
#------------------------------------------------------------------------------#
my $screen    = Win32::GUI::GetDesktopWindow(); # Screen resolution
my $scrnX     = Win32::GUI::Width($screen);
my $scrnY     = Win32::GUI::Height($screen);
# Fonts
sub LOGPIXELSX() {88}
sub getDPI { return(Win32::GUI::DC->new()->GetDeviceCaps(LOGPIXELSX)); }
my $DPI = &getDPI();
my $fontGBu;
my $font10;
my $font10b;
my $font10u;
my $fontGB2;
# Larger size (125% and 150%)
if ($DPI >= 120) {
  $fontGBu = new Win32::GUI::Font(-name => 'Arial', -size => 10, -bold => 1, -underline => 1);
  $font10  = new Win32::GUI::Font(-name => 'Arial', -size =>  8);
  $font10b = new Win32::GUI::Font(-name => 'Arial', -size =>  8, -bold => 1);
  $font10u = new Win32::GUI::Font(-name => 'Arial', -size =>  8, -bold => 1, -underline => 1);
  $fontGB2 = new Win32::GUI::Font(-name => 'Arial', -size => 12, -bold => 1, -underline => 1);
# Normal size
} else {
  $fontGBu = new Win32::GUI::Font(-name => 'Arial', -size => 12, -bold => 1, -underline => 1);
  $font10  = new Win32::GUI::Font(-name => 'Arial', -size => 10);
  $font10b = new Win32::GUI::Font(-name => 'Arial', -size => 10, -bold => 1);
  $font10u = new Win32::GUI::Font(-name => 'Arial', -size => 10, -bold => 1, -underline => 1);
  $fontGB2 = new Win32::GUI::Font(-name => 'Arial', -size => 14, -bold => 1, -underline => 1);
}
# Load Pointers
my $loadImage = new Win32::API('user32', 'LoadImage', ['N','N','I','I','I','I'],'N');
$HOURGLASS    = $loadImage->Call(0, 32514, 2, 0, 0, 0x8040);
$ARROW        = $loadImage->Call(0, 32512, 2, 0, 0, 0x8040);

#------------------------------------------------------------------------------#
# Execute process
#------------------------------------------------------------------------------#
my $winPb;
my $winAdvPb;
my $winResults;
my $gridResFilesMenu;
my $gridResExprMenu;
my $winReport;
my $winSearchSA;
my $gridSearchSA_IPsMenu;
my $gridSearchSA_ACTsMenu;
if (!-d $REPORTDIR) { while ($REPORTDIR =~ s/[^\\]$//g) {}; chop($REPORTDIR); }
# Show progress window
if    ($PROCESSNAME eq 'Extract-Expr' or $PROCESSNAME eq 'Extract-SO' or
       $PROCESSNAME eq 'Extract-Results'                                  ) { &createWinResults(); }
elsif ($PROCESSNAME eq 'LADB-Create'  or $PROCESSNAME eq 'LADB-Update' or
       $PROCESSNAME eq 'LADB-UpdateDB'                                    ) { &createWinAdvPb();   }
else                                                                        { &createWinPb();      }
# Extract
if    ($PROCESSNAME eq 'Extract-Expr' and -f "$REPORTDIR\\ExtractExprParams-" . $PROCESSID .'.json') { &extractExprFiles(); }
elsif ($PROCESSNAME eq 'Extract-SO'   and -f "$REPORTDIR\\ExtractSOParams-"   . $PROCESSID .'.json') { &extractSOFiles();   }
# Parse logs and store as SQLite database
elsif ($PROCESSNAME eq 'LADB-Create' or $PROCESSNAME eq 'LADB-Update') { &createLADB(); }
# Update database or create a new one
elsif ($PROCESSNAME eq 'LADB-UpdateDB' and -f "$REPORTDIR\\CurrentUpdateParams-" . $PROCESSID .'.json') { &updateLADB(); }
# Query and search database
elsif ($PROCESSNAME eq 'LADB-Query'    and -f "$REPORTDIR\\CurrentQueryParams-"  . $PROCESSID .'.json') { &queryDB();  }
elsif ($PROCESSNAME eq 'LADB-Search'   and -f "$REPORTDIR\\CurrentSearchParams-" . $PROCESSID .'.json') { &searchDB(); }
# Open Extraction Results
elsif ($PROCESSNAME eq 'Extract-Results') { &ExtractResults(); }
# Open Suspicious Activities Results
elsif ($PROCESSNAME eq 'LADB-SAResults' ) { &SAResults();      }
# Else, show error message
else { &invalidParams(); }
# Start GUI
Win32::GUI::Dialog();

#------------------------------------------------------------------------------#
sub createWinAdvPb
#------------------------------------------------------------------------------#
{
  # Advanced Progress window
  my $winWidth  = 800;
  my $winHeight = 370;
  my $winPosX   = ($scrnX - $winWidth)  / 2;
  my $winPosY   = ($scrnY - $winHeight) / 2;
  $winAdvPb = Win32::GUI::Window->new(-name        => 'winAdvPb'            ,
                                      -text        => $STR{'WebLogAnalysis'},
                                      -pos         => [$winPosX, $winPosY]  ,
                                      -size        => [800, 370]            ,
                                      -background  => [255, 255, 255]       ,
                                      -hasmaximize => 0                     ,
                                      -hasminimize => 1                     ,
                                      -helpbutton  => 0                     ,
                                      -resizable   => 0                     , );
  $winAdvPb->SetIcon($winICO);
  # Progress
  $winAdvPb->AddLabel(      -name        => 'lblLogo'        ,
                            -size        => [128,128]        ,
                            -pos         => [  0, 10]        ,
                            -bitmap      => $logo128Bmp      ,
                            -background  => [255, 255, 255]  , );
  $winAdvPb->AddLabel(      -name        => 'lblPbCurr1'     ,
                            -size        => [638, 22]        ,
                            -pos         => [140,  8]        ,
                            -font        => $font10          ,
                            -truncate    => 1                ,
                            -background  => [255, 255, 255]  , );
  $winAdvPb->AddProgressBar(-name        => 'pbWinPb1'       ,
                            -size        => [530, 22]        ,
                            -pos         => [140, 32]        ,
                            -smooth      => 1                , );
  $winAdvPb->AddLabel(      -name        => 'lblCount1'      ,
                            -size        => [100, 22]        ,
                            -pos         => [680, 33]        ,
                            -font        => $font10          ,
                            -truncate    => 1                ,
                            -background  => [255, 255, 255]  , );
  $winAdvPb->AddLabel(      -name        => 'lblPbCurr2'     ,
                            -size        => [5638, 22]        ,
                            -pos         => [140, 60]        ,
                            -font        => $font10          ,
                            -truncate    => 1                ,
                            -background  => [255, 255, 255]  , );
  $winAdvPb->AddProgressBar(-name        => 'pbWinPb2'       ,
                            -size        => [530, 22]        ,
                            -pos         => [140, 84]        ,
                            -smooth      => 1                , );
  $winAdvPb->AddLabel(      -name        => 'lblCount2'      ,
                            -size        => [100, 22]        ,
                            -pos         => [680, 85]        ,
                            -font        => $font10          ,
                            -truncate    => 1                ,
                            -background  => [255, 255, 255]  , );
  # Stats
  $winAdvPb->AddLabel(      -name        => 'lblResStatsShadowT'    ,
                            -size        => [100, 22]               ,
                            -pos         => [141,116]               ,
                            -foreground  => [180, 180, 180]         ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'ResStats'}.':'    ,
                            -font        => $fontGBu                , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsT'          ,
                            -size        => [100, 22]               ,
                            -pos         => [140,115]               ,
                            -addstyle    => 11                      , # Transparent
                            -foreground  => [ 50, 180,  0]          ,
                            -text        => $STR{'ResStats'}.':'    ,
                            -font        => $fontGBu                , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsFiles'      ,
                            -size        => [140, 22]               ,
                            -pos         => [140,145]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'ResStatsFiles'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsFilesVal'   ,
                            -size        => [140, 22]               ,
                            -pos         => [285,145]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsLines'      ,
                            -size        => [140, 22]               ,
                            -pos         => [140,170]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'ResStatsLines'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsLinesVal'   ,
                            -size        => [140, 22]               ,
                            -pos         => [285,170]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsSize'       ,
                            -size        => [140, 22]               ,
                            -pos         => [140,195]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'Size'}.':'        ,
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsSizeVal'    ,
                            -size        => [140, 22]               ,
                            -pos         => [285,195]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsDuration'   ,
                            -size        => [140, 22]               ,
                            -pos         => [140,220]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'ResStatsTimeElapsed'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsDurationVal',
                            -size        => [140, 22]               ,
                            -pos         => [285,220]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsTimeLeft'   ,
                            -size        => [140, 22]               ,
                            -pos         => [140,245]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'ResStatsTimeLeft'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsTimeLeftVal',
                            -size        => [140, 22]               ,
                            -pos         => [285,245]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsEntries'    ,
                            -size        => [150, 22]               ,
                            -pos         => [140,270]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'ResStatsEntries'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsEntriesVal' ,
                            -size        => [140, 22]               ,
                            -pos         => [285,270]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsRejected'   ,
                            -size        => [150, 22]               ,
                            -pos         => [455,145]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'lblCurrDBRejected'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsRejectedVal',
                            -size        => [140, 22]               ,
                            -pos         => [610,145]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsFiltered'   ,
                            -size        => [150, 22]               ,
                            -pos         => [455,170]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'lblCurrDBFiltered'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsFilteredVal',
                            -size        => [140, 22]               ,
                            -pos         => [610,170]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsResWD'      ,
                            -size        => [150, 22]               ,
                            -pos         => [455,195]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'lblCurrDBResWDs'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsResWDVal'   ,
                            -size        => [140, 22]               ,
                            -pos         => [610,195]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsResISP'     ,
                            -size        => [150, 22]               ,
                            -pos         => [455,220]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'lblCurrDBNbrResISP'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsResISPVal'  ,
                            -size        => [140, 22]               ,
                            -pos         => [610,220]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsResGeoIP'   ,
                            -size        => [150, 22]               ,
                            -pos         => [455,245]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'lblCurrDBNbrResGeoIP'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsResGeoIPVal',
                            -size        => [140, 22]               ,
                            -pos         => [610,245]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsResUA'   ,
                            -size        => [150, 22]               ,
                            -pos         => [455,270]               ,
                            -background  => [255, 255, 255]         ,
                            -text        => $STR{'lblCurrDBResUAs'}.':',
                            -font        => $font10                 , );
  $winAdvPb->AddLabel(      -name        => 'lblResStatsResUAVal'   ,
                            -size        => [140, 22]               ,
                            -pos         => [610,270]               ,
                            -background  => [255, 255, 255]         ,
                            -font        => $font10b                ,
                            -align       => 'right'                 , );
  $winAdvPb->AddButton(     -name        => 'btnCancelLA'           ,
                            -text        => $STR{'cancel'}          ,
                            -font        => $font10                 ,
                            -size        => [ 80, 30]               ,
                            -pos         => [360,305]               ,
                            -cancel      => 1                       , );
  $winAdvPb->AddButton(     -name        => 'btnCloseWinAdvPb'      ,
                            -text        => $STR{'Close'}           ,
                            -font        => $font10                 ,
                            -size        => [ 80, 30]               ,
                            -pos         => [360,305]               ,
                            -visible     => 0                       ,
                            -cancel      => 1                       , );
  $winAdvPb->Show();
  
}  #--- End createWinAdvPb

#------------------------------------------------------------------------------#
sub createWinPb
#------------------------------------------------------------------------------#
{
  # Simple Progress window
  my $winWidth  = 600;
  my $winHeight = 170;
  my $winPosX   = ($scrnX - $winWidth)  / 2;
  my $winPosY   = ($scrnY - $winHeight) / 2;
  $winPb  = Win32::GUI::DialogBox->new( -name        => 'winPb'                   ,
                                        -text        => $STR{'winPb'}             ,
                                        -pos         => [$winPosX, $winPosY]      ,
                                        -size        => [600, 170]                ,
                                        -background  => [255, 255, 255]           ,
                                        -hasmaximize => 0                         ,
                                        -hasminimize => 1                         ,
                                        -helpbutton  => 0                         ,
                                        -resizable   => 0                         ,
                                        -dialogui    => 1                         , );
  $winPb->SetIcon($winICO);
  $winPb->AddLabel(       -name        => 'lblLogo2'       ,
                          -size        => [128,128]        ,
                          -pos         => [  0,  5]        ,
                          -bitmap      => $logo128Bmp      , );
  $winPb->AddLabel(       -name        => 'lblCurr'        ,
                          -size        => [460, 22]        ,
                          -pos         => [140, 25]        ,
                          -font        => $font10          ,
                          -truncate    => 1                ,
                          -background  => [255, 255, 255]  ,
                          -foreground  => [  0, 102, 204]  , );
  $winPb->AddProgressBar( -name        => 'pb'             ,
                          -size        => [355, 22]        ,
                          -pos         => [140, 50]        ,
                          -smooth      => 1                , );
  $winPb->AddLabel(       -name        => 'lblCount'       ,
                          -size        => [100, 22]        ,
                          -pos         => [500, 52]        ,
                          -font        => $font10          ,
                          -truncate    => 1                ,
                          -background  => [255, 255, 255]  ,
                          -foreground  => [  0, 102, 204]  , );
  $winPb->AddButton(      -name        => 'btnCancel'      ,
                          -text        => $STR{'cancel'}   ,
                          -font        => $font10          ,
                          -size        => [ 80, 30]        ,
                          -pos         => [300, 95]        ,
                          -cancel      => 1                , );
  $winPb->AddButton(      -name        => 'btnClose'       ,
                          -text        => $STR{'Close'}    ,
                          -font        => $font10          ,
                          -size        => [ 80, 30]        ,
                          -pos         => [300, 95]        ,
                          -cancel      => 1                ,
                          -visible     => 0                , );
  $winPb->Show();
  
}  #--- End createWinPb

#------------------------------------------------------------------------------#
sub createWinResults
#------------------------------------------------------------------------------#
{
  # Result window for extraction
  my $winWidth  = 800;
  my $winHeight = 400;
  my $winPosX   = ($scrnX - $winWidth)  / 2;
  my $winPosY   = ($scrnY - $winHeight) / 2;
  $winResults = Win32::GUI::Window->new(-name        => 'winResults'          ,
                                        -text        => "$STR{'Extraction'} $STR{'Results'}",
                                        -pos         => [$winPosX, $winPosY]  ,
                                        -size        => [800, 400]            ,
                                        -background  => [255, 255, 255]       ,
                                        -hasmaximize => 1                     ,
                                        -hasminimize => 1                     ,
                                        -helpbutton  => 0                     ,
                                        -resizable   => 1                     , );
  $winResults->SetIcon($winICO);
  $winResults->AddLabel(      -name         => 'lblLogo'        ,
                              -size         => [128,128]        ,
                              -pos          => [  0, 10]        ,
                              -bitmap       => $logo128Bmp      ,
                              -background   => [255, 255, 255]  , );
  # Stats
  $winResults->AddLabel(      -name         => 'lblResStatsShadowT'    ,
                              -size         => [100, 22]               ,
                              -pos          => [146,  6]               ,
                              -foreground   => [180, 180, 180]         ,
                              -background   => [255, 255, 255]         ,
                              -text         => $STR{'ResStats'}.':'    ,
                              -font         => $fontGBu                , );
  $winResults->AddLabel(      -name         => 'lblResStatsT'          ,
                              -size         => [100, 22]               ,
                              -pos          => [145,  5]               ,
                              -addstyle     => 11                      , # Transparent
                              -foreground   => [ 50, 180,  0]          ,
                              -text         => $STR{'ResStats'}.':'    ,
                              -font         => $fontGBu                , );
  $winResults->AddLabel(      -name         => 'lblResStatsFiles'      ,
                              -size         => [ 80, 22]               ,
                              -pos          => [145, 35]               ,
                              -background   => [255, 255, 255]         ,
                              -text         => $STR{'ResStatsFiles'}.':',
                              -font         => $font10                 , );
  $winResults->AddLabel(      -name         => 'lblResStatsFilesVal'   ,
                              -size         => [ 80, 22]               ,
                              -pos          => [230, 35]               ,
                              -background   => [255, 255, 255]         ,
                              -font         => $font10b                ,
                              -align        => 'right'                 , );
  $winResults->AddLabel(      -name         => 'lblResStatsLines'      ,
                              -size         => [ 80, 22]               ,
                              -pos          => [145, 60]               ,
                              -background   => [255, 255, 255]         ,
                              -text         => $STR{'ResStatsLines'}.':',
                              -font         => $font10                 , );
  $winResults->AddLabel(      -name         => 'lblResStatsLinesVal'   ,
                              -size         => [ 80, 22]               ,
                              -pos          => [230, 60]               ,
                              -background   => [255, 255, 255]         ,
                              -font         => $font10b                ,
                              -align        => 'right'                 , );
  $winResults->AddLabel(      -name         => 'lblResStatsSize'       ,
                              -size         => [ 80, 22]               ,
                              -pos          => [325, 35]               ,
                              -background   => [255, 255, 255]         ,
                              -text         => $STR{'Size'}.':'        ,
                              -font         => $font10                 , );
  $winResults->AddLabel(      -name         => 'lblResStatsSizeVal'    ,
                              -size         => [ 80, 22]               ,
                              -pos          => [410, 35]               ,
                              -background   => [255, 255, 255]         ,
                              -font         => $font10b                ,
                              -align        => 'right'                 , );
  $winResults->AddLabel(      -name         => 'lblResStatsDuration'   ,
                              -size         => [ 80, 22]               ,
                              -pos          => [325, 60]               ,
                              -background   => [255, 255, 255]         ,
                              -text         => $STR{'ResStatsDuration'}.':',
                              -font         => $font10                 , );
  $winResults->AddLabel(      -name         => 'lblResStatsDurationVal',
                              -size         => [ 80, 22]               ,
                              -pos          => [410, 60]               ,
                              -background   => [255, 255, 255]         ,
                              -font         => $font10b                ,
                              -align        => 'right'                 , );
  $winResults->AddLabel(      -name         => 'lblResStatsResults'    ,
                              -size         => [ 80, 22]               ,
                              -pos          => [505, 35]               ,
                              -background   => [255, 255, 255]         ,
                              -text         => $STR{'Results'}.':',
                              -font         => $font10                 , );
  $winResults->AddLabel(      -name         => 'lblResStatsResultsVal' ,
                              -size         => [ 80, 22]               ,
                              -pos          => [590, 35]               ,
                              -background   => [255, 255, 255]         ,
                              -font         => $font10b                ,
                              -align        => 'right'                 , );
  # Results grid
  $winResults->AddLabel(      -name         => 'lblResultsShadowT'     ,
                              -size         => [100, 22]               ,
                              -pos          => [146, 91]               ,
                              -foreground   => [180, 180, 180]         ,
                              -background   => [255, 255, 255]         ,
                              -text         => $STR{'Results'}.':'     ,
                              -font         => $fontGBu                , );
  $winResults->AddLabel(      -name         => 'lblResultsT'           ,
                              -size         => [100, 22]               ,
                              -pos          => [145, 90]               ,
                              -addstyle     => 11                      , # Transparent
                              -foreground   => [ 50, 180,  0]          ,
                              -text         => $STR{'Results'}.':',
                              -font         => $fontGBu                , );
  $winResults->AddRadioButton(-name         => 'rbResByFile'           ,
                              -size         => [100, 22]               ,
                              -pos          => [260, 90]               ,
                              -background   => [255, 255, 255]         ,
                              -text         => $STR{'lblExprOptMaxResFile'},
                              -font         => $font10                 ,
                              -checked      => 1                       ,
                              -group        => 1                       , );
  $winResults->AddRadioButton(-name         => 'rbResByExpr'           ,
                              -size         => [100, 22]               ,
                              -pos          => [365, 90]               ,
                              -background   => [255, 255, 255]         ,
                              -text         => $STR{'rbResByExpr'}     ,
                              -font         => $font10                 , );
  $winResults->AddButton(     -name         => 'btnSaveResultsExtract' ,
                              -size         => [100, 22]               ,
                              -pos          => [495, 90]               ,
                              -text         => $STR{'SaveResults'}.'...',
                              -disabled     => 1                       , );
  $winResults->AddButton(     -name         => 'btnWinReport'          ,
                              -size         => [100, 22]               ,
                              -pos          => [600, 90]               ,
                              -text         => $STR{'ReportOpt2'}.'...',
                              -disabled     => 1                       , );
  $winResults->AddGrid(       -name         => 'gridResFiles'          ,
                              -size         => [500,100]               ,
                              -pos          => [145,115]               ,
                              -background   => [255, 255, 255]         ,
                              -rows         => 1                       ,
                              -columns      => 4                       ,
                              -fixedrows    => 1                       ,
                              -fixedcolumns => 0                       ,
                              -editable     => 0                       , );
  $winResults->gridResFiles->SetListMode(1);
  # Popup menu for Result Files grid
  $gridResFilesMenu = new Win32::GUI::Menu(
    'gridResFilesMenu'                             => 'gridResFilesMenu'         ,
    "> $STR{'showResults'}"                        => { -name => 'showResFileResults', -default => 1 },
    "> $STR{'showResults'} ($STR{'NoDuplicates'})" => 'showResFileResultsNoDupl' ,
    "> $STR{'showResults'} ($STR{'ResultsOnly'})"  => 'showResFileResultsResOnly',
    "> $STR{'showResults'} ($STR{'ResultsOnly'}-$STR{'NoDuplicates'})"  => 'showResFileResultsResOnlyNoDupl',
    "> $STR{'openFile'}"                           => 'openResFile'              ,
    "> $STR{'copyFile'}".'...'                     => 'copyResFile'              ,
    " > -" => 0,
    "> $STR{'selectAll'}"                          => 'selectAllResFiles'        ,
    "> $STR{'copySelRow'}"                         => 'copySelResFilesRow'       ,
  );
  $winResults->AddGrid(       -name         => 'gridResExpr'           ,
                              -size         => [500,100]               ,
                              -pos          => [145,115]               ,
                              -background   => [255, 255, 255]         ,
                              -rows         => 1                       ,
                              -columns      => 5                       ,
                              -fixedrows    => 1                       ,
                              -fixedcolumns => 0                       ,
                              -editable     => 0                       ,
                              -visible      => 0                       , );
  $winResults->gridResExpr->SetListMode(1);
  # Popup menu for Result Expressions grid
  $gridResExprMenu = new Win32::GUI::Menu(
    'gridResExprMenu'                              => 'gridResExprMenu'  ,
    "> $STR{'showResults'}"                        => { -name => 'showResExprResults', -default => 1 },
    "> $STR{'showResults'} ($STR{'NoDuplicates'})" => 'showResExprResultsNoDupl' ,
    "> $STR{'showResults'} ($STR{'ResultsOnly'})"  => 'showResExprResultsResOnly',
    "> $STR{'showResults'} ($STR{'ResultsOnly'}-$STR{'NoDuplicates'})"  => 'showResExprResultsResOnlyNoDupl',
    " > -" => 0,
    "> $STR{'selectAll'}"                          => 'selectAllResExpr' ,
    "> $STR{'copySelRow'}"                         => 'copySelResExprRow',
  );
  # Progress
  $winResults->AddLabel(      -name         => 'lblCurr'        ,
                              -size         => [460, 22]        ,
                              -pos          => [145,220]        ,
                              -font         => $font10          ,
                              -truncate     => 1                ,
                              -background   => [255, 255, 255]  , );
  $winResults->AddProgressBar(-name         => 'pb'             ,
                              -size         => [355, 22]        ,
                              -pos          => [145,145]        ,
                              -smooth       => 1                , );
  $winResults->AddLabel(      -name         => 'lblCount'       ,
                              -size         => [100, 22]        ,
                              -pos          => [505,147]        ,
                              -font         => $font10          ,
                              -truncate     => 1                ,
                              -background   => [255, 255, 255]  , );
  # Buttons
  $winResults->AddButton(     -name         => 'btnCancelExtract',
                              -text         => $STR{'cancel'}    ,
                              -font         => $font10           ,
                              -size         => [ 80, 30]         ,
                              -pos          => [300,300]         ,
                              -cancel       => 1                 , );
  $winResults->AddButton(     -name         => 'btnCloseWinResults',
                              -text         => $STR{'Close'}     ,
                              -font         => $font10           ,
                              -size         => [ 80, 30]         ,
                              -pos          => [300,300]         ,
                              -cancel       => 1                 ,
                              -visible      => 0                 , );
  $winResults->Show();

}  #--- End createWinResults

#--------------------------#
sub winResults_Resize
#--------------------------#
{
  $winResults->btnSaveResultsExtract->Left($winResults->ScaleWidth()-210);
  $winResults->btnWinReport->Left($winResults->ScaleWidth()-105);
  $winResults->gridResFiles->Width($winResults->ScaleWidth()-150);
  $winResults->gridResFiles->Height($winResults->ScaleHeight()-220);
  $winResults->gridResFiles->AutoSize();
  $winResults->gridResFiles->ExpandColumnsToFit() if $winResults->gridResFiles->GetVirtualWidth() < $winResults->gridResFiles->Width();
  $winResults->gridResFiles->Refresh();
  $winResults->gridResExpr->Width($winResults->ScaleWidth()-150);
  $winResults->gridResExpr->Height($winResults->ScaleHeight()-220);
  $winResults->gridResExpr->AutoSize();
  $winResults->gridResExpr->ExpandColumnsToFit() if $winResults->gridResExpr->GetVirtualWidth()  < $winResults->gridResExpr->Width();
  $winResults->gridResExpr->Refresh();
  $winResults->btnCancelExtract->Left(($winResults->ScaleWidth()-80)/2);
  $winResults->btnCloseWinResults->Left(($winResults->ScaleWidth()-80)/2);
  $winResults->lblCurr->Width($winResults->ScaleWidth()-150);
  $winResults->pb->Width($winResults->ScaleWidth()-255);
  $winResults->lblCount->Left($winResults->ScaleWidth()-105);
  $winResults->lblCurr->Top($winResults->ScaleHeight()-97);
  $winResults->pb->Top($winResults->ScaleHeight()-72);
  $winResults->lblCount->Top($winResults->ScaleHeight()-70);  
  $winResults->btnCancelExtract->Top($winResults->ScaleHeight()-40);
  $winResults->btnCloseWinResults->Top($winResults->ScaleHeight()-40);
  
}  #--- End winResults_Resize

#--------------------------#
sub createWinReport
#--------------------------#
{
  # Report window
  my $winWidth  = 800;
  my $winHeight = 400;
  my $winPosX   = ($scrnX - $winWidth)  / 2;
  my $winPosY   = ($scrnY - $winHeight) / 2;
  $winReport = Win32::GUI::Window->new( -name        => 'winReport'            ,
                                        -background  => [255, 255, 255]        ,
                                        -parent      => $winResults            ,
                                        -text        => $STR{'ReportOpt2'}     ,
                                        -pos         => [$winPosX, $winPosY]   ,
                                        -size        => [680, 230]             ,
                                        -hasmaximize => 0                      ,
                                        -hasminimize => 0                      ,
                                        -resizable   => 0                      ,
                                        -dialogui    => 1                      , );
  $winReport->SetIcon($winICO);
  $winReport->AddLabel(         -name         => 'lblLogo'               ,
                                -size         => [128,128]               ,
                                -pos          => [  5,  5]               ,
                                -bitmap       => $options128             ,
                                -background   => [255, 255, 255]         , );
  # Report options
  $winReport->AddLabel(         -name         => 'lblReportOptShadowT'   ,
                                -size         => [150, 22]               ,
                                -pos          => [151,  6]               ,
                                -foreground   => [180, 180, 180]         ,
                                -background   => [255, 255, 255]         ,
                                -text         => $STR{'ReportOpt'}.':'   ,
                                -font         => $fontGB2                , );
  $winReport->AddLabel(         -name         => 'lblReportOptT'         ,
                                -size         => [150, 22]               ,
                                -pos          => [150,  5]               ,
                                -addstyle     => 11                      , # Transparent
                                -foreground   => [ 50, 180,  0]          ,
                                -text         => $STR{'ReportOpt'}.':'   ,
                                -font         => $fontGB2                , );
  $winReport->AddLabel(         -name         => 'lblReportCaller'       ,
                                -size         => [ 20, 22]               ,
                                -pos          => [305,  5]               ,
                                -visible      => 0                       , ); # Hidden, 0 (Extraction), 1 (Query Database), 2 (Search Database)
  $winReport->AddTextfield(     -name         => 'tfReportDir'           ,
                                -size         => [390, 22]               ,
                                -pos          => [150, 38]               ,
                                -tabstop      => 1                       , );
  $winReport->AddCombobox(      -name         => 'cbReportFormat'        ,
                                -size         => [ 80, 22]               ,
                                -pos          => [543, 38]               ,
                                -dropdownlist => 1                       ,
                                -vscroll      => 1                       ,
                                -tabstop      => 1                       , );
  $winReport->cbReportFormat->Add('XLSX', 'HTML', 'TXT (TSV)'            , );
  $winReport->cbReportFormat->SetCurSel(0);
  $winReport->AddButton(        -name         => 'btnReportDir'          ,
                                -size         => [ 22, 22]               ,
                                -pos          => [625, 38]               ,
                                -bitmap       => $openDirBmp             ,
                                -tip          => $STR{'btnReportDirTip'} ,
                                -tabstop      => 1                       , );
  $winReport->AddButton(        -name         => 'btnOpenReportDir'      ,
                                -size         => [ 22, 22]               ,
                                -pos          => [649, 38]               ,
                                -bitmap       => $browseBmp              ,
                                -tip          => $STR{'btnOpenDirTip'}   ,
                                -tabstop      => 1                       , );
  $winReport->AddCheckbox(      -name         => 'chReplaceReport'       ,
                                -size         => [200, 20]               ,
                                -pos          => [150, 68]               ,
                                -background   => [255, 255, 255]         ,
                                -text         => $STR{'chReplace'}       ,
                                -font         => $font10                 ,
                                -tabstop      => 1                       , );
  $winReport->AddCheckbox(      -name         => 'chOpenReport'          ,
                                -size         => [200, 20]               ,
                                -pos          => [410, 68]               ,
                                -background   => [255, 255, 255]         ,
                                -text         => $STR{'chOpenReport'}    ,
                                -font         => $font10                 ,
                                -checked      => 1                       ,
                                -tabstop      => 1                       , );
  $winReport->AddCheckbox(      -name         => 'chReportOptSeparateReports',
                                -size         => [300, 22]               ,
                                -pos          => [150, 93]               ,
                                -text         => $STR{'chReportOptSeparateReportsExpr'},
                                -background   => [255, 255, 255]         ,
                                -font         => $font10                 ,
                                -checked      => 0                       ,
                                -tabstop      => 1                       , );
  $winReport->AddLabel(         -name         => 'lblOutputDTFormat'     ,
                                -size         => [150, 22]               ,
                                -pos          => [150, 96]               ,
                                -background   => [255, 255, 255]         ,
                                -text         => $STR{'DTFormat'}.':'    ,
                                -font         => $font10                 ,
                                -visible      => 0                       , );
  $winReport->AddCombobox(      -name         => 'cbOutputDTFormat'      ,
                                -size         => [250,100]               ,
                                -pos          => [305, 93]               ,
                                -dropdownlist => 1                       ,
                                -vscroll      => 1                       ,
                                -visible      => 0                       , );
  $winReport->AddButton(        -name         => 'btnOutputFormatDTDB'   ,
                                -size         => [ 22, 22]               ,
                                -pos          => [558, 93]               ,
                                -font         => $font10                 ,
                                -bitmap       => $datetime16Bmp          ,
                                -tip          => $STR{'openDTDB'}        ,
                                -visible      => 0                       , );
  # Include
  $winReport->AddLabel(         -name         => 'lblReportOptInclude'   ,
                                -size         => [ 80, 22]               ,
                                -pos          => [150,120]               ,
                                -background   => [255, 255, 255]         ,
                                -text         => $STR{'Include'}.':'     ,
                                -font         => $font10u                , );
  $winReport->AddCheckbox(      -name         => 'chReportOptIncHeaders' ,
                                -size         => [150, 22]               ,
                                -pos          => [150,143]               ,
                                -text         => $STR{'chReportOptIncHeaders'},
                                -background   => [255, 255, 255]         ,
                                -font         => $font10                 ,
                                -checked      => 1                       ,
                                -tabstop      => 1                       , );
  $winReport->AddCheckbox(      -name         => 'chReportOptIncSource'  ,
                                -size         => [100, 22]               ,
                                -pos          => [305,143]               ,
                                -text         => $STR{'chReportOptIncSource'},
                                -background   => [255, 255, 255]         ,
                                -font         => $font10                 ,
                                -checked      => 0                       ,
                                -tabstop      => 1                       , );
  $winReport->AddCheckbox(      -name         => 'chReportOptIncExpr'    ,
                                -size         => [120, 22]               ,
                                -pos          => [410,143]               ,
                                -text         => $STR{'Expression'}  ,
                                -background   => [255, 255, 255]         ,
                                -font         => $font10                 ,
                                -checked      => 0                       ,
                                -tabstop      => 1                       , );
  $winReport->AddCheckbox(      -name         => 'chReportOptIncISP'     ,
                                -size         => [100, 22]               ,
                                -pos          => [410,143]               ,
                                -text         => $STR{'isp'}             ,
                                -background   => [255, 255, 255]         ,
                                -font         => $font10                 ,
                                -visible      => 0                       ,
                                -tabstop      => 1                       , );
  $winReport->AddCheckbox(      -name         => 'chReportOptIncGeoIP'   ,
                                -size         => [100, 22]               ,
                                -pos          => [515,143]               ,
                                -text         => $STR{'GeoIPDB'}         ,
                                -background   => [255, 255, 255]         ,
                                -font         => $font10                 ,
                                -tabstop      => 1                       , );
  $winReport->AddCheckbox(      -name         => 'chReportOptIncUADetails',
                                -size         => [150, 22]               ,
                                -pos          => [150,168]               ,
                                -text         => $STR{'UADetails'}       ,
                                -background   => [255, 255, 255]         ,
                                -font         => $font10                 ,
                                -visible      => 0                       ,
                                -tabstop      => 1                       , );
  $winReport->AddCheckbox(      -name         => 'chReportOptIncWeekday' ,
                                -size         => [100, 22]               ,
                                -pos          => [305,168]               ,
                                -text         => $STR{'Weekday'}         ,
                                -background   => [255, 255, 255]         ,
                                -font         => $font10                 ,
                                -checked      => 0                       ,
                                -tabstop      => 1                       , );
  $winReport->AddButton(        -name         => 'btnReportGo'           ,
                                -size         => [ 80, 30]               ,
                                -pos          => [$winReport->ScaleWidth()-88,168],
                                -text         => $STR{'Go'}.' >>'        ,
                                -font         => $font10                 ,
                                -disabled     => 1                       ,
                                -tabstop      => 1                       , );

}  #--- End createWinReport

#------------------------------------------------------------------------------#
sub invalidParams
#------------------------------------------------------------------------------#
{
  $THR = threads->create(sub {
    sleep(1);
    Win32::GUI::MessageBox(0, $STR{'invalidParams'}, $STR{'error'}, 0x40010);
    exit(0);
  });
  
}  #--- End invalidParams

#--------------------------#
sub btnCancel_Click
#--------------------------#
{
  # Stop requests
  if ($THR) {
    $winPb->lblCurr->Text("$STR{'Process'} $STR{'cancelled'}...");
    $winPb->btnCancel->Hide();
    $winPb->btnClose->Show();
    $THR->kill('KILL')->detach() if $THR->is_running();
    $winPb->ChangeCursor($ARROW);
  }
  return(1);

}  #--- End btnCancel_Click

#--------------------------#
sub btnCancelExtract_Click
#--------------------------#
{
  # Stop requests
  if ($THR) {
    $winResults->lblCurr->Text("$STR{'Process'} $STR{'cancelled'}...");
    $winResults->btnCancelExtract->Hide();
    $winResults->btnCloseWinResults->Show();
    $THR->kill('KILL')->detach() if $THR->is_running();
    $winResults->ChangeCursor($ARROW);
  }
  return(1);

}  #--- End btnCancelExtract_Click

#--------------------------#
sub winResults_Terminate
#--------------------------#
{
  $THR->kill('KILL')->detach() if $THR and $THR->is_running();
  # Delete temp file
  unlink("$REPORTDIR\\ExtractExprParams-" . $PROCESSID .'.json'    ) if -e "$REPORTDIR\\ExtractExprParams-" . $PROCESSID .'.json';
  unlink("$REPORTDIR\\ExtractSOParams-" . $PROCESSID .'.json'      ) if -e "$REPORTDIR\\ExtractSOParams-" . $PROCESSID .'.json';
  unlink("$REPORTDIR\\CurrentExtractResults-" . $PROCESSID .'.json') if -e "$REPORTDIR\\CurrentExtractResults-" . $PROCESSID .'.json';
  unlink("$REPORTDIR\\.XL-Parser_tmp-" . $PROCESSID .'.txt'        ) if -e "$REPORTDIR\\.XL-Parser_tmp-" . $PROCESSID .'.txt';
  unlink("$REPORTDIR\\.XL-Parser_tmp2-" . $PROCESSID .'.txt'       ) if -e "$REPORTDIR\\.XL-Parser_tmp2-" . $PROCESSID .'.txt';
  unlink("$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt'    ) if -e "$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt';
  -1; # Close program
  
}  #--- End winResults_Terminate

#--------------------------#
sub btnCloseWinResults_Click { &winResults_Terminate(); }
#--------------------------#

#------------------------------------------------------------------------------#
sub extractExprFiles
#------------------------------------------------------------------------------#
{
  my %extractParams;
  my $refExtractParams = \%extractParams;
  if (open(my $json, "$REPORTDIR\\ExtractExprParams-" . $PROCESSID .'.json')) {
    $THR = threads->create(sub {
      # Thread 'cancellation' signal handler
      $SIG{'KILL'} = sub {
        $winResults->ChangeCursor($ARROW);
        threads->exit();
      };
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        $winResults->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winResults, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      $winResults->ChangeCursor($HOURGLASS);
			# Set Result Files grid header
			$winResults->gridResFiles->SetCellText(0, 0, $STR{'ResStatsFiles'} );
			$winResults->gridResFiles->SetCellText(0, 1, $STR{'Size'}          );
			$winResults->gridResFiles->SetCellText(0, 2, $STR{'ResStatsLines'} );
			$winResults->gridResFiles->SetCellText(0, 3, $STR{'Results'});
			$winResults->gridResFiles->SetCellFormat(0, 0, 1); # Center column headers
			$winResults->gridResFiles->SetCellFormat(0, 1, 1);
			$winResults->gridResFiles->SetCellFormat(0, 2, 1);
			$winResults->gridResFiles->SetCellFormat(0, 3, 1);
      $winResults->gridResFiles->AutoSize();
      $winResults->gridResFiles->ExpandColumnsToFit() if $winResults->gridResFiles->GetVirtualWidth() < $winResults->gridResFiles->Width();
      $winResults->gridResFiles->Refresh();
      # Set Result Expressions grid header
      $winResults->gridResExpr->SetColumns(5);
      $winResults->rbResByExpr->Text($STR{'rbResByExpr'});
      $winResults->gridResExpr->SetCellText(0, 0, $STR{'Expression'} );
      $winResults->gridResExpr->SetCellText(0, 1, $STR{'Case'}           );
      $winResults->gridResExpr->SetCellText(0, 2, $STR{'Regex'}          );
      $winResults->gridResExpr->SetCellText(0, 3, $STR{'Invert'}         );
      $winResults->gridResExpr->SetCellText(0, 4, $STR{'Results'} );
      $winResults->gridResExpr->SetCellFormat(0, 0, 1); # Center column headers
      $winResults->gridResExpr->SetCellFormat(0, 1, 1);
      $winResults->gridResExpr->SetCellFormat(0, 2, 1);
      $winResults->gridResExpr->SetCellFormat(0, 3, 1);
      $winResults->gridResExpr->SetCellFormat(0, 4, 1);
      $winResults->gridResExpr->AutoSize();
      $winResults->gridResExpr->ExpandColumnsToFit() if $winResults->gridResExpr->GetVirtualWidth()  < $winResults->gridResExpr->Width();
      $winResults->gridResExpr->Refresh();
      # Get params from JSON
      my $jsonText = <$json>;
      close($json);
      my $jsonObj = JSON->new;
      $refExtractParams = $jsonObj->decode($jsonText);
      # List files
      my %listFiles;
      my $refListFiles = \%listFiles;
      if ($$refExtractParams{inputType} eq 'Dir' or $$refExtractParams{inputType} eq 'Files') {
        # If list of files hasn't change
        if (-f "$REPORTDIR\\CurrentListFiles.json" and open(my $json, "$REPORTDIR\\CurrentListFiles.json")) {
          $jsonText = <$json>;
          close($json);
          my $jsonObj = JSON->new;
          $refListFiles = $jsonObj->decode($jsonText);
        } else {        
          &getListFiles($refListFiles, $refExtractParams);
          # Store results in a JSON file
          if (open(my $json, '>:encoding(cp1252)', "$REPORTDIR\\CurrentListFiles.json")) {
            my $jsonObj = JSON->new;
            my $jsonText = $jsonObj->encode($refListFiles);
            print $json $jsonText;
            close($json);
          }
        }
      } elsif ($$refExtractParams{inputType} eq 'Clipboard') { $$refListFiles{'Clipboard'} = 1; }
      my $nbrFiles = scalar(keys %{$refListFiles});
      if ($nbrFiles) {
        # Set options
        my $tmpReport = "$REPORTDIR\\.XL-Parser_tmp-" . $PROCESSID .'.txt';
        my $optSet    = 1 if $$refExtractParams{maxResByFile} or $$refExtractParams{maxResTot} or
                             $$refExtractParams{linesBefore}  or $$refExtractParams{linesAfter};
        my $AND = 0;
        my @groupExpr; # An array of hash ref of hash ref (Used only if Search by file is selected)
        my $exprStr;
        # All Expr in one string
        my $lastExprIndex = 0;
        for (my $index = 1; $index <= scalar(keys %{$$refExtractParams{expressions}}); $index++) {
          if ($$refExtractParams{expressions}{$index}{operator} ne '-') {
            $AND++ if $$refExtractParams{expressions}{$index}{operator} eq $STR{'AND'}; # There is a AND in list
            $exprStr .= $$refExtractParams{expressions}{$index}{operator} . ' ';
          }
          $exprStr .= "[$STR{'Invert'}] " if $$refExtractParams{expressions}{$index}{invert} == 1;
          $exprStr .= $$refExtractParams{expressions}{$index}{expr} . ' ';
          $lastExprIndex++;
        }
        chop($exprStr);
        $lastExprIndex++;
        # If there is a AND in list, or No duplicate is selected, add the expression that match all
        if ($AND or $$refExtractParams{noDupl} or $optSet or ($$refExtractParams{modeByFile} and !$AND)) {
          $$refExtractParams{expressions}{$lastExprIndex}{expr}   = $exprStr;
          $$refExtractParams{expressions}{$lastExprIndex}{nbrRes} = 0;
        }
        # If Search by file is selected and there are AND
        if ($$refExtractParams{modeByFile} and $AND) {
          # Group expressions between AND: (Expr1 OR Expr2) = GROUP1   AND   (Expr3 OR Expr4) = GROUP2
          my $nbrExpr = scalar(keys %{$$refExtractParams{expressions}}) - 1;
          my %tmpExprGroup;
          my $index = 1;
          for (my $i = 1; $i <= $nbrExpr; $i++) {
            if ($$refExtractParams{expressions}{$i}{operator} eq $STR{'AND'}) {
              my %copyTmpExprGroup = %tmpExprGroup;
              $$refExtractParams{expressions}{$i}{operator} = $STR{'OR'};
              $copyTmpExprGroup{$index}{expr} = '-';                 # Should be global expr, but not used in this case
              push(@groupExpr, \%copyTmpExprGroup);                  # Add the group
              for (keys %tmpExprGroup) { delete $tmpExprGroup{$_}; } # Delete the tmp hash
              $index = 1;                                            # Reset the index
            }
            $tmpExprGroup{$index} = $$refExtractParams{expressions}{$i};
            $index++;
          }
          my $nbrExprLastGroup = scalar(keys %tmpExprGroup);
          $tmpExprGroup{$nbrExprLastGroup+1}{expr} = '-';
          push(@groupExpr, \%tmpExprGroup); # Add the last group
        }
        # If tmp report already exist, delete it
        unlink($tmpReport) if -e $tmpReport;
        # Set Stats
        my %results;
        $results{totResFiles}   = 0;
        $results{totResLines}   = 0;
        $results{totResSize}    = 0;
        $results{totResResults} = 0;
        my $startTime           = time;
        # Set progress
        $winResults->pb->SetRange(0, $nbrFiles);
        $winResults->pb->SetPos(0);
        $winResults->pb->SetStep(1);
        $winResults->lblCount->Text("0 / $nbrFiles");
        $winResults->lblCurr->Text("$STR{'Searching'} $STR{'Started'}");
        my $count = 0;
        # Get File format list
        my $nbrFileFormats = scalar(keys %{$$refExtractParams{fileFormats}});
        # Foreach file, call the right parser
        foreach my $file (sort { $a cmp $b } keys %{$refListFiles}) {
          $file = encode('cp1252', $file);
          $winResults->lblCurr->Text("$STR{'Searching'} $file".'...');
          # Local variables
          my $fileLines   = 0;
          my $fileResults = 0;
          my $refListResult;
          foreach my $fileFormat (keys %{$$refExtractParams{fileFormats}}) {
            my $formatFound = 0;
            foreach my $ext (@{$$refExtractParams{fileFormats}{$fileFormat}{extList}}) {
              if ($file =~ /$ext$/i) {
                # Plain text and Clipboard
                if ($fileFormat eq $STR{'PlainText'} and ((-T $file and $file !~ /\.pdf$/i) or $file eq 'Clipboard')) {
                  if ($$refExtractParams{modeByFile}) { # Search by file
                    ($fileResults) = &extractExprByFileTxt($file, $refExtractParams, $AND, $lastExprIndex, \@groupExpr);
                  } elsif ($optSet)         { # Search with options
                    ($fileLines, $fileResults, $refListResult) = &extractExprOptFileTxt($file, $refExtractParams, $AND, $lastExprIndex);
                  } elsif ($AND or $$refExtractParams{noDupl}) { # Search and match (with AND or No Duplicate selected)
                    ($fileLines, $fileResults, $refListResult) = &extractExprFileTxt(   $file, $$refExtractParams{expressions}, $AND, $lastExprIndex, $$refExtractParams{inputType});
                  } else                    { # Search all (only one expr, or only OR in list and duplicate allowed)
                    ($fileLines, $fileResults, $refListResult) = &extractExprAllFileTxt($file, $$refExtractParams{expressions}, $$refExtractParams{inputType});
                  }
                }
                # Unicode
                if      (!$fileResults and $fileFormat eq $STR{'Unicode'}) {
                  if ($$refExtractParams{modeByFile}) { # Search by file
                    ($fileResults) = &extractExprByFileUnicode( $file, $$refExtractParams{fileFormats}{$fileFormat}{options},
                                                                $$refExtractParams{expressions}, $AND, $lastExprIndex, \@groupExpr);
                  } elsif ($optSet)         { # Search with options
                    ($fileLines, $fileResults, $refListResult)  = &extractExprOptFileUnicode( $file, $$refExtractParams{fileFormats}{$fileFormat}{options},
                                                                                              $refExtractParams, $AND, $lastExprIndex);
                  } elsif ($AND or $$refExtractParams{noDupl}) { # Search and match (with AND or No Duplicate selected)
                    ($fileLines, $fileResults, $refListResult)  = &extractExprFileUnicode(    $file, $$refExtractParams{fileFormats}{$fileFormat}{options},
                                                                                              $$refExtractParams{expressions}, $AND, $lastExprIndex);
                  } else                    { # Search all (only one expr, or only OR in list and duplicate allowed)
                    ($fileLines, $fileResults, $refListResult)  = &extractExprAllFileUnicode( $file, $$refExtractParams{fileFormats}{$fileFormat}{options},
                                                                                              $$refExtractParams{expressions});
                  }
                # Any ASCII
                } elsif (!$fileResults and $fileFormat eq $STR{'AnyASCII'}) {
                  if ($$refExtractParams{modeByFile}) { # Search by file
                    ($fileResults) = &extractExprByFileTxt($file, $$refExtractParams{expressions}, $AND, $lastExprIndex, \@groupExpr);
                  } elsif ($optSet)         { # Search with options
                    ($fileLines, $fileResults, $refListResult) = &extractExprOptFileTxt($file, $refExtractParams, $AND, $lastExprIndex);
                  } elsif ($AND or $$refExtractParams{noDupl}) { # Search and match (with AND or No Duplicate selected)
                    ($fileLines, $fileResults, $refListResult) = &extractExprFileTxt(   $file, $$refExtractParams{expressions}, $AND, $lastExprIndex, undef);
                  } else                    { # Search all (only one expr, or only OR in list and duplicate allowed)
                    ($fileLines, $fileResults, $refListResult) = &extractExprAllFileTxt($file, $$refExtractParams{expressions}, undef);
                  }
                # Doc and Docx
                } elsif ($fileFormat eq 'Doc' or $fileFormat eq 'Docx') {
                  if ($$refExtractParams{modeByFile}) { # Search by file
                    ($fileResults) = &extractExprByFileDoc( $file, $fileFormat, $$refExtractParams{fileFormats}{$fileFormat}{options},
                                                            $$refExtractParams{expressions}, $AND, $lastExprIndex, \@groupExpr);
                  } elsif ($optSet)         { # Search with options
                    ($fileLines, $fileResults, $refListResult) = &extractExprOptFileDoc($file, $fileFormat, $$refExtractParams{fileFormats}{$fileFormat}{options},
                                                                                        $refExtractParams, $AND, $lastExprIndex);
                  } elsif ($AND or $$refExtractParams{noDupl}) { # Search and match (with AND or No Duplicate selected)
                    ($fileLines, $fileResults, $refListResult) = &extractExprFileDoc(   $file, $fileFormat, $$refExtractParams{fileFormats}{$fileFormat}{options},
                                                                                        $$refExtractParams{expressions}, $AND, $lastExprIndex);
                  } else                    { # Search all (only one expr, or only OR in list and duplicate allowed)
                    ($fileLines, $fileResults, $refListResult) = &extractExprAllFileDoc($file, $fileFormat, $$refExtractParams{fileFormats}{$fileFormat}{options},
                                                                                        $$refExtractParams{expressions});
                  }
                  $formatFound = 1 if $fileResults;
                # Xls and Xlsx
                } elsif ($fileFormat eq 'Xls' or $fileFormat eq 'Xlsx') {
                  if ($$refExtractParams{modeByFile}) { # Search by file
                    ($fileResults) = &extractExprByFileXls($file, $fileFormat, $$refExtractParams{expressions}, $AND, $lastExprIndex, \@groupExpr);
                  } elsif ($optSet)         { # Search with options
                    ($fileLines, $fileResults, $refListResult) = &extractExprOptFileXls($file, $fileFormat, $refExtractParams, $AND, $lastExprIndex);
                  } elsif ($AND or $$refExtractParams{noDupl}) { # Search and match (with AND or No Duplicate selected)
                    ($fileLines, $fileResults, $refListResult) = &extractExprFileXls(   $file, $fileFormat, $$refExtractParams{expressions}, $AND, $lastExprIndex);
                  } else                    { # Search all (only one expr, or only OR in list and duplicate allowed)
                    ($fileLines, $fileResults, $refListResult) = &extractExprAllFileXls($file, $fileFormat, $$refExtractParams{expressions});
                  }
                  $formatFound = 1 if $fileResults;
                # Evt and Evtx
                } elsif ($fileFormat eq 'Evt' or $fileFormat eq 'Evtx') {
                  if ($$refExtractParams{modeByFile}) { # Search by file
                    ($fileResults) = &extractExprByFileEvt($file, $fileFormat, $$refExtractParams{expressions}, $AND, $lastExprIndex, \@groupExpr);
                  } elsif ($optSet)         { # Search with options
                    ($fileLines, $fileResults, $refListResult) = &extractExprOptFileEvt($file, $fileFormat, $refExtractParams, $AND, $lastExprIndex);
                  } elsif ($AND or $$refExtractParams{noDupl}) { # Search and match (with AND or No Duplicate selected)
                    ($fileLines, $fileResults, $refListResult) = &extractExprFileEvt(   $file, $fileFormat, $$refExtractParams{expressions}, $AND, $lastExprIndex);
                  } else                    { # Search all (only one expr, or only OR in list and duplicate allowed)
                    ($fileLines, $fileResults, $refListResult) = &extractExprAllFileEvt($file, $fileFormat, $$refExtractParams{expressions});
                  }
                  $formatFound = 1 if $fileResults;
                # Pdf
                } elsif ($fileFormat eq 'Pdf') {
                  if ($$refExtractParams{modeByFile}) { # Search by file
                    ($fileResults) = &extractExprByFilePdf($file, $$refExtractParams{expressions}, $AND, $lastExprIndex, \@groupExpr);
                  } elsif ($optSet)         { # Search with options
                    ($fileLines, $fileResults, $refListResult) = &extractExprOptFilePdf($file, $refExtractParams, $AND, $lastExprIndex);
                  } elsif ($AND or $$refExtractParams{noDupl}) { # Search and match (with AND or No Duplicate selected)
                    ($fileLines, $fileResults, $refListResult) = &extractExprFilePdf(   $file, $$refExtractParams{expressions}, $AND, $lastExprIndex);
                  } else                    { # Search all (only one expr, or only OR in list and duplicate allowed)
                    ($fileLines, $fileResults, $refListResult) = &extractExprAllFilePdf($file, $$refExtractParams{expressions});
                  }
                  $formatFound = 1 if $fileResults;
                # Msg
                } elsif ($fileFormat eq 'Msg') {
                  if ($$refExtractParams{modeByFile}) { # Search by file
                    ($fileResults) = &extractExprByFileMsg($file, $$refExtractParams{expressions}, $AND, $lastExprIndex, \@groupExpr);
                  } elsif ($optSet)         { # Search with options
                    ($fileLines, $fileResults, $refListResult) = &extractExprOptFileMsg($file, $refExtractParams, $AND, $lastExprIndex);
                  } elsif ($AND or $$refExtractParams{noDupl}) { # Search and match (with AND or No Duplicate selected)
                    ($fileLines, $fileResults, $refListResult) = &extractExprFileMsg(   $file, $$refExtractParams{expressions}, $AND, $lastExprIndex);
                  } else                    { # Search all (only one expr, or only OR in list and duplicate allowed)
                    ($fileLines, $fileResults, $refListResult) = &extractExprAllFileMsg($file, $$refExtractParams{expressions});
                  }
                  $formatFound = 1 if $fileResults;
                # Zip
                } elsif ($fileFormat eq 'Zip') {
                  if ($$refExtractParams{modeByFile}) { # Search by file
                    ($fileResults) = &extractExprByFileZip($file, $$refExtractParams{expressions}, $AND, $lastExprIndex, \@groupExpr);
                  } elsif ($optSet)         { # Search with options
                    ($fileLines, $fileResults, $refListResult) = &extractExprOptFileZip($file, $$refExtractParams, $AND, $lastExprIndex);
                  } elsif ($AND or $$refExtractParams{noDupl}) { # Search and match (with AND or No Duplicate selected)
                    ($fileLines, $fileResults, $refListResult) = &extractExprFileZip(   $file, $$refExtractParams{expressions}, $AND, $lastExprIndex);
                  } else                    { # Search all (only one expr, or only OR in list and duplicate allowed)
                    ($fileLines, $fileResults, $refListResult) = &extractExprAllFileZip($file, $$refExtractParams{expressions});
                  }
                  $formatFound = 1 if $fileResults;
                }
              }
              last if $formatFound;
            }
            last if $formatFound;
          }
          # Update stats
          $results{totResFiles}++;
          $results{totResLines}   += $fileLines;
          my $fileSize    = (stat($file))[7];
          $results{totResSize}    += $fileSize if $fileSize;
          my $sizeStr     = &formatFileSize($results{totResSize});
          my $currTime    = time;
          my $diffTime    = $currTime - $startTime;
          my ($diffD, $diffH, $diffM, $diffS) = (gmtime $diffTime)[7,2,1,0];
          my $duration;
          $duration .= "$diffD days, " if $diffD;
          $duration .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
          $results{totResResults} += $fileResults;
          $winResults->lblResStatsFilesVal->Text($results{totResFiles});
          $winResults->lblResStatsLinesVal->Text($results{totResLines});
          $winResults->lblResStatsSizeVal->Text($sizeStr);
          $winResults->lblResStatsDurationVal->Text($duration);
          $winResults->lblResStatsResultsVal->Text($results{totResResults});
          if ($fileResults) {
            # Add results to file
            if ($refListResult) {
              if (open(my $tmpFH, '>>', $tmpReport)) {
                foreach (@{$refListResult}) { print $tmpFH "$file\t$_\n"; }
                close($tmpFH);
              }
            }
          }
          # Compile results
          # By file
          $results{byFile}{$file}{fileSize}   =  $fileSize if $fileSize; # Size
          $results{byFile}{$file}{nbrLines}   = $fileLines;   # Number of lines
          $results{byFile}{$file}{nbrResults} = $fileResults; # Number of results
          # Add file to the grid By files
          if (my $newLine = $winResults->gridResFiles->InsertRow($file, -1)) {
            $winResults->gridResFiles->SetCellText($newLine, 0, $file        ); # File path
            $winResults->gridResFiles->SetCellFormat($newLine, 1, 2);
            $winResults->gridResFiles->SetCellFormat($newLine, 2, 2);
            $winResults->gridResFiles->SetCellFormat($newLine, 3, 2);
            $winResults->gridResFiles->SetCellText($newLine, 1, $fileSize    ) if $fileSize; # Size
            $winResults->gridResFiles->SetCellText($newLine, 2, $fileLines   ); # Number of lines
            $winResults->gridResFiles->SetCellText($newLine, 3, $fileResults ); # Number of results
          }
          $winResults->gridResFiles->AutoSize();
          $winResults->gridResFiles->ExpandColumnsToFit() if $winResults->gridResFiles->GetVirtualWidth() < $winResults->gridResFiles->Width();
          $winResults->gridResFiles->Refresh();
          # By expression
          foreach my $index (keys %{$$refExtractParams{expressions}}) {
            if ($$refExtractParams{expressions}{$index}{nbrRes}) {
              my $expr;
              $expr .= "[$STR{'Invert'}] " if $$refExtractParams{expressions}{$index}{invert};
              $expr .= $$refExtractParams{expressions}{$index}{expr};
              if ($results{byExpr}{$expr}) {
                $results{byExpr}{$expr}{nbrRes} += $$refExtractParams{expressions}{$index}{nbrRes};
              } else {
                $results{byExpr}{$expr}{nbrRes} = $$refExtractParams{expressions}{$index}{nbrRes};
                $results{byExpr}{$expr}{case}   = 1 if $$refExtractParams{expressions}{$index}{case};
                $results{byExpr}{$expr}{regex}  = 1 if $$refExtractParams{expressions}{$index}{regex};
                $results{byExpr}{$expr}{invert} = 1 if $$refExtractParams{expressions}{$index}{invert};
              }
              # If Expression is already in grid, update it
              my $exist = 0;
              for (my $i = 1; $i < $winResults->gridResExpr->GetRows(); $i++) {
                my $currExpr = $winResults->gridResExpr->GetCellText($i, 0);
                if ($expr eq $currExpr) {
                  $winResults->gridResExpr->SetCellText($i, 4, $results{byExpr}{$expr}{nbrRes});
                  $exist = 1;
                  last;
                }
              }
              # Doesn't exist, create a row
              if (!$exist and my $newLine = $winResults->gridResExpr->InsertRow($expr, -1)) {
                $winResults->gridResExpr->SetCellText($newLine, 0, $expr);
                $winResults->gridResExpr->SetCellType($newLine, 1, 4);
                $winResults->gridResExpr->SetCellType($newLine, 2, 4);
                $winResults->gridResExpr->SetCellType($newLine, 3, 4);
                if ($results{byExpr}{$expr}{case})   { $winResults->gridResExpr->SetCellCheck($newLine, 1, 1);  }
                else                                 { $winResults->gridResExpr->SetCellCheck($newLine, 1, 0);  }
                if ($results{byExpr}{$expr}{regex})  { $winResults->gridResExpr->SetCellCheck($newLine, 2, 1);  }
                else                                 { $winResults->gridResExpr->SetCellCheck($newLine, 2, 0);  }
                if ($results{byExpr}{$expr}{invert}) { $winResults->gridResExpr->SetCellCheck($newLine, 3, 1);  }
                else                                 { $winResults->gridResExpr->SetCellCheck($newLine, 3, 0);  }
                $winResults->gridResExpr->SetCellText($newLine, 4, $results{byExpr}{$expr}{nbrRes});
              }
              $winResults->gridResExpr->AutoSize();
              $winResults->gridResExpr->ExpandColumnsToFit() if $winResults->gridResExpr->GetVirtualWidth()  < $winResults->gridResExpr->Width();
              $winResults->gridResExpr->Refresh();
            }
          }
          $count++;
          $winResults->lblCount->Text("$count / $nbrFiles");
          $winResults->pb->StepIt();
          # Reset number of result for expression
          foreach my $index (keys %{$$refExtractParams{expressions}}) { $$refExtractParams{expressions}{$index}{nbrRes} = 0; }
        }
        $winResults->btnSaveResultsExtract->Enable();
        $winResults->btnWinReport->Enable();
        # Store results in a JSON file
        if (scalar(keys %results) and open(my $json, '>:encoding(cp1252)', "$REPORTDIR\\CurrentExtractResults-" . $PROCESSID .'.json')) {
          my $jsonObj = JSON->new;
          my $jsonText = $jsonObj->encode(\%results);
          print $json $jsonText;
          close($json);
        }
      } else { Win32::GUI::MessageBox($winResults, $STR{'noFile'}, $STR{'error'}, 0x40010); } # No files
      $winResults->pb->SetPos(0);
      $winResults->pb->Hide;
      $winResults->lblCurr->Text('');
      $winResults->lblCount->Text('');
      $winResults->ChangeCursor($ARROW);
      $winResults->btnCancelExtract->Hide();
      $winResults->btnCloseWinResults->Show();
    });
  }

}  #--- End extractExprFiles

#------------------------------------------------------------------------------#
sub extractExprByFileTxt
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions, $AND, $lastExprIndex, $refExprGroups) = @_;
  # Text file
  if (open(my $fh, $file)) {
    if ($AND) {
      if ((stat($file))[7] < 10000) { # If file size is less then 10 Mb, we analyse whole file in once
        my $file_as_string = do { local $/ = <$fh> };
        $file_as_string =~ s/[\r\n]//g;
        my $nbrGroups = scalar(@{$refExprGroups});
        for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
          my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
					my ($nbrResLine, $refListResLine) = &extractExprString($file_as_string, $$refExprGroups[$i], $AND, $lastExprIndexInGroup);
					if ($nbrResLine) { next; } # One expr of the group has been found, go to next group
          # No expr of the group has been found, we can stop here
					else {
            close($fh);
            return(0);
          }
				}
        close($fh);
        return(1);
      } else {
        my $nbrGroups = scalar(@{$refExprGroups});
        for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
          my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
          my $found = 0;
          while (<$fh>) {
            s/[\n\r]//g;
            if ($_) {
              my ($nbrResLine, $refListResLine) = &extractExprString($_, $$refExprGroups[$i], 0, $lastExprIndexInGroup);
              if ($nbrResLine) { # One expr of the group has been found, go to next group
                $found = 1;
                close($fh);
                open($fh, $file);
                last;
              }
            }
          }
          # No expr of the group has been found, we can stop here
          if (!$found) {
            close($fh);
            return(0);
          }
        }
        close($fh);
        return(1);
      }
    } else { # No AND, if only one expression is found, no need to continue
      while (<$fh>) {
        s/[\n\r]//g;
        if ($_) {
          my ($nbrResLine, $refListResLine) = &extractExprString($_, $refExpressions, $AND, $lastExprIndex);
          if ($nbrResLine) { return(1); }
        }
      }
    }
    close($fh);
  }
  
  return(0);
  
}  #--- End extractExprByFileTxt

#------------------------------------------------------------------------------#
sub extractExprOptFileTxt
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExtractParams, $AND, $lastExprIndex) = @_;
  my $incContext       = 1 if ($$refExtractParams{linesBefore} or $$refExtractParams{linesAfter});
  my $lastExLine       = 0; # Last line number where result has been found
  my $nbrExLines       = 0; # Number of extracted lines
  my $end              = 0; # End of extraction, but context after may be added
  my $endContextAfter  = 1; # End of context after
  my $nbrLinesNotEmpty = 0;
  my $nbrLines         = 0;
  my $nbrResults       = 0;
  my @tmpLinesBefore;
  my @listResFile;
  # Clipboard
  if ($file eq 'Clipboard' and $$refExtractParams{inputType} eq 'Clipboard' and Win32::Clipboard::IsText() and my $text = Win32::Clipboard::GetText()) {
    my @tab = split(/\n/, $text);
    foreach (@tab) {
      s/[\n\r]//g;
      my $line = $_;
      if ($line) {
        my ($nbrResLine, $refListResLine);
        ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
        if ($nbrResLine) {
          $lastExLine = $nbrLinesNotEmpty;
          $nbrExLines++;
          # Add line before ?
          if ($incContext and $$refExtractParams{linesBefore}) {
            push(@listResFile, "\n");
            push(@listResFile, @tmpLinesBefore);
            @tmpLinesBefore = (); # Empty array of lines before
          }
          # Add extracted line
          push(@listResFile, @{$refListResLine});
          $nbrResults += $nbrResLine;
          $endContextAfter = 0 if $incContext and $endContextAfter;
        # Keep line ?
        } else {
          # Context before
          if ($endContextAfter) {
            if ($incContext and $$refExtractParams{linesBefore}) {
              push(@listResFile, "\n");
              push(@tmpLinesBefore, $line);
              my $nbrItems = @tmpLinesBefore;
              # Array is full, remove first item
              shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
            }
          # Context after
          } else {
            # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
            if ($nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
              push(@listResFile, $line);
              # Last line to add
              if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                if ($end) { last; } # Finish extraction
                else { push(@listResFile, "\n"); } # Not finished, add a new line
              }
            } else { $endContextAfter = 1; }
          }
        }
        $nbrLinesNotEmpty++;
      }
      $nbrLines++;
      # If maximum of result has been reached
      if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
          $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
        # No line to add, no need to continue
        last if !$$refExtractParams{linesAfter};
        $end++;
      }
    }
  # Text file
  } else {
    if (open(my $fh, $file)) {
      while (<$fh>) {
        s/[\n\r]//g;
        my $line = $_;
        if ($line) {
          my ($nbrResLine, $refListResLine);
          ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
          if ($nbrResLine) {
            $lastExLine = $nbrLines;
            $nbrExLines++;
            # Add line before ?
            if ($incContext and $$refExtractParams{linesBefore}) {
              push(@listResFile, "\n");
              push(@listResFile, @tmpLinesBefore);
              @tmpLinesBefore = (); # Empty array of lines before
            }
            # Add extracted line
            push(@listResFile, @{$refListResLine});
            $nbrResults += $nbrResLine;
            $endContextAfter = 0 if $incContext and $endContextAfter;
          # Keep line ?
          } else {
            # Context before
            if ($endContextAfter) {
              if ($incContext and $$refExtractParams{linesBefore}) {
                push(@listResFile, "\n");
                push(@tmpLinesBefore, $line);
                my $nbrItems = @tmpLinesBefore;
                # Array is full, remove first item
                shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
              }
            # Context after
            } else {
              # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
              if ($nbrLines <= ($lastExLine + $$refExtractParams{linesAfter})) {
                push(@listResFile, $line);
                # Last line to add
                if ($nbrLines == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                  if ($end) { last; } # Finish extraction
                  else { push(@listResFile, "\n"); } # Not finished, add a new line 
                }
              } else { $endContextAfter = 1; }
            }
          }
        }
        $nbrLines++;
        # If maximum of result has been reached
        if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
            $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
          # No line to add, no need to continue
          last if !$$refExtractParams{linesAfter};
          $end++;
        }
      }
      close($fh);
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);  
  
}  #--- End extractExprOptFileTxt

#------------------------------------------------------------------------------#
sub extractExprFileTxt
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions, $AND, $lastExprIndex, $clipboard) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Clipboard
  if ($file eq 'Clipboard' and $clipboard eq 'Clipboard' and Win32::Clipboard::IsText() and my $text = Win32::Clipboard::GetText()) {
    my @tab = split(/\n/, $text);
    foreach (@tab) {
      s/[\n\r]//g;
      if ($_) {
        my ($nbrResLine, $refListResLine) = &extractExprString($_, $refExpressions, $AND, $lastExprIndex);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
      }
      $nbrLines++;
    }
  # Text file
  } else {
    if (open(my $fh, $file)) {
      while (<$fh>) {
        s/[\n\r]//g;
        my ($nbrResLine, $refListResLine) = &extractExprString($_, $refExpressions, $AND, $lastExprIndex);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
        $nbrLines++;
      }
      close($fh);
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprFileTxt

#------------------------------------------------------------------------------#
sub extractExprAllFileTxt
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions, $clipboard) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Clipboard
  if ($file eq 'Clipboard' and $clipboard eq 'Clipboard' and Win32::Clipboard::IsText() and my $text = Win32::Clipboard::GetText()) {
    my @tab = split(/\n/, $text);
    foreach (@tab) {
      s/[\n\r]//g;
      if ($_) {
        my ($nbrResLine, $refListResLine) = &extractExprStringAll($_, $refExpressions);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
      }
      $nbrLines++;
    }
  # Text file
  } else {
    if (open(my $fh, $file)) {
      while (<$fh>) {
        s/[\n\r]//g;
        my ($nbrResLine, $refListResLine) = &extractExprStringAll($_, $refExpressions);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
        $nbrLines++;
      }
      close($fh);
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprAllFileTxt

#------------------------------------------------------------------------------#
sub extractExprByFileUnicode
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileType, $refExpressions, $AND, $lastExprIndex, $refExprGroups) = @_;
  my $fh;
  # HTML type
  if ($fileType eq 'HTML') { $fh = html_file($file); }
  # Other type
  else {
    my $encoding;
    open(my $fhTmp, $file);
    binmode($fhTmp);
    if (read($fhTmp, my $filestart, 500)) {
      if (my $enc = guess_encoding($filestart)) {
        if (defined $enc and $enc !~ /ambiguous/ and $enc !~ /No appropriate encodings found/) {
          if (my $enco = $enc->name) { $encoding = "<:encoding(" . $enco . ")"; }
        }
      }
    }
    close($fhTmp);
    open($fh, $encoding, $file);
  }
  if ($fh) {
    if ($AND) {
      if ((stat($file))[7] < 10000) { # If file size is less then 10 Mb, we analyse whole file in once
        my $file_as_string = do { local $/ = <$fh> };
        $file_as_string =~ s/[\r\n]//g;
        my $nbrGroups = scalar(@{$refExprGroups});
        for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
          my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
					my ($nbrResLine, $refListResLine) = &extractExprString($file_as_string, $$refExprGroups[$i], $AND, $lastExprIndexInGroup);
					if ($nbrResLine) { next; } # One expr of the group has been found, go to next group
          # No expr of the group has been found, we can stop here
					else {
            close($fh);
            return(0);
          }
				}
        close($fh);
        return(1);
      } else {
        my $nbrGroups = scalar(@{$refExprGroups});
        for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
          my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
          my $found = 0;
          while (<$fh>) {
            s/[\n\r]//g;
            if ($_) {
              my ($nbrResLine, $refListResLine) = &extractExprString($_, $$refExprGroups[$i], 0, $lastExprIndexInGroup);
              if ($nbrResLine) { # One expr of the group has been found, go to next group
                $found = 1;
                close($fh);
                open($fh, $file);
                last;
              }
            }
          }
          if (!$found) { # No expr of the group has been found, we can stop here
            close($fh);
            return(0);
          }
        }
        close($fh);
        return(1);
      }
    } else { # No AND, if only one expression is found, no need to continue
      while (<$fh>) {
        s/[\n\r]//g;
        if ($_) {
          my ($nbrResLine, $refListResLine) = &extractExprString($_, $refExpressions, $AND, $lastExprIndex);
          if ($nbrResLine) { return(1); }
        }
      }
    }
    close($fh);
  }
  return(0);
  
}  #--- End extractExprByFileUnicode

#------------------------------------------------------------------------------#
sub extractExprOptFileUnicode
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileType, $refExtractParams, $AND, $lastExprIndex) = @_;
  my $incContext       = 1 if ($$refExtractParams{linesBefore} or $$refExtractParams{linesAfter});
  my $lastExLine       = 0; # Last line number where result has been found
  my $nbrExLines       = 0; # Nunmber of extracted lines
  my $end              = 0; # End of extraction, but context after may be added
  my $endContextAfter  = 1; # End of context after
  my $nbrLinesNotEmpty = 0;
  my $nbrLines         = 0;
  my $nbrResults       = 0;
  my @tmpLinesBefore;
  my @listResFile;
  my $fh;
  # HTML type
  if ($fileType eq 'HTML') { $fh = html_file($file); }
  # Other type
  else {
    my $encoding;
    open(my $fhTmp, $file);
    binmode($fhTmp);
    if (read($fhTmp, my $filestart, 500)) {
      if (my $enc = guess_encoding($filestart)) {
        if (defined $enc and $enc !~ /ambiguous/ and $enc !~ /No appropriate encodings found/) {
          if (my $enco = $enc->name) { $encoding = "<:encoding(" . $enco . ")"; }
        }
      }
    }
    close($fhTmp);
    open($fh, $encoding, $file);
  }
  if ($fh) {
    while (<$fh>) {
      s/[\n\r]//g;
      my $line = $_;
      if ($line) {
        my ($nbrResLine, $refListResLine);
        ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
        if ($nbrResLine) {
          $lastExLine = $nbrLinesNotEmpty;
          $nbrExLines++;
          # Add line before ?
          if ($incContext and $$refExtractParams{linesBefore}) {
            push(@listResFile, "\n");
            push(@listResFile, @tmpLinesBefore);
            @tmpLinesBefore = (); # Empty array of lines before
          }
          # Add extracted line
          push(@listResFile, @{$refListResLine});
          $nbrResults += $nbrResLine;
          $endContextAfter = 0 if $incContext and $endContextAfter;
        # Keep line ?
        } else {
          # Context before
          if ($endContextAfter) {
            if ($incContext and $$refExtractParams{linesBefore}) {
              push(@listResFile, "\n");
              push(@tmpLinesBefore, $line);
              my $nbrItems = @tmpLinesBefore;
              # Array is full, remove first item
              shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
            }
          # Context after
          } else {
            # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
            if ($nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
              push(@listResFile, $line);
              # Last line to add
              if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                # Finish extraction
                if ($end) { last; }
                # Not finished, add a new line
                else { push(@listResFile, "\n"); }
              }
            } else { $endContextAfter = 1; }
          }
        }
        $nbrLinesNotEmpty++;
      }
      $nbrLines++;
      # If maximum of result has been reached
      if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
          $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
        # No line to add, no need to continue
        last if !$$refExtractParams{linesAfter};
        $end++;
      }
    }
    close($fh);
  }
  return($nbrLines, $nbrResults, \@listResFile);  
  
}  #--- End extractExprOptFileUnicode

#------------------------------------------------------------------------------#
sub extractExprFileUnicode
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileType, $refExpressions, $AND, $lastExprIndex) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  my $fh;
  # HTML type
  if ($fileType eq 'HTML') { $fh = html_file($file); }
  # Other type
  else {
    my $encoding;
    open(my $fhTmp, $file);
    binmode($fhTmp);
    if (read($fhTmp, my $filestart, 500)) {
      if (my $enc = guess_encoding($filestart)) {
        if (defined $enc and $enc !~ /ambiguous/ and $enc !~ /No appropriate encodings found/) {
          if (my $enco = $enc->name) { $encoding = "<:encoding(" . $enco . ")"; }
        }
      }
    }
    close($fhTmp);
    open($fh, $encoding, $file);
  }
  if ($fh) {
    while (<$fh>) {
      s/[\n\r]//g;
      my ($nbrResLine, $refListResLine) = &extractExprString($_, $refExpressions, $AND, $lastExprIndex);
      if ($nbrResLine) {
        $nbrResults += $nbrResLine;
        push(@listResFile, @{$refListResLine});
      }
      $nbrLines++;
    }
    close($fh);
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprFileUnicode

#------------------------------------------------------------------------------#
sub extractExprAllFileUnicode
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileType, $refExpressions) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  my $fh;
  # HTML type
  if ($fileType eq 'HTML') { $fh = html_file($file); }
  # Other type
  else {
    my $encoding;
    open(my $fhTmp, $file);
    binmode($fhTmp);
    if (read($fhTmp, my $filestart, 500)) {
      if (my $enc = guess_encoding($filestart)) {
        if (defined $enc and $enc !~ /ambiguous/ and $enc !~ /No appropriate encodings found/) {
          if (my $enco = $enc->name) { $encoding = "<:encoding(" . $enco . ")"; }
        }
      }
    }
    close($fhTmp);
    open($fh, $encoding, $file);
  }
  if ($fh) {
    while (<$fh>) {
      s/[\n\r]//g;
      my ($nbrResLine, $refListResLine) = &extractExprStringAll($_, $refExpressions);
      if ($nbrResLine) {
        $nbrResults += $nbrResLine;
        push(@listResFile, @{$refListResLine});
      }
      $nbrLines++;
    }
    close($fh);
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprAllFileUnicode

#------------------------------------------------------------------------------#
sub extractExprByFileDoc
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $MSWordOpt, $refExpressions, $AND, $lastExprIndex, $refExprGroups) = @_;
  # Using MS Word (Work for Doc and Docx)
  if ($MSWordOpt eq 'MSWORD=1') {
    if (my $document = Win32::OLE->GetObject($file, sub {$_[0]->Quit;})) {
      if ($AND) {
        my $nbrGroups = scalar(@{$refExprGroups});
        for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
          my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
          my $found = 0;
          if (my $paragraphs = $document->Paragraphs()) {
            if (my $enumerate  = new Win32::OLE::Enum($paragraphs)) {
              while(defined(my $paragraph = $enumerate->Next())) {
                my $line = $paragraph->{Range}->{Text};
                $line    =~ s/[\n\r]//g;
                $line    =~ s/\x0b/\n/g;
                if ($line) {
                  my ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExprGroups[$i], 0, $lastExprIndexInGroup);
                  if ($nbrResLine) { # One expr of the group has been found, go to next group
                    $found = 1;
                    $document->close();
                    $document->Quit;
                    Win32::OLE->QuitMessageLoop();
                    Win32::OLE->Uninitialize();
                    $document = Win32::OLE->GetObject($file, sub {$_[0]->Quit;});
                    last;
                  }
                }
              }
            }
          }
          # No expr of the group has been found, we can stop here
          if (!$found) {
            $document->close();
            $document->Quit;
            Win32::OLE->QuitMessageLoop();
            Win32::OLE->Uninitialize();
            return(0);
          }
        }
        $document->close();
        $document->Quit;
        Win32::OLE->QuitMessageLoop();
        Win32::OLE->Uninitialize();
        return(1);
      } else { # No AND, if only one expression is found, no need to continue
        if (my $paragraphs = $document->Paragraphs()) {
          if (my $enumerate  = new Win32::OLE::Enum($paragraphs)) {
            while(defined(my $paragraph = $enumerate->Next())) {
              my $line = $paragraph->{Range}->{Text};
              $line    =~ s/[\n\r]//g;
              $line    =~ s/\x0b/\n/g;
              if ($line) {
                my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
                if ($nbrResLine) {
                  $document->close();
                  $document->Quit;
                  Win32::OLE->QuitMessageLoop();
                  Win32::OLE->Uninitialize();
                  return(1);
                }
              }
            }
          }
        }
      }
      $document->close();
      $document->Quit;
      Win32::OLE->QuitMessageLoop();
      Win32::OLE->Uninitialize();
    }
  # Without MS Word (Doc)
  } elsif ($fileFormat eq 'Doc') {
    if (my $extract = Text::Extract::Word->new($file)) {
      if (my $text = $extract->get_text(':raw')) {
        my $nbrGroups = scalar(@{$refExprGroups});
        for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
          my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
					my ($nbrResLine, $refListResLine) = &extractExprString($text, $$refExprGroups[$i], $AND, $lastExprIndexInGroup);
					if ($nbrResLine) { next; } # One expr of the group has been found, go to next group
          # No expr of the group has been found, we can stop here
					else { return(0); }
				}
        return(1);
      }
    }
  # Without MS Word (Docx)
  } elsif ($fileFormat eq 'Docx') {
    # Use Zip parser
    if (my $zip = Archive::Zip->new($file)) {
      my @members = $zip->membersMatching('^word/(document|endnotes)\.xml');
      foreach my $member (@members) {
        if (my $reader = new XML::LibXML::Reader(string => $member->contents().'')) {
          if ($AND) {
            my $nbrGroups = scalar(@{$refExprGroups});
            for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
              my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
              my $found = 0;
              my $line;
              while ($reader->read) {
                if ($reader->nodePath =~ /\/w:p$/ and $line) {
                  chop($line);
                  if ($line) {
                    my ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExprGroups[$i], $AND, $lastExprIndexInGroup);
                    if ($nbrResLine) {
                      $found = 1;
                      $reader->finish;
                      $reader = new XML::LibXML::Reader(string => $member->contents().'');
                      last;
                    }
                  }
                  $line = '';
                } elsif ($reader->nodePath =~ /\/w:t\/text()/) { $line .= $reader->value . "\t"; }
              }
              # No expr of the group has been found, we can stop here
              if (!$found) {
                $reader->finish;
                return(0);
              }
            }
            $reader->finish;
            return(1);
          } else { # No AND, if only one expression is found, no need to continue
            my $line;
            while ($reader->read) {
              if ($reader->nodePath =~ /\/w:p$/ and $line) {
                chop($line);
                if ($line) {
                  my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
                  if ($nbrResLine) {
                    $reader->finish;
                    return(1);
                  }
                }
              } elsif ($reader->nodePath =~ /\/w:t\/text()/) { $line .= $reader->value . "\t"; }
            }
          }
          $reader->finish;
        }
      }
    }
  }
  return(0);
  
}  #--- End extractExprByFileDoc

#------------------------------------------------------------------------------#
sub extractExprOptFileDoc
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $MSWordOpt, $refExtractParams, $AND, $lastExprIndex) = @_;
  my $incContext       = 1 if ($$refExtractParams{linesBefore} or $$refExtractParams{linesAfter});
  my $lastExLine       = 0; # Last line number where result has been found
  my $nbrExLines       = 0; # Nunmber of extracted lines
  my $end              = 0; # End of extraction, but context after may be added
  my $endContextAfter  = 1; # End of context after
  my $nbrLinesNotEmpty = 0;
  my $nbrLines         = 0;
  my $nbrResults       = 0;
  my @tmpLinesBefore;
  my @listResFile;
  # Using MS Word (Work for Doc and Docx)
  if ($MSWordOpt eq 'MSWORD=1') {
    if (my $document = Win32::OLE->GetObject($file, sub {$_[0]->Quit;})) {
      if (my $paragraphs = $document->Paragraphs()) {
        if (my $enumerate  = new Win32::OLE::Enum($paragraphs)) {
          while(defined(my $paragraph = $enumerate->Next())) {
            my $line = $paragraph->{Range}->{Text};
            $line    =~ s/[\n\r]//g;
            $line    =~ s/\x0b/\n/g;
            if ($line) {
              my ($nbrResLine, $refListResLine);
              ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
              if ($nbrResLine) {
                $lastExLine = $nbrLinesNotEmpty;
                $nbrExLines++;
                # Add line before ?
                if ($incContext and $$refExtractParams{linesBefore}) {
                  push(@listResFile, "\n");
                  push(@listResFile, @tmpLinesBefore);
                  @tmpLinesBefore = (); # Empty array of lines before
                }
                # Add extracted line
                push(@listResFile, @{$refListResLine});
                $nbrResults += $nbrResLine;
                $endContextAfter = 0 if $incContext and $endContextAfter;
              # Keep line ?
              } else {
                # Context before
                if ($endContextAfter) {
                  if ($incContext and $$refExtractParams{linesBefore}) {
                    push(@listResFile, "\n");
                    push(@tmpLinesBefore, $line);
                    my $nbrItems = @tmpLinesBefore;
                    # Array is full, remove first item
                    shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
                  }
                # Context after
                } else {
                  # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
                  if ($nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
                    push(@listResFile, $line);
                    # Last line to add
                    if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                      if ($end) { last; } 							 # Finish extraction
                      else { push(@listResFile, "\n"); } # Not finished, add a new line
                    }
                  } else { $endContextAfter = 1; }
                }
              }
              $nbrLinesNotEmpty++;
            }
            $nbrLines++;
            # If maximum of result has been reached
            if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
                $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
              # No line to add, no need to continue
              last if !$$refExtractParams{linesAfter};
              $end++;
            }
          }
        }
      }
      $document->close();
      $document->Quit;
      Win32::OLE->QuitMessageLoop();
      Win32::OLE->Uninitialize();
    }
  # Without MS Word (Doc)
  } elsif ($fileFormat eq 'Doc') {
    my $extract = Text::Extract::Word->new($file);
    my @tab     = split(/[\r\n]/, $extract->get_text(':raw'));
		foreach (@tab) {
      s/[\n\r]//g;
      my $line = $_;
      if ($line) {
        my ($nbrResLine, $refListResLine);
        ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
        if ($nbrResLine) {
          $lastExLine = $nbrLinesNotEmpty;
          $nbrExLines++;
          # Add line before ?
          if ($incContext and $$refExtractParams{linesBefore}) {
            push(@listResFile, "\n");
            push(@listResFile, @tmpLinesBefore);
            @tmpLinesBefore = (); # Empty array of lines before
          }
          # Add extracted line
          push(@listResFile, @{$refListResLine});
          $nbrResults += $nbrResLine;
          $endContextAfter = 0 if $incContext and $endContextAfter;
        # Keep line ?
        } else {
          # Context before
          if ($endContextAfter) {
            if ($incContext and $$refExtractParams{linesBefore}) {
              push(@listResFile, "\n");
              push(@tmpLinesBefore, $line);
              my $nbrItems = @tmpLinesBefore;
              # Array is full, remove first item
              shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
            }
          # Context after
          } else {
            # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
            if ($lastExLine != 0 and $nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
              push(@listResFile, $line);
              # Last line to add
              if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                if ($end) { last; } 							 # Finish extraction
                else { push(@listResFile, "\n"); } # Not finished, add a new line
              }
            } else { $endContextAfter = 1; }
          }
        }
        $nbrLinesNotEmpty++;
      }
      $nbrLines++;
      # If maximum of result has been reached
      if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
          $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
        # No line to add, no need to continue
        last if !$$refExtractParams{linesAfter};
        $end++;
      }
		}
  # Without MS Word (Docx)
  } elsif ($fileFormat eq 'Docx') {
    # Use Zip parser
    if (my $zip = Archive::Zip->new($file)) {
      my @members = $zip->membersMatching('^word/(document|endnotes)\.xml');
      foreach my $member (@members) {
        if (my $reader = new XML::LibXML::Reader(string => $member->contents().'')) {
          my $line;
          while ($reader->read) {
            if ($reader->nodePath =~ /\/w:p$/ and $line) {
              chop($line);
              if ($line) {
                my ($nbrResLine, $refListResLine);
                ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
                if ($nbrResLine) {
                  $lastExLine = $nbrLines;
                  $nbrExLines++;
                  # Add line before ?
                  if ($incContext and $$refExtractParams{linesBefore}) {
                    push(@listResFile, "\n");
                    push(@listResFile, @tmpLinesBefore);
                    @tmpLinesBefore = (); # Empty array of lines before
                  }
                  # Add extracted line
                  push(@listResFile, @{$refListResLine});
                  $nbrResults += $nbrResLine;
                  $endContextAfter = 0 if $incContext and $endContextAfter;
                # Keep line ?
                } else {
                  # Context before
                  if ($endContextAfter) {
                    if ($incContext and $$refExtractParams{linesBefore}) {
                      push(@listResFile, "\n");
                      push(@tmpLinesBefore, $line);
                      my $nbrItems = @tmpLinesBefore;
                      # Array is full, remove first item
                      shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
                    }
                  # Context after
                  } else {
                    # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
                    if ($lastExLine != 0 and $nbrLines <= ($lastExLine + $$refExtractParams{linesAfter})) {
                      push(@listResFile, $line);
                      # Last line to add
                      if ($nbrLines == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                        if ($end) { last; } 							 # Finish extraction
                        else { push(@listResFile, "\n"); } # Not finished, add a new line
                      }
                    } else { $endContextAfter = 1; }
                  }
                }
              }
              $nbrLines++;
              # If maximum of result has been reached
              if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
                  $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
                # No line to add, no need to continue
                last if !$$refExtractParams{linesAfter};
                $end++;
              }
              $line = '';
            } elsif ($reader->nodePath =~ /\/w:t\/text()/) { $line .= $reader->value . "\t"; }
          }
          $reader->finish;
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);  
  
}  #--- End extractExprOptFileDoc

#------------------------------------------------------------------------------#
sub extractExprFileDoc
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $MSWordOpt, $refExpressions, $AND, $lastExprIndex) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Using MS Word (Work for Doc and Docx)
  if ($MSWordOpt eq 'MSWORD=1') {
    if (my $document = Win32::OLE->GetObject($file, sub {$_[0]->Quit;})) {
      if (my $paragraphs = $document->Paragraphs()) {
        if (my $enumerate  = new Win32::OLE::Enum($paragraphs)) {
          while(defined(my $paragraph = $enumerate->Next())) {
            my $line = $paragraph->{Range}->{Text};
            $line    =~ s/[\n\r]//g;
            $line    =~ s/\x0b/\n/g;
            my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
            if ($nbrResLine) {
              $nbrResults += $nbrResLine;
              push(@listResFile, @{$refListResLine});
            }
            $nbrLines++;
          }
        }
      }
      $document->close();
      $document->Quit;
      Win32::OLE->QuitMessageLoop();
      Win32::OLE->Uninitialize();
    }
  # Without MS Word (Doc)
  } elsif ($fileFormat eq 'Doc') {
    my $extract = Text::Extract::Word->new($file);
    my @tab     = split(/[\r\n]/, $extract->get_text(':raw'));
		foreach (@tab) {
      s/[\n\r]//g;
      my ($nbrResLine, $refListResLine) = &extractExprString($_, $refExpressions, $AND, $lastExprIndex);
      if ($nbrResLine) {
        $nbrResults += $nbrResLine;
        push(@listResFile, @{$refListResLine});
      }
      $nbrLines++;
		}
  # Without MS Word (Docx)
  } elsif ($fileFormat eq 'Docx') {
    # Use Zip parser
    if (my $zip = Archive::Zip->new($file)) {
      my @members = $zip->membersMatching('^word/(document|endnotes)\.xml');
      foreach my $member (@members) {
        if (my $reader = new XML::LibXML::Reader(string => $member->contents().'')) {
          my $line;
          while ($reader->read) {
            if ($reader->nodePath =~ /\/w:p$/ and $line) {
              chop($line);
              my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
              if ($nbrResLine) {
                $nbrResults += $nbrResLine;
                push(@listResFile, @{$refListResLine});
              }
              $nbrLines++;
              $line = '';
            } elsif ($reader->nodePath =~ /\/w:t\/text()/) { $line .= $reader->value . "\t"; }
          }
          $reader->finish;
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprFileDoc

#------------------------------------------------------------------------------#
sub extractExprAllFileDoc
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $MSWordOpt, $refExpressions) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Using MS Word (Work for Doc and Docx)
  if ($MSWordOpt eq 'MSWORD=1') {
    if (my $document = Win32::OLE->GetObject($file, sub {$_[0]->Quit;})) {
      if (my $paragraphs = $document->Paragraphs()) {
        if (my $enumerate  = new Win32::OLE::Enum($paragraphs)) {
          while(defined(my $paragraph = $enumerate->Next())) {
            my $line = $paragraph->{Range}->{Text};
            $line    =~ s/[\n\r]//g;
            $line    =~ s/\x0b/\n/g;
            my ($nbrResLine, $refListResLine) = &extractExprStringAll($line, $refExpressions);
            if ($nbrResLine) {
              $nbrResults += $nbrResLine;
              push(@listResFile, @{$refListResLine});
            }
            $nbrLines++;
          }
        }
      }
      $document->close();
      $document->Quit;
      Win32::OLE->QuitMessageLoop();
      Win32::OLE->Uninitialize();
    }
  # Without MS Word (Doc)
  } elsif ($fileFormat eq 'Doc') {
    my $extract = Text::Extract::Word->new($file);
    my @tab     = split(/[\r\n]/, $extract->get_text(':raw'));
		foreach (@tab) {
      s/[\n\r]//g;
      my ($nbrResLine, $refListResLine) = &extractExprStringAll($_, $refExpressions);
      if ($nbrResLine) {
        $nbrResults += $nbrResLine;
        push(@listResFile, @{$refListResLine});
      }
      $nbrLines++;
		}
  # Without MS Word (Docx)
  } elsif ($fileFormat eq 'Docx') {
    # Use Zip parser
    if (my $zip = Archive::Zip->new($file)) {
      my @members = $zip->membersMatching('^word/(document|endnotes)\.xml');
      foreach my $member (@members) {
        if (my $reader = new XML::LibXML::Reader(string => $member->contents().'')) {
          my $line;
          while ($reader->read) {
            if ($reader->nodePath =~ /\/w:p$/ and $line) {
              chop($line);
              my ($nbrResLine, $refListResLine) = &extractExprStringAll($line, $refExpressions);
              if ($nbrResLine) {
                $nbrResults += $nbrResLine;
                push(@listResFile, @{$refListResLine});
              }
              $nbrLines++;
              $line = '';
            } elsif ($reader->nodePath =~ /\/w:t\/text()/) { $line .= $reader->value . "\t"; }
          }
          $reader->finish;
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprAllFileDoc

#------------------------------------------------------------------------------#
sub extractExprByFileXls
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $refExpressions, $AND, $lastExprIndex, $refExprGroups) = @_;
  # Xls
  if ($fileFormat eq 'Xls') {
    my $xls;
    eval { $xls = Spreadsheet::ParseExcel::Simple->read($file); };
    if ($xls) {
      if ($AND) {
        my $nbrGroups = scalar(@{$refExprGroups});
        for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
          my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
          my $found = 0;
          foreach my $sheet ($xls->sheets) {
            while ($sheet->has_data) {
              my $line = join("\t", $sheet->next_row);
              if ($line) {
                my ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExprGroups[$i], 0, $lastExprIndexInGroup);
                if ($nbrResLine) { # One expr of the group has been found, go to next group
                  $found = 1;
                  last; # End looping row
                }
              }
            }
            last if $found; # End looping sheet
          }
          return(0) if !$found; # No expr of the group has been found, we can stop here
        }
        return(1);
      } else { # No AND, if only one expression is found, no need to continue
        foreach my $sheet ($xls->sheets) {
          while ($sheet->has_data) {
            my $line = join("\t", $sheet->next_row);
            if ($line) {
              my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
              if ($nbrResLine) { return(1); }
            }
          }
        }
      }
    }
  # Xlsx
  } elsif ($fileFormat eq 'Xlsx' and my $xlsx = Spreadsheet::XLSX->new($file)) {
    if ($AND) {
      my $nbrGroups = scalar(@{$refExprGroups});
      for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
        my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
        my $found = 0;
        foreach my $sheet (@{$xlsx->{Worksheet}}) {
          $sheet->{MaxRow} ||= $sheet->{MinRow};
          foreach my $row ($sheet->{MinRow} .. $sheet->{MaxRow}) {
            my $line;
            # Combine cells for each row
            $sheet->{MaxCol} ||= $sheet->{MinCol};
            foreach my $col ($sheet->{MinCol} ..  $sheet->{MaxCol}) {
              my $cell = $sheet->{Cells}[$row][$col];
              $line .= $cell->{Val} if $cell->{Val};
              $line .= "\t";
            }
            while ($line =~ /[\t]$/) { chop($line); }
            if ($line) {
              my ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExprGroups[$i], 0, $lastExprIndexInGroup);
              if ($nbrResLine) { # One expr of the group has been found, go to next group
                $found = 1;
                last; # End looping row
              }
            }
          }
          last if $found; # End looping sheet
        }
        return(0) if !$found; # No expr of the group has been found, we can stop here
      }
      return(1);
    } else { # No AND, if only one expression is found, no need to continue
      foreach my $sheet (@{$xlsx->{Worksheet}}) {
        $sheet->{MaxRow} ||= $sheet->{MinRow};
        foreach my $row ($sheet->{MinRow} .. $sheet->{MaxRow}) {
          my $line;
          # Combine cells for each row
          $sheet->{MaxCol} ||= $sheet->{MinCol};
          foreach my $col ($sheet->{MinCol} ..  $sheet->{MaxCol}) {
            my $cell = $sheet->{Cells}[$row][$col];
            $line .= $cell->{Val} if $cell->{Val};
            $line .= "\t";
          }
          while ($line =~ /[\t]$/) { chop($line); }
          if ($line) {
            my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
            if ($nbrResLine) { return(1); }
          }
        }
      }
    }
  }
  return(0);
  
}  #--- End extractExprByFileXls

#------------------------------------------------------------------------------#
sub extractExprOptFileXls
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $refExtractParams, $AND, $lastExprIndex) = @_;
  my $incContext       = 1 if ($$refExtractParams{linesBefore} or $$refExtractParams{linesAfter});
  my $lastExLine       = 0; # Last line number where result has been found
  my $nbrExLines       = 0; # Nunmber of extracted lines
  my $end              = 0; # End of extraction, but context after may be added
  my $endContextAfter  = 1; # End of context after
  my $nbrLinesNotEmpty = 0;
  my $nbrLines         = 0;
  my $nbrResults       = 0;
  my @tmpLinesBefore;
  my @listResFile;
  # Xls
  if ($fileFormat eq 'Xls') {
    my $xls;
    eval { $xls = Spreadsheet::ParseExcel::Simple->read($file); };
    if ($xls) {
      foreach my $sheet ($xls->sheets) {
        while ($sheet->has_data) {
          my $line = join("\t", $sheet->next_row);
          if ($line) {
            my ($nbrResLine, $refListResLine);
            ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
            if ($nbrResLine) {
              $lastExLine = $nbrLinesNotEmpty;
              $nbrExLines++;
              # Add line before ?
              if ($incContext and $$refExtractParams{linesBefore}) {
                push(@listResFile, "\n");
                push(@listResFile, @tmpLinesBefore);
                @tmpLinesBefore = (); # Empty array of lines before
              }
              # Add extracted line
              push(@listResFile, @{$refListResLine});
              $nbrResults += $nbrResLine;
              $endContextAfter = 0 if $incContext and $endContextAfter;
            # Keep line ?
            } else {
              # Context before
              if ($endContextAfter) {
                if ($incContext and $$refExtractParams{linesBefore}) {
                  push(@listResFile, "\n");
                  push(@tmpLinesBefore, $line);
                  my $nbrItems = @tmpLinesBefore;
                  # Array is full, remove first item
                  shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
                }
              # Context after
              } else {
                # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
                if ($nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
                  push(@listResFile, $line);
                  # Last line to add
                  if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                    if ($end) { last; } 							 # Finish extraction
                    else { push(@listResFile, "\n"); } # Not finished, add a new line
                  }
                } else { $endContextAfter = 1; }
              }
            }
            $nbrLinesNotEmpty++;
          }
          $nbrLines++;
          # If maximum of result has been reached
          if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
              $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
            # No line to add, no need to continue
            last if !$$refExtractParams{linesAfter};
            $end++;
          }
        }
      }
    }
  # Xlsx
  } elsif ($fileFormat eq 'Xlsx' and my $xlsx = Spreadsheet::XLSX->new($file)) {
    foreach my $sheet (@{$xlsx->{Worksheet}}) {
      $sheet->{MaxRow} ||= $sheet->{MinRow};
      foreach my $row ($sheet->{MinRow} .. $sheet->{MaxRow}) {
        my $line;
        # Combine cells for each row
        $sheet->{MaxCol} ||= $sheet->{MinCol};
        foreach my $col ($sheet->{MinCol} ..  $sheet->{MaxCol}) {
          my $cell = $sheet->{Cells}[$row][$col];
          $line .= $cell->{Val} if $cell->{Val};
          $line .= "\t";
        }
        while ($line =~ /[\t]$/) { chop($line); }
        if ($line) {
          my ($nbrResLine, $refListResLine);
          ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
          if ($nbrResLine) {
            $lastExLine = $nbrLinesNotEmpty;
            $nbrExLines++;
            # Add line before ?
            if ($incContext and $$refExtractParams{linesBefore}) {
              push(@listResFile, "\n");
              push(@listResFile, @tmpLinesBefore);
              @tmpLinesBefore = (); # Empty array of lines before
            }
            # Add extracted line
            push(@listResFile, @{$refListResLine});
            $nbrResults += $nbrResLine;
            $endContextAfter = 0 if $incContext and $endContextAfter;
          # Keep line ?
          } else {
            # Context before
            if ($endContextAfter) {
              if ($incContext and $$refExtractParams{linesBefore}) {
                push(@listResFile, "\n");
                push(@tmpLinesBefore, $line);
                my $nbrItems = @tmpLinesBefore;
                # Array is full, remove first item
                shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
              }
            # Context after
            } else {
              # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
              if ($lastExLine != 0 and $nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
                push(@listResFile, $line);
                # Last line to add
                if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                  if ($end) { last; } 							 # Finish extraction
                  else { push(@listResFile, "\n"); } # Not finished, add a new line
                }
              } else { $endContextAfter = 1; }
            }
          }
          $nbrLinesNotEmpty++;
        }
        $nbrLines++;
        # If maximum of result has been reached
        if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
            $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
          # No line to add, no need to continue
          last if !$$refExtractParams{linesAfter};
          $end++;
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);  
  
}  #--- End extractExprOptFileXls

#------------------------------------------------------------------------------#
sub extractExprFileXls
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $refExpressions, $AND, $lastExprIndex) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Xls
  if ($fileFormat eq 'Xls') {
    my $xls;
    eval { $xls = Spreadsheet::ParseExcel::Simple->read($file); };
    if ($xls) {
      foreach my $sheet ($xls->sheets) {
        while ($sheet->has_data) {
          my $line = join("\t", $sheet->next_row);
          if ($line) {
            my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
            if ($nbrResLine) {
              $nbrResults += $nbrResLine;
              push(@listResFile, @{$refListResLine});
            }
          }
          $nbrLines++;
        }
      }
    }
  # Xlsx
  } elsif ($fileFormat eq 'Xlsx' and my $xlsx = Spreadsheet::XLSX->new($file)) {
    foreach my $sheet (@{$xlsx->{Worksheet}}) {
      $sheet->{MaxRow} ||= $sheet->{MinRow};
      foreach my $row ($sheet->{MinRow} .. $sheet->{MaxRow}) {
        my $line;
        # Combine cells for each row
        $sheet->{MaxCol} ||= $sheet->{MinCol};
        foreach my $col ($sheet->{MinCol} ..  $sheet->{MaxCol}) {
          my $cell = $sheet->{Cells}[$row][$col];
          $line .= $cell->{Val} if $cell->{Val};
          $line .= "\t";
        }
        while ($line =~ /[\t]$/) { chop($line); }
        if ($line) {
          my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
          if ($nbrResLine) {
            $nbrResults += $nbrResLine;
            push(@listResFile, @{$refListResLine});
          }
        }
        $nbrLines++;
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprFileXls

#------------------------------------------------------------------------------#
sub extractExprAllFileXls
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $refExpressions) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Xls
  if ($fileFormat eq 'Xls') {
    my $xls;
    eval { $xls = Spreadsheet::ParseExcel::Simple->read($file); };
    if ($xls) {
      foreach my $sheet ($xls->sheets) {
        while ($sheet->has_data) {
          my $line = join("\t", $sheet->next_row);
          if ($line) {
            my ($nbrResLine, $refListResLine) = &extractExprStringAll($line, $refExpressions);
            if ($nbrResLine) {
              $nbrResults += $nbrResLine;
              push(@listResFile, @{$refListResLine});
            }
            $nbrLines++;
          }
        }
      }
    }
  # Xlsx
  } elsif ($fileFormat eq 'Xlsx' and my $xlsx = Spreadsheet::XLSX->new($file)) {
    foreach my $sheet (@{$xlsx->{Worksheet}}) {
      $sheet->{MaxRow} ||= $sheet->{MinRow};
      foreach my $row ($sheet->{MinRow} .. $sheet->{MaxRow}) {
        my $line;
        # Combine cells for each row
        $sheet->{MaxCol} ||= $sheet->{MinCol};
        foreach my $col ($sheet->{MinCol} ..  $sheet->{MaxCol}) {
          my $cell = $sheet->{Cells}[$row][$col];
          $line .= $cell->{Val} if $cell->{Val};
          $line .= "\t";
        }
        while ($line =~ /[\t]$/) { chop($line); }
        if ($line) {
          my ($nbrResLine, $refListResLine) = &extractExprStringAll($line, $refExpressions);
          if ($nbrResLine) {
            $nbrResults += $nbrResLine;
            push(@listResFile, @{$refListResLine});
          }
        }
        $nbrLines++;
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprAllFileXls

#------------------------------------------------------------------------------#
sub extractExprByFileEvt
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $refExpressions, $AND, $lastExprIndex, $refExprGroups) = @_;
  # Evt
  if ($fileFormat eq 'Evt' and my $evt = Parse::EventLog->new($file)) {
    my %c = $evt->getAll();
    if ($AND) {
      my $nbrGroups = scalar(@{$refExprGroups});
      for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
        my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
        my $found = 0;
        foreach my $a (keys %c) {
          my $line;
          $line  .= $c{$a}{EventID}                  . "\t";
          $line  .= localtime($c{$a}{TimeGenerated}) . "\t";
          $line  .= GetEventType($c{$a}{EventType})  . "\t";
          $line  .= $c{$a}{Source}                   . "\t";
          $line  .= $c{$a}{Computer}                 . "\t";
          my $str = $c{$a}{Strings};
          if ($str) { foreach my $s (@$str) { if ($s) { $s =~ s/[\t\r\n]/ /g; $line .= "$s|"; } } }
          chop($line);
          if ($line) {
            my ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExprGroups[$i], 0, $lastExprIndexInGroup);
            if ($nbrResLine) { # One expr of the group has been found, go to next group
              $found = 1;
              last;
            }
          }
        }
        return(0) if !$found; # No expr of the group has been found, we can stop here
      }
      return(1);
    } else { # No AND, if only one expression is found, no need to continue
      foreach my $a (keys %c) {
        my $line;
        $line  .= $c{$a}{EventID}                  . "\t";
        $line  .= localtime($c{$a}{TimeGenerated}) . "\t";
        $line  .= GetEventType($c{$a}{EventType})  . "\t";
        $line  .= $c{$a}{Source}                   . "\t";
        $line  .= $c{$a}{Computer}                 . "\t";
        my $str = $c{$a}{Strings};
        if ($str) { foreach my $s (@$str) { if ($s) { $s =~ s/[\t\r\n]/ /g; $line .= "$s|"; } } }
        chop($line);
        if ($line) {
          my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
          return(1) if $nbrResLine;
        }
      }
    }
  # Evtx
  } elsif ($fileFormat eq 'Evtx' and open(my $fh, $file)) {
    if (my $parser = Win32::EventLog->new($file)) {
      my $nbrRecs;
      my $base;
      my $x = 0;
      $parser->GetNumber($nbrRecs);
      $parser->GetOldest($base);
      if ($AND) {
        my $nbrGroups = scalar(@{$refExprGroups});
        for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
          my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
          my $found = 0;
          while ($x < $nbrRecs) {
            my $hashRef;
            if ($parser->Read(EVENTLOG_FORWARDS_READ|EVENTLOG_SEEK_READ,$base+$x,$hashRef)) {
              Win32::EventLog::GetMessageText($hashRef);
              my $line = $hashRef->{Message};
              $line = $hashRef->{Strings} if !$line;
              if ($line) {
                my ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExprGroups[$i], 0, $lastExprIndexInGroup);
                if ($nbrResLine) { # One expr of the group has been found, go to next group
                  $found = 1;
                  last;
                }
              }
            }
            $x++;
          }
          return(0) if !$found; # No expr of the group has been found, we can stop here
        }
        return(1);
      } else { # No AND, if only one expression is found, no need to continue
        while ($x < $nbrRecs) {
          my $hashRef;
          if ($parser->Read(EVENTLOG_FORWARDS_READ|EVENTLOG_SEEK_READ,$base+$x,$hashRef)) {
            Win32::EventLog::GetMessageText($hashRef);
            my $line = $hashRef->{Message};
            $line = $hashRef->{Strings} if !$line;
            if ($line) {
              my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
              if ($nbrResLine) { return(1); }
            }
          }
          $x++;
        }
      }
    }
  }
  return(0);
  
}  #--- End extractExprByFileEvt

#------------------------------------------------------------------------------#
sub extractExprOptFileEvt
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $refExtractParams, $AND, $lastExprIndex) = @_;
  my $incContext       = 1 if ($$refExtractParams{linesBefore} or $$refExtractParams{linesAfter});
  my $lastExLine       = 0; # Last line number where result has been found
  my $nbrExLines       = 0; # Nunmber of extracted lines
  my $end              = 0; # End of extraction, but context after may be added
  my $endContextAfter  = 1; # End of context after
  my $nbrLinesNotEmpty = 0;
  my $nbrLines         = 0;
  my $nbrResults       = 0;
  my @tmpLinesBefore;
  my @listResFile;
  # Evt
  if ($fileFormat eq 'Evt' and my $evt = Parse::EventLog->new($file)) {
    my %c = $evt->getAll();
    foreach my $a (keys %c) {
      my $line;
      $line  .= $c{$a}{EventID}                  . "\t";
      $line  .= localtime($c{$a}{TimeGenerated}) . "\t";
      $line  .= GetEventType($c{$a}{EventType})  . "\t";
      $line  .= $c{$a}{Source}                   . "\t";
      $line  .= $c{$a}{Computer}                 . "\t";
      my $str = $c{$a}{Strings};
      if ($str) { foreach my $s (@$str) { if ($s) { $s =~ s/[\t\r\n]/ /g; $line .= "$s|"; } } }
      chop($line);
      if ($line) {
        my ($nbrResLine, $refListResLine);
        ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
        if ($nbrResLine) {
          $lastExLine = $nbrLinesNotEmpty;
          $nbrExLines++;
          # Add line before ?
          if ($incContext and $$refExtractParams{linesBefore}) {
            push(@listResFile, "\n");
            push(@listResFile, @tmpLinesBefore);
            @tmpLinesBefore = (); # Empty array of lines before
          }
          # Add extracted line
          push(@listResFile, @{$refListResLine});
          $nbrResults += $nbrResLine;
          $endContextAfter = 0 if $incContext and $endContextAfter;
        # Keep line ?
        } else {
          # Context before
          if ($endContextAfter) {
            if ($incContext and $$refExtractParams{linesBefore}) {
              push(@listResFile, "\n");
              push(@tmpLinesBefore, $line);
              my $nbrItems = @tmpLinesBefore;
              # Array is full, remove first item
              shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
            }
          # Context after
          } else {
            # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
            if ($nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
              push(@listResFile, $line);
              # Last line to add
              if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                # Finish extraction
                if ($end) { last; }
                # Not finished, add a new line
                else { push(@listResFile, "\n"); }
              }
            } else { $endContextAfter = 1; }
          }
        }
        $nbrLinesNotEmpty++;
      }
      $nbrLines++;
      # If maximum of result has been reached
      if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
          $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
        # No line to add, no need to continue
        last if !$$refExtractParams{linesAfter};
        $end++;
      }
    }
  # Evtx
  } elsif ($fileFormat eq 'Evtx' and open(my $fh, $file)) {
    if (my $parser = Win32::EventLog->new($file)) {
      my $nbrRecs;
      my $base;
      my $x = 0;
      $parser->GetNumber($nbrRecs);
      $parser->GetOldest($base);
      while ($x < $nbrRecs) {
        my $hashRef;
        if ($parser->Read(EVENTLOG_FORWARDS_READ|EVENTLOG_SEEK_READ,$base+$x,$hashRef)) {
          Win32::EventLog::GetMessageText($hashRef);
          my $line = $hashRef->{Message};
          $line = $hashRef->{Strings} if !$line;
          if ($line) {
            my ($nbrResLine, $refListResLine);
            if (!$end) {
              ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex);
            }
            if ($nbrResLine) {
              $lastExLine = $nbrLinesNotEmpty;
              $nbrExLines++;
              # Add line before ?
              if ($incContext and $$refExtractParams{linesBefore}) {
                push(@listResFile, "\n");
                push(@listResFile, @tmpLinesBefore);
                @tmpLinesBefore = (); # Empty array of lines before
              }
              # Add extracted line
              push(@listResFile, @{$refListResLine});
              $nbrResults += $nbrResLine;
              $endContextAfter = 0 if $incContext and $endContextAfter;
            # Keep line ?
            } else {
              # Context before
              if ($endContextAfter) {
                if ($incContext and $$refExtractParams{linesBefore}) {
                  push(@listResFile, "\n");
                  push(@tmpLinesBefore, $line);
                  my $nbrItems = @tmpLinesBefore;
                  # Array is full, remove first item
                  shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
                }
              # Context after
              } else {
                # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
                if ($lastExLine != 0 and $nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
                  push(@listResFile, $line);
                  # Last line to add
                  if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                    # Finish extraction
                    if ($end) { last; }
                    # Not finished, add a new line
                    else { push(@listResFile, "\n"); }
                  }
                } else { $endContextAfter = 1; }
              }
            }
            $nbrLinesNotEmpty++;
          }
          $nbrLines++;
          # If maximum of result has been reached
          if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
              $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
            # No line to add, no need to continue
            last if !$$refExtractParams{linesAfter};
            $end++;
          }
        }
        $x++;
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);  
  
}  #--- End extractExprOptFileEvt

#------------------------------------------------------------------------------#
sub extractExprFileEvt
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $refExpressions, $AND, $lastExprIndex) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Evt
  if ($fileFormat eq 'Evt' and my $evt = Parse::EventLog->new($file)) {
    my %c = $evt->getAll();
    foreach my $a (keys %c) {
      my $line;
      $line  .= $c{$a}{EventID}                  . "\t";
      $line  .= localtime($c{$a}{TimeGenerated}) . "\t";
      $line  .= GetEventType($c{$a}{EventType})  . "\t";
      $line  .= $c{$a}{Source}                   . "\t";
      $line  .= $c{$a}{Computer}                 . "\t";
      my $str = $c{$a}{Strings};
      if ($str) { foreach my $s (@$str) { if ($s) { $s =~ s/[\t\r\n]/ /g; $line .= "$s|"; } } }
      chop($line);
      my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
      if ($nbrResLine) {
        $nbrResults += $nbrResLine;
        push(@listResFile, @{$refListResLine});
      }
      $nbrLines++;
    }
  # Evtx
  } elsif ($fileFormat eq 'Evtx' and open(my $fh, $file)) {
    if (my $parser = Win32::EventLog->new($file)) {
      my $nbrRecs;
      my $base;
      my $x = 0;
      $parser->GetNumber($nbrRecs);
      $parser->GetOldest($base);
      while ($x < $nbrRecs) {
        my $hashRef;
        if ($parser->Read(EVENTLOG_FORWARDS_READ|EVENTLOG_SEEK_READ,$base+$x,$hashRef)) {
          Win32::EventLog::GetMessageText($hashRef);
					my $line = $hashRef->{Message};
					$line = $hashRef->{Strings} if !$line;
					if ($line) {
            my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
            if ($nbrResLine) {
              $nbrResults += $nbrResLine;
              push(@listResFile, @{$refListResLine});
            }
            $nbrLines++;
          }
        }
        $x++;
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprFileEvt

#------------------------------------------------------------------------------#
sub extractExprAllFileEvt
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $refExpressions) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Evt
  if ($fileFormat eq 'Evt' and my $evt = Parse::EventLog->new($file)) {
    my %c = $evt->getAll();
    foreach my $a (keys %c) {
      my $line;
      $line  .= $c{$a}{EventID}                  . "\t";
      $line  .= localtime($c{$a}{TimeGenerated}) . "\t";
      $line  .= GetEventType($c{$a}{EventType})  . "\t";
      $line  .= $c{$a}{Source}                   . "\t";
      $line  .= $c{$a}{Computer}                 . "\t";
      my $str = $c{$a}{Strings};
      if ($str) { foreach my $s (@$str) { if ($s) { $s =~ s/[\t\r\n]/ /g; $line .= "$s|"; } } }
      chop($line);
      if ($line) {
        my ($nbrResLine, $refListResLine) = &extractExprStringAll($line, $refExpressions);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
      }
      $nbrLines++;
    }
  # Evtx
  } elsif ($fileFormat eq 'Evtx' and open(my $fh, $file)) {
    if (my $parser = Win32::EventLog->new($file)) {
      my $nbrRecs;
      my $base;
      my $x = 0;
      $parser->GetNumber($nbrRecs);
      $parser->GetOldest($base);
      while ($x < $nbrRecs) {
        my $hashRef;
        if ($parser->Read(EVENTLOG_FORWARDS_READ|EVENTLOG_SEEK_READ,$base+$x,$hashRef)) {
          Win32::EventLog::GetMessageText($hashRef);
					my $line = $hashRef->{Message};
					$line = $hashRef->{Strings} if !$line;
					if ($line) {
            my ($nbrResLine, $refListResLine) = &extractExprStringAll($line, $refExpressions);
            if ($nbrResLine) {
              $nbrResults += $nbrResLine;
              push(@listResFile, @{$refListResLine});
            }
          }
          $nbrLines++;
        }
        $x++;
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprAllFileEvt

#------------------------------------------------------------------------------#
sub extractExprByFilePdf
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions, $AND, $lastExprIndex, $refExprGroups) = @_;
  if (my $pdf = CAM::PDF->new($file)) {
    if (my $nbrPages = $pdf->numPages()) {
      if ($AND) {
        my $nbrGroups = scalar(@{$refExprGroups});
        for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
          my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
          my $found = 0;
          for (my $j = 1; $j <= $nbrPages; $j++) {
            if (my $text = $pdf->getPageText($j)) {
              my ($nbrResLine, $refListResLine) = &extractExprString($text, $$refExprGroups[$i], 0, $lastExprIndexInGroup);
              if ($nbrResLine) { # One expr of the group has been found, go to next group
                $found = 1;
                last;
              }
            }
          }
          return(0) if !$found; # No expr of the group has been found, we can stop here
        }
        return(1);
      } else { # No AND, if only one expression is found, no need to continue
        for (my $j = 1; $j <= $nbrPages; $j++) {
          if (my $text = $pdf->getPageText($j)) {
            my ($nbrResLine, $refListResLine) = &extractExprString($text, $refExpressions, $AND, $lastExprIndex);
            if ($nbrResLine) { return(1); }
          }
        }
      }
    }
  }
  return(0);
  
}  #--- End extractExprByFilePdf

#------------------------------------------------------------------------------#
sub extractExprOptFilePdf
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExtractParams, $AND, $lastExprIndex) = @_;
  my $incContext       = 1 if ($$refExtractParams{linesBefore} or $$refExtractParams{linesAfter});
  my $lastExLine       = 0; # Last line number where result has been found
  my $nbrExLines       = 0; # Nunmber of extracted lines
  my $end              = 0; # End of extraction, but context after may be added
  my $endContextAfter  = 1; # End of context after
  my $nbrLinesNotEmpty = 0;
  my $nbrLines         = 0;
  my $nbrResults       = 0;
  my @tmpLinesBefore;
  my @listResFile;
  if (my $pdf = CAM::PDF->new($file)) {
    if (my $nbrPages = $pdf->numPages()) {
      for (my $i = 1; $i <= $nbrPages; $i++) {
        if (my $text = $pdf->getPageText($i)) {
          my @lines = split(/\n/, $text);
          foreach my $line (@lines) {
            if ($line) {
              my ($nbrResLine, $refListResLine);
              if (!$end) { ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex); }
              if ($nbrResLine) {
                $lastExLine = $nbrLinesNotEmpty;
                $nbrExLines++;
                # Add line before ?
                if ($incContext and $$refExtractParams{linesBefore}) {
                  push(@listResFile, "\n");
                  push(@listResFile, @tmpLinesBefore);
                  @tmpLinesBefore = (); # Empty array of lines before
                }
                # Add extracted line
                push(@listResFile, @{$refListResLine});
                $nbrResults += $nbrResLine;
                $endContextAfter = 0 if $incContext and $endContextAfter;
              # Keep line ?
              } else {
                # Context before
                if ($endContextAfter) {
                  if ($incContext and $$refExtractParams{linesBefore}) {
                    push(@listResFile, "\n");
                    push(@tmpLinesBefore, $line);
                    my $nbrItems = @tmpLinesBefore;
                    # Array is full, remove first item
                    shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
                  }
                # Context after
                } else {
                  # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
                  if ($nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
                    push(@listResFile, $line);
                    # Last line to add
                    if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                      if ($end) { last; } 							 # Finish extraction
                      else { push(@listResFile, "\n"); } # Not finished, add a new line
                    }
                  } else { $endContextAfter = 1; }
                }
              }
              $nbrLinesNotEmpty++;
            }
            $nbrLines++;
            # If maximum of result has been reached
            if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
                $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
              # No line to add, no need to continue
              last if !$$refExtractParams{linesAfter};
              $end++;
            }
          }
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);  
  
}  #--- End extractExprOptFilePdf

#------------------------------------------------------------------------------#
sub extractExprFilePdf
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions, $AND, $lastExprIndex) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  if (my $pdf = CAM::PDF->new($file)) {
    if (my $nbrPages = $pdf->numPages()) {
      for (my $i = 1; $i <= $nbrPages; $i++) {
        if (my $text = $pdf->getPageText($i)) {
          my @lines = split(/\n/, $text);
          foreach my $line (@lines) {
            if ($line) {
              my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
              if ($nbrResLine) {
                $nbrResults += $nbrResLine;
                push(@listResFile, @{$refListResLine});
              }
            }
            $nbrLines++;
          }
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprFilePdf

#------------------------------------------------------------------------------#
sub extractExprAllFilePdf
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  if (my $pdf = CAM::PDF->new($file)) {
    if (my $nbrPages = $pdf->numPages()) {
      for (my $i = 1; $i <= $nbrPages; $i++) {
        if (my $text = $pdf->getPageText($i)) {
          my @lines = split(/\n/, $text);
          foreach my $line (@lines) {
            if ($line) {
              my ($nbrResLine, $refListResLine) = &extractExprStringAll($line, $refExpressions);
              if ($nbrResLine) {
                $nbrResults += $nbrResLine;
                push(@listResFile, @{$refListResLine});
              }
            }
            $nbrLines++;
          }
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprAllFilePdf

#------------------------------------------------------------------------------#
sub extractExprByFileMsg
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions, $AND, $lastExprIndex, $refExprGroups) = @_;
  my $msg;
  eval { $msg = new Email::Outlook::Message($file); };
  if ($msg and my $mime = $msg->to_email_mime) {
    my @tab = split(/\n/, $mime->as_string);
    if ($AND) {
      my $nbrGroups = scalar(@{$refExprGroups});
      for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
        my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
        my $found = 0;
        foreach my $line (@tab) {
          $line =~ s/[\n\r]//g;
          if ($line) {
            my ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExprGroups[$i], 0, $lastExprIndexInGroup);
            if ($nbrResLine) { # One expr of the group has been found, go to next group
              $found = 1;
              last;
            }
          }
        }
        # No expr of the group has been found, we can stop here
        if (!$found) { return(0); }
      }
      return(1);
    } else { # No AND, if only one expression is found, no need to continue
      foreach my $line (@tab) {
        $line =~ s/[\n\r]//g;
        if ($line) {
          my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
          return(1) if $nbrResLine;
        }
      }
    }
  }
  return(0);
  
}  #--- End extractExprByFileMsg

#------------------------------------------------------------------------------#
sub extractExprOptFileMsg
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExtractParams, $AND, $lastExprIndex) = @_;
  my $incContext       = 1 if ($$refExtractParams{linesBefore} or $$refExtractParams{linesAfter});
  my $lastExLine       = 0; # Last line number where result has been found
  my $nbrExLines       = 0; # Nunmber of extracted lines
  my $end              = 0; # End of extraction, but context after may be added
  my $endContextAfter  = 1; # End of context after
  my $nbrLinesNotEmpty = 0;
  my $nbrLines         = 0;
  my $nbrResults       = 0;
  my @tmpLinesBefore;
  my @listResFile;
  my $msg;
  eval { $msg = new Email::Outlook::Message($file); };
  if ($msg and my $mime = $msg->to_email_mime) {
    my @tab = split(/\n/, $mime->as_string);
    foreach my $line (@tab) {
      $line =~ s/[\n\r]//g;
      if ($line) {
        my ($nbrResLine, $refListResLine);
        ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
        if ($nbrResLine) {
          $lastExLine = $nbrLinesNotEmpty;
          $nbrExLines++;
          # Add line before ?
          if ($incContext and $$refExtractParams{linesBefore}) {
            push(@listResFile, "\n");
            push(@listResFile, @tmpLinesBefore);
            @tmpLinesBefore = (); # Empty array of lines before
          }
          # Add extracted line
          push(@listResFile, @{$refListResLine});
          $nbrResults += $nbrResLine;
          $endContextAfter = 0 if $incContext and $endContextAfter;
        # Keep line ?
        } else {
          # Context before
          if ($endContextAfter) {
            if ($incContext and $$refExtractParams{linesBefore}) {
              push(@listResFile, "\n");
              push(@tmpLinesBefore, $line);
              my $nbrItems = @tmpLinesBefore;
              # Array is full, remove first item
              shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
            }
          # Context after
          } else {
            # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
            if ($nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
              push(@listResFile, $line);
              # Last line to add
              if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                if ($end) { last; } 							 # Finish extraction
                else { push(@listResFile, "\n"); } # Not finished, add a new line
              }
            } else { $endContextAfter = 1; }
          }
        }
        $nbrLinesNotEmpty++;
      }
      $nbrLines++;
      # If maximum of result has been reached
      if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
          $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
        # No line to add, no need to continue
        last if !$$refExtractParams{linesAfter};
        $end++;
      }
    }
  }
  
  return($nbrLines, $nbrResults, \@listResFile);  
  
}  #--- End extractExprOptFileMsg

#------------------------------------------------------------------------------#
sub extractExprFileMsg
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions, $AND, $lastExprIndex) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  my $msg;
  eval { $msg = new Email::Outlook::Message($file); };
  if ($msg and my $mime = $msg->to_email_mime) {
    my @tab = split(/\n/, $mime->as_string);
    foreach my $line (@tab) {
      $line =~ s/[\n\r]//g;
      if ($line) {
        my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
      }
      $nbrLines++;
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprFileMsg

#------------------------------------------------------------------------------#
sub extractExprAllFileMsg
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  my $msg;
  eval { $msg = new Email::Outlook::Message($file); };
  if ($msg and my $mime = $msg->to_email_mime) {
    my @tab = split(/\n/, $mime->as_string);
    foreach my $line (@tab) {
      $line =~ s/[\n\r]//g;
      if ($line) {
        my ($nbrResLine, $refListResLine) = &extractExprStringAll($line, $refExpressions);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
      }
      $nbrLines++;
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprAllFileMsg

#------------------------------------------------------------------------------#
sub extractExprByFileZip
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions, $AND, $lastExprIndex, $refExprGroups) = @_;
  if (my $zip = Archive::Zip->new($file)) {
    my @members = $zip->members();
    if ($AND) {
      my $nbrGroups = scalar(@{$refExprGroups});
      for (my $i = 0; $i < $nbrGroups; $i++) { # For each group
        my $lastExprIndexInGroup = (keys $$refExprGroups[$i]);
        my $found = 0;
        foreach (@members) {
          my $filename = $_->fileName();
          #my $zipPath  = "$file\@$filename";
          #print "$zipPath\n";
          if (! $_->isEncrypted()) {
            if (my $str = $_->contents()) {
              my @tab = split(/[\r\n]/, $str);
              foreach my $line (@tab) {
                if ($line) {
                  my ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExprGroups[$i], 0, $lastExprIndexInGroup);
                  if ($nbrResLine) { # One expr of the group has been found, go to next group
                    $found = 1;
                    last;
                  }
                }
              }
            }
          }
        }
        # No expr of the group has been found, we can stop here
        return(0) if !$found;
      }
      return(1);
    } else { # No AND, if only one expression is found, no need to continue
      foreach (@members) {
        my $filename = $_->fileName();
        #my $zipPath  = "$file\@$filename";
        #print "$zipPath\n";
        if (! $_->isEncrypted()) {
          if (my $str = $_->contents()) {
            my @tab = split(/[\r\n]/, $str);
            foreach my $line (@tab) {
              if ($line) {
                my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
                return(1) if $nbrResLine;
              }
            }
          }
        }
      }
    }
  }
  
  return(0);
  
}  #--- End extractExprByFileZip

#------------------------------------------------------------------------------#
sub extractExprOptFileZip
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExtractParams, $AND, $lastExprIndex) = @_;
  my $incContext       = 1 if ($$refExtractParams{linesBefore} or $$refExtractParams{linesAfter});
  my $lastExLine       = 0; # Last line number where result has been found
  my $nbrExLines       = 0; # Nunmber of extracted lines
  my $end              = 0; # End of extraction, but context after may be added
  my $endContextAfter  = 1; # End of context after
  my $nbrLinesNotEmpty = 0;
  my $nbrLines         = 0;
  my $nbrResults       = 0;
  my @tmpLinesBefore;
  my @listResFile;
  if (my $zip = Archive::Zip->new($file)) {
    my @members = $zip->members();
    foreach (@members) {
      my $filename = $_->fileName();
      #my $zipPath  = "$file\@$filename";
      #print "$zipPath\n";
      if (! $_->isEncrypted()) {
        if (my $str = $_->contents()) {
          my @tab = split(/[\r\n]/, $str);
          foreach my $line (@tab) {
            if ($line) {
              my ($nbrResLine, $refListResLine);
              ($nbrResLine, $refListResLine) = &extractExprString($line, $$refExtractParams{expressions}, $AND, $lastExprIndex) if !$end;
              if ($nbrResLine) {
                $lastExLine = $nbrLinesNotEmpty;
                $nbrExLines++;
                # Add line before ?
                if ($incContext and $$refExtractParams{linesBefore}) {
                  push(@listResFile, "\n");
                  push(@listResFile, @tmpLinesBefore);
                  @tmpLinesBefore = (); # Empty array of lines before
                }
                # Add extracted line
                push(@listResFile, @{$refListResLine});
                $nbrResults += $nbrResLine;
                $endContextAfter = 0 if $incContext and $endContextAfter;
              # Keep line ?
              } else {
                # Context before
                if ($endContextAfter) {
                  if ($incContext and $$refExtractParams{linesBefore}) {
                    push(@listResFile, "\n");
                    push(@tmpLinesBefore, $line);
                    my $nbrItems = @tmpLinesBefore;
                    # Array is full, remove first item
                    shift(@tmpLinesBefore) if $nbrItems > $$refExtractParams{linesBefore};
                  }
                # Context after
                } else {
                  # There is an extracted line and the line number is lower or egal to $lastExLine + $$refExtractParams{linesAfter}
                  if ($nbrLinesNotEmpty <= ($lastExLine + $$refExtractParams{linesAfter})) {
                    push(@listResFile, $line);
                    # Last line to add
                    if ($nbrLinesNotEmpty == ($lastExLine + $$refExtractParams{linesAfter}) and !$$refExtractParams{linesBefore}) {
                      if ($end) { last; } 							 # Finish extraction
                      else { push(@listResFile, "\n"); } # Not finished, add a new line
                    }
                  } else { $endContextAfter = 1; }
                }
              }
              $nbrLinesNotEmpty++;
            }
            $nbrLines++;
            # If maximum of result has been reached
            if (($$refExtractParams{maxResByFile} and $nbrExLines == $$refExtractParams{maxResByFile}) or
                $$refExtractParams{maxResTot} and $nbrExLines == $$refExtractParams{maxResTot}) {
              # No line to add, no need to continue
              last if !$$refExtractParams{linesAfter};
              $end++;
            }
          }
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);  
  
}  #--- End extractExprOptFileZip

#------------------------------------------------------------------------------#
sub extractExprFileZip
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions, $AND, $lastExprIndex) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  if (my $zip = Archive::Zip->new($file)) {
    my @members = $zip->members();
    foreach (@members) {
      my $filename = $_->fileName();
      #my $zipPath  = "$file\@$filename";
      #print "$zipPath\n";
      if (! $_->isEncrypted()) {
        if (my $str = $_->contents()) {
          my @tab = split(/[\r\n]/, $str);
          foreach my $line (@tab) {
            if ($line) {
              my ($nbrResLine, $refListResLine) = &extractExprString($line, $refExpressions, $AND, $lastExprIndex);
              if ($nbrResLine) {
                $nbrResults += $nbrResLine;
                push(@listResFile, @{$refListResLine});
              }
              $nbrLines++;
            }
          }
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprFileZip

#------------------------------------------------------------------------------#
sub extractExprAllFileZip
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refExpressions) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  if (my $zip = Archive::Zip->new($file)) {
    my @members = $zip->members();
    foreach (@members) {
      my $filename = $_->fileName();
      #my $zipPath  = "$file\@$filename";
      #print "$zipPath\n";
      if (! $_->isEncrypted()) {
        if (my $str = $_->contents()) {
          my @tab = split(/[\r\n]/, $str);
          foreach my $line (@tab) {
            if ($line) {
              my ($nbrResLine, $refListResLine) = &extractExprStringAll($line, $refExpressions);
              if ($nbrResLine) {
                $nbrResults += $nbrResLine;
                push(@listResFile, @{$refListResLine});
              }
            }
            $nbrLines++;
          }
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractExprAllFileZip

#------------------------------------------------------------------------------#
sub extractExprString
#------------------------------------------------------------------------------#
{
  # There is at least one AND in list or No duplicate is selected
  # $AND = the number of AND
  my ($line, $refExpressions, $AND, $lastExprIndex) = @_;
  my $nbrResLine = 0;
  my $status     = 0; # Status of last test
  my @resLine;
  my $last = $lastExprIndex - 1; # Index of the last expression in list
  # Test expressions while it matches
  for (my $index = 1; $index <= $last; $index++) {
    my ($result, $nbrRes, $refListRes);
    # $index is the position of the expression in the list
    # Struct:
    #   $expressions{$index}{operator} : -, OR, AND
    #   $expressions{$index}{case}     : 0 or 1
    #   $expressions{$index}{regex}    : 0 or 1
    #   $expressions{$index}{invert}   : 0 or 1
    #   $expressions{$index}{expr}     : Expression
    
    # If it's the first expression to test, or if the last expression had no result and operator is OR
    if (($$refExpressions{$index}{operator} eq $STR{'OR'} and !$status) or $$refExpressions{$index}{operator} eq '-') {
      ($result, $nbrRes, $refListRes) = &textExpr($line, $$refExpressions{$index}, $$refExpressions{$lastExprIndex}{expr});
    # If last expression had result and operator is OR
    } elsif ($$refExpressions{$index}{operator} eq $STR{'OR'} and $status) {
      if ($AND) { next; } # There are AND left, we continue
      else      { last; } # No more AND, no need to continue
    # If operator is AND
    } elsif ($$refExpressions{$index}{operator} eq $STR{'AND'}) {
      $AND--;
      # Last expression had result, we continue
      if ($status) {
        $result = 0; $nbrRes = 0; @{$refListRes} = (); # Reset all
        ($result, $nbrRes, $refListRes) = &textExpr($line, $$refExpressions{$index}, $$refExpressions{$lastExprIndex}{expr});
      # Last expression had no result, no need to continue
      } else { return(0, undef); }
    }
    # If Expr has results and it's the last expression
    if ($result) {
			$status = 1;
			if ($index == $last or !$AND) {
        $nbrResLine += $nbrRes;
        push(@resLine, @{$refListRes});
        $$refExpressions{$lastExprIndex}{nbrRes} += $nbrRes;
      }
    }
    # No result, operator is AND and it's the last expression, no need to continue
    elsif ($$refExpressions{$index}{operator} eq $STR{'AND'} and $index == $last) { return(0, undef); }
    # No result, but there is another expr
    elsif (!$result and $index != $last) { $status = 0; }
  }
  # Return results
  if ($status) {
    if ($nbrResLine) { return($nbrResLine, \@resLine); } # If extracted, return the list
    else { # Else, return the line
      $nbrResLine = 1;
      return($nbrResLine, \@resLine);
    }
  } else { return(0, undef); }
  
}  #--- End extractExprString

#------------------------------------------------------------------------------#
sub extractExprStringAll
#------------------------------------------------------------------------------#
{
  # There is only one expr, or only OR in list and duplicate allowed
  my ($line, $refExpressions) = @_;
  my $nbrResLine = 0;
  my $status     = 0; # Status of last test
  my @resLine;
  # Test each expressions
  foreach my $index (keys %{$refExpressions}) {
    my ($result, $nbrRes, $refListRes) = &textExprAll($line, $$refExpressions{$index});
    # If Expr has results
    if ($result) {
      $nbrResLine += $nbrRes;
      push(@resLine, @{$refListRes});
      $$refExpressions{$index}{nbrRes} += $nbrRes;
      $status = 1;
    }
  }
  # Return results
  if ($status) {
    if ($nbrResLine) { return($nbrResLine, \@resLine); } # If extracted, return the list
    else { # Else, return the line
      $nbrResLine = 1;
      return($nbrResLine, \@resLine);
    }
  } else { return(0, undef); }
  
}  #--- End extractExprStringAll

#------------------------------------------------------------------------------#
sub textExpr
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($line, $refExpr, $globalExpr) = @_;
  my $expr   = $$refExpr{expr};
  my $nbrRes = 0;
  my @listRes;
  $expr = quotemeta($expr) if !$$refExpr{regex};
  # Output :
  #   If result == 1 and $nbrRes == 0, means no capture, but expression matches
  #   If result == 1 and $nbrRes > 1, $nbrRes is the number of extracted data and $refListRes is the list of the data
  # Line match
  if (($$refExpr{case} and ($line =~ /$expr/ )) or (!$$refExpr{case} and ($line =~ /$expr/i))) {
    # Invert but match, no need to continue
    return(0, 0, undef) if $$refExpr{invert};
    # If there is at least one capture group, we must extract data
    my $r = Extract::Regex->new($expr, 1);
    if ($r->nbrCaptureGroups()) {
      while (($$refExpr{case} and ($line =~ /$expr/ )) or (!$$refExpr{case} and ($line =~ /$expr/i))) {
        my ($partRes, $pos, $width) = &extractExpr($line, $expr, $$refExpr{case});
        if ($partRes) {
          $nbrRes++;
          push(@listRes, "$globalExpr\t$partRes");
          # Remove processed part of the line
          chomp($partRes);
          my $lineWidth = length($line);
          my $offset    = $pos+$width;
          $line         = substr($line,$offset,$lineWidth-$offset);
        } else {
          if ($$refExpr{case}) { $line =~ s/$expr//i; }
          else                 { $line =~ s/$expr//;  }
        }
      }
      return(1, $nbrRes, \@listRes);
    # No capture group, test if expr match line only
    } else {
      push(@listRes, "$globalExpr\t$line");
      return(1, 1, \@listRes);
    }
  }
  # Line doesn't match, but invert option is selected
  elsif ($$refExpr{invert}) {
    push(@listRes, "$globalExpr\t$line");
    return(1, 1, \@listRes);
  }
  # Line doesn't match
  else { return(0, 0, undef); }
  
}  #--- End textExpr

#------------------------------------------------------------------------------#
sub textExprAll
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($line, $refExpr) = @_;
  my $expr   = $$refExpr{expr};
  my $nbrRes = 0;
  my @listRes;
  $expr = quotemeta($expr) if !$$refExpr{regex};
  # Output :
  #   If result == 1 and $nbrRes == 0, means no capture, but expression matches
  #   If result == 1 and $nbrRes > 1, $nbrRes is the number of extracted data and $refListRes is the list of the data
  # Line match
  if (($$refExpr{case} and ($line =~ /$expr/ )) or (!$$refExpr{case} and ($line =~ /$expr/i))) {
    # Invert but match, no need to continue
    return(0, 0, undef) if $$refExpr{invert};
    # If there is at least one capture group, we must extract data
    my $r = Extract::Regex->new($expr, 1);
    if ($r->nbrCaptureGroups()) {
      while (($$refExpr{case} and ($line =~ /$expr/ )) or (!$$refExpr{case} and ($line =~ /$expr/i))) {
        my ($partRes, $pos, $width) = &extractExpr($line, $expr, $$refExpr{case});
        if ($partRes) {
          $nbrRes++;
          push(@listRes, "$expr\t$partRes");
          # Remove processed part of the line
          chomp($partRes);
          my $lineWidth = length($line);
          my $offset    = $pos+$width;
          $line         = substr($line,$offset,$lineWidth-$offset);
        } else {
          if ($$refExpr{case}) { $line =~ s/$expr//i; }
          else                 { $line =~ s/$expr//;  }
        }
      }
      return(1, $nbrRes, \@listRes);
    # No capture group, test if expr match line only
    } else {
      push(@listRes, "$$refExpr{expr}\t$line");
      return(1, 1, \@listRes);
    }
  }
  # Line doesn't match, but invert option is selected
  elsif ($$refExpr{invert}) {
    push(@listRes, "[$STR{'Invert'}] $$refExpr{expr}\t$line");
    return(1, 1, \@listRes);
  }
  # Line doesn't match
  else { return(0, 0, undef); }
  
}  #--- End textExprAll

#------------------------------------------------------------------------------#
sub extractExpr
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($line, $expr, $case) = @_;
  my $res   = '';
  my $width = 0;
  my $pos   = 0;
  my @listRes;
  # Test expr again
  if ($case)  { @listRes = ($line =~ /$expr/);  }
  else        { @listRes = ($line =~ /$expr/i); }
  foreach (@listRes) {
    if (defined $_) {
      $res  .= "$_\t";
      $pos   = index($line,$_,$pos);
      $width = length($_);
    }
  }
  chop($res);
  return($res, $pos, $width);

}  #--- End extractExpr

#------------------------------------------------------------------------------#
sub extractSOFiles
#------------------------------------------------------------------------------#
{
  # Local variables
  my %extractParams;
  my $refExtractParams = \%extractParams;
  if (open(my $json, '<', "$REPORTDIR\\ExtractSOParams-" . $PROCESSID .'.json')) {
    $THR = threads->create(sub {
      # Thread 'cancellation' signal handler
      $SIG{'KILL'} = sub {
        $winResults->ChangeCursor($ARROW);
        threads->exit();
      };
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        #return if $_[0] =~ /Invalid version format/;  # Worked for XL-Tools, to test, prevent crash from Parse::HTTP::UserAgent, ex.: Java/1.7.0_09-icedtea
        die if $_[0] =~ /Negative length/ and $_[0] =~ /IO\/Handle.pm/;
        print $_[0] . "\n";
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        $winResults->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winResults, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      $winResults->ChangeCursor($HOURGLASS);
      # Get params from JSON
      my $jsonText = <$json>;
      close($json);
      my $jsonObj = JSON->new;
      $refExtractParams = $jsonObj->decode($jsonText);
      # List files
      my %listFiles;
      my $refListFiles = \%listFiles;
      if ($$refExtractParams{inputType} eq 'Dir' or $$refExtractParams{inputType} eq 'Files') {
        if (-f "$REPORTDIR\\CurrentListFiles.json" and open(my $json, "$REPORTDIR\\CurrentListFiles.json")) {
          $jsonText = <$json>;
          close($json);
          my $jsonObj = JSON->new;
          $refListFiles = $jsonObj->decode($jsonText);
        } else {        
          &getListFiles($refListFiles, $refExtractParams);
          # Store results in a JSON file
          if (open(my $json, '>:encoding(cp1252)', "$REPORTDIR\\CurrentListFiles.json")) {
            my $jsonObj = JSON->new;
            my $jsonText = $jsonObj->encode($refListFiles);
            print $json $jsonText;
            close($json);
          }
        }
      } elsif ($$refExtractParams{inputType} eq 'Clipboard') { $$refListFiles{'Clipboard'} = 1; }
      my $nbrFiles = scalar(keys %{$refListFiles});
      if ($nbrFiles) {
        # Set options
        my $tmpReport1 = "$REPORTDIR\\.XL-Parser_tmp-"  . $PROCESSID .'.txt';
        my $tmpReport2 = "$REPORTDIR\\.XL-Parser_tmp2-" . $PROCESSID .'.txt';
        my %results;
        # Load TLD Database and set valid Email option (this option has to be used while extracting)
        my $validEmail;
        my $TLDDB;
        if (($$refExtractParams{SO}{$STR{SO_Emails}} and $$refExtractParams{SO}{$STR{SO_Emails}}{'options'}{$STR{SO_Emails_Valid}}) or
            ($$refExtractParams{SO}{$STR{SO_Hostnames}} or $$refExtractParams{SO}{$STR{SO_DomainNames}})) {
          $validEmail = 1;
          # Load TLD Database
          $TLDDB = Domain::PublicSuffix->new({ 'data_file' => $$refExtractParams{TLD_DB_FILE} }) or
          Win32::GUI::MessageBox($winResults, $STR{'errLoadingDB'}, $STR{'error'}, 0x40010);
        } else { $validEmail = 0; }
        # Set remove Param option (for URLs), this option has to be used while extracting
        my $remParam;
        if ($$refExtractParams{SO}{$STR{SO_URLs}} and $$refExtractParams{SO}{$STR{SO_URLs}}{options}{$STR{'SO_URL_RemParam'}}) {
          $remParam = 1;
        } else { $remParam = 0; }
        # Set other options
        my $NSLookup         = 0;
        my $ResolveTLD       = 0;
        my $IPAddr_XLWhoisDB = 0;
        my $ResolveGeoIP     = 0;
        my $MACAddr_ResOUI   = 0;
        my $CC_ResIC         = 0;
        foreach my $object (keys %{$$refExtractParams{SO}}) {
          if (exists($$refExtractParams{SO}{$object}{options})) {
            $NSLookup         = 1 if exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_NSLookup'}})         and !$NSLookup;
            $ResolveTLD       = 1 if exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_ResolveTLD'}})       and !$ResolveTLD;
            $IPAddr_XLWhoisDB = 1 if exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_IPAddr_XLWhoisDB'}}) and !$IPAddr_XLWhoisDB;
            $ResolveGeoIP     = 1 if exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_GeoIP'}})            and !$ResolveGeoIP;
            $MACAddr_ResOUI   = 1 if exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_MACAddr_ResOUI'}})   and !$MACAddr_ResOUI;
            $CC_ResIC         = 1 if exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_CC_ResIC'}})         and !$CC_ResIC;
          }
        }
        # Load required databases
        my $dbhTLD       = &loadTLDDB($$refExtractParams{RES_TLD_DB_FILE})     if $ResolveTLD;
        my $dbhXLWhoisDB = &loadXLWhoisDB($$refExtractParams{XLWHOIS_DB_FILE}) if $IPAddr_XLWhoisDB;
        my $dbhGeoIP     = &loadGeoIP($$refExtractParams{GEOIP_DB_FILE})       if $ResolveGeoIP;
        my $dbhMACAddr   = &loadMACAddrDB($$refExtractParams{MACOUI_DB_FILE})  if $MACAddr_ResOUI;
        my $refListIIN   = &loadListIIN($$refExtractParams{IIN_DB_FILE})       if $CC_ResIC;
        # If tmp reports already exist, delete
        unlink($tmpReport1) if -e $tmpReport1;
        unlink($tmpReport2) if -e $tmpReport2;
        # Set Stats
        $results{totResFiles}   = 0;
        $results{totResLines}   = 0;
        $results{totResSize}    = 0;
        $results{totResResults} = 0;
        my $startTime           = time;
        # Set Result Files grid header
        $winResults->gridResFiles->SetCellText(0, 0, $STR{'ResStatsFiles'} );
        $winResults->gridResFiles->SetCellText(0, 1, $STR{'Size'}          );
        $winResults->gridResFiles->SetCellText(0, 2, $STR{'ResStatsLines'} );
        $winResults->gridResFiles->SetCellText(0, 3, $STR{'Results'});
        $winResults->gridResFiles->SetCellFormat(0, 0, 1); # Center column headers
        $winResults->gridResFiles->SetCellFormat(0, 1, 1);
        $winResults->gridResFiles->SetCellFormat(0, 2, 1);
        $winResults->gridResFiles->SetCellFormat(0, 3, 1);
        $winResults->gridResFiles->AutoSize();
        $winResults->gridResFiles->ExpandColumnsToFit() if $winResults->gridResFiles->GetVirtualWidth() < $winResults->gridResFiles->Width();
        $winResults->gridResFiles->Refresh();
        # Set Result Objects grid header
        $winResults->gridResExpr->SetColumns(3);
        $winResults->rbResByExpr->Text($STR{'rbResByObject'});
        $winResults->gridResExpr->SetCellText(0, 0, $STR{'Object'});
        $winResults->gridResExpr->SetCellText(0, 1, $STR{'Results'});
        $winResults->gridResExpr->SetCellText(0, 2, $STR{'Options'});
        $winResults->gridResExpr->SetCellFormat(0, 0, 1); # Center column headers
        $winResults->gridResExpr->SetCellFormat(0, 1, 1);
        $winResults->gridResExpr->SetCellFormat(0, 2, 1);
        $winResults->gridResExpr->AutoSize();
        $winResults->gridResExpr->ExpandColumnsToFit() if $winResults->gridResExpr->GetVirtualWidth() < $winResults->gridResExpr->Width();
        $winResults->gridResExpr->Refresh();
        # Set progress
        my $nbrFiles = scalar(keys %{$refListFiles});
        $winResults->pb->SetRange(0, $nbrFiles);
        $winResults->pb->SetPos(0);
        $winResults->pb->SetStep(1);
        $winResults->lblCount->Text("0 / $nbrFiles");
        $winResults->lblCurr->Text("$STR{'Searching'} $STR{'Started'}");
        my $count = 0;
        # Get File format list
        my $nbrFileFormats = scalar(keys %{$$refExtractParams{fileFormats}});
        # Foreach file, call the right parser
        foreach my $file (sort { $a cmp $b } keys %{$refListFiles}) {
          $file = encode('cp1252', $file);
          $winResults->lblCurr->Text("$STR{'Searching'} $file".'...');
          # Local variables
          my $fileLines   = 0;
          my $fileResults = 0;
          my $refResByFile;
          foreach my $fileFormat (keys %{$$refExtractParams{fileFormats}}) {
            my $formatFound = 0;
            foreach my $ext (@{$$refExtractParams{fileFormats}{$fileFormat}{extList}}) {
              if ($file =~ /$ext$/i or $file eq 'Clipboard') {
                # Plain text and Clipboard
                if ($fileFormat eq $STR{'PlainText'} and ((-T $file and $file !~ /\.pdf$/i) or $file eq 'Clipboard')) {
                  ($fileLines, $fileResults, $refResByFile) = &extractSOFileTxt($file, $$refExtractParams{SO}, $validEmail, $remParam,
                                                                                \%results, \$TLDDB, $$refExtractParams{inputType});
                # Unicode
                } elsif (!$fileResults and $fileFormat eq $STR{'Unicode'}) {
                  ($fileLines, $fileResults, $refResByFile) =
                  &extractSOFileUnicode($file, $$refExtractParams{fileFormats}{$fileFormat}{options}, $$refExtractParams{SO}, $validEmail,
                                        $remParam, \%results, \$TLDDB);
                # Any ASCII
                } elsif (!$fileResults and $fileFormat eq $STR{'AnyASCII'}) {
                  ($fileLines, $fileResults, $refResByFile) = &extractSOFileTxt($file, $$refExtractParams{SO}, $validEmail, $remParam,
                                                                                \%results, \$TLDDB, $$refExtractParams{inputType});
                # Doc and Docx
                } elsif ($fileFormat eq 'Doc' or $fileFormat eq 'Docx') {
                  ($fileLines, $fileResults, $refResByFile) =
                  &extractSOFileDoc($file, $fileFormat, $$refExtractParams{fileFormats}{$fileFormat}{options}, $$refExtractParams{SO},
                                    $validEmail, $remParam, \%results, \$TLDDB);
                  $formatFound = 1 if $fileResults;
                # Xls and Xlsx
                } elsif ($fileFormat eq 'Xls' or $fileFormat eq 'Xlsx') {
                  ($fileLines, $fileResults, $refResByFile) = &extractSOFileXls($file, $fileFormat, $$refExtractParams{SO}, $validEmail,
                                                                                $remParam, \%results, \$TLDDB);
                  $formatFound = 1 if $fileResults;
                # Evt and Evtx
                } elsif ($fileFormat eq 'Evt' or $fileFormat eq 'Evtx') {
                  ($fileLines, $fileResults, $refResByFile) = &extractSOFileEvt($file, $fileFormat, $$refExtractParams{SO}, $validEmail,
                                                                                $remParam, \%results, \$TLDDB);
                  $formatFound = 1 if $fileResults;
                # Pdf
                } elsif ($fileFormat eq 'Pdf') {
                  ($fileLines, $fileResults, $refResByFile) = &extractSOFilePdf($file, $$refExtractParams{SO}, $validEmail, $remParam,
                                                                                \%results, \$TLDDB);
                  $formatFound = 1 if $fileResults;
                # Msg
                } elsif ($fileFormat eq 'Msg') {
                  ($fileLines, $fileResults, $refResByFile) = &extractSOFileMsg($file, $$refExtractParams{SO}, $validEmail, $remParam,
                                                                                \%results, \$TLDDB);
                  $formatFound = 1 if $fileResults;
                # Zip
                } elsif ($fileFormat eq 'Zip') {
                  ($fileLines, $fileResults, $refResByFile) = &extractSOFileZip($file, $$refExtractParams{SO}, $validEmail, $remParam,
                                                                                \%results, \$TLDDB);
                  $formatFound = 1 if $fileResults;
                }
              }
              last if $formatFound;
            }
            last if $formatFound;
          }
          # Update stats
          $results{totResFiles}++;
          $results{totResLines}   += $fileLines;
          my $fileSize    = (stat($file))[7];
          $results{totResSize}    += $fileSize if $fileSize;
          my $sizeStr     = &formatFileSize($results{totResSize});
          my $currTime    = time;
          my $diffTime    = $currTime - $startTime;
          my ($diffD, $diffH, $diffM, $diffS) = (gmtime $diffTime)[7,2,1,0];
          my $duration;
          $duration .= "$diffD days, " if $diffD;
          $duration .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
          $results{totResResults} += $fileResults;
          $winResults->lblResStatsFilesVal->Text($results{totResFiles});
          $winResults->lblResStatsLinesVal->Text($results{totResLines});
          $winResults->lblResStatsSizeVal->Text($sizeStr);
          $winResults->lblResStatsDurationVal->Text($duration);
          $winResults->lblResStatsResultsVal->Text($results{totResResults});
          # Update results in files
          if ($fileResults) {
            # Add results to temp report 1 (By File)
            if (open(my $tmpFH, '>>', $tmpReport1)) {
              foreach (@{$refResByFile}) { print $tmpFH "$file\t$_\n"; }
              close($tmpFH);
            }
            # Add results to temp report 2 (By Object)
            if (open(my $tmpFH, '>', $tmpReport2)) {
              foreach my $object (keys %{$results{bySO}}) {
                foreach my $res (keys %{$results{bySO}{$object}}) {
                  if ($res ne 'nbrRes') {
                    my $newLine = "$object\t$res\t$results{bySO}{$object}{$res}{nbr}\t";
                    # Additional columns (based on options)
                    # Nslookup
                    if ($NSLookup) {
                      if (exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_NSLookup'}})) {
                        if ($results{bySO}{$object}{$res}{$STR{'SO_NSLookup'}}) { # Already resolved
                          $newLine .= "$results{bySO}{$object}{$res}{$STR{'SO_NSLookup'}}\t";
                        } elsif (my $lookup = &nsLookup($res, $$refExtractParams{NSLOOKUP_TIMEOUT})) {
                          $newLine .= "$lookup\t";
                          $results{bySO}{$object}{$res}{$STR{'SO_NSLookup'}} = $lookup;
                        } else {
                          $newLine .= "-\t";
                          $results{bySO}{$object}{$res}{$STR{'SO_NSLookup'}} = '-';
                        }
                      } else { $newLine .= "-\t"; }
                    }
                    # Resolve TLD
                    if ($ResolveTLD) {
                      if (exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_ResolveTLD'}})) {
                        if ($results{bySO}{$object}{$res}{$STR{'SO_ResolveTLD'}}) { # Already resolved
                          $newLine .= "$results{bySO}{$object}{$res}{$STR{'SO_ResolveTLD'}}\t";
                        } else {
                          my $hostname;
                          if ($object eq $STR{'SO_URLs'} and $res =~ /((?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.){2,}[a-zA-Z]{2,})(?:[^a-zA-Z]|$)/i) {
                            $hostname = $1;
                          } elsif ($object eq $STR{'SO_IPv4Addr'} or $object eq $STR{'SO_IPv6Addr'} and $results{bySO}{$object}{$res}{$STR{'SO_NSLookup'}}) {
                            $hostname = $results{bySO}{$object}{$res}{$STR{'SO_NSLookup'}};
                          } else { $hostname = $res; }
                          if (my $resTLD = &resolveTLD($hostname, \$dbhTLD)) {
                            $newLine .= "$resTLD\t";
                            $results{bySO}{$object}{$res}{$STR{'SO_ResolveTLD'}} = $resTLD;
                          } else {
                            $newLine .= "-\t";
                            $results{bySO}{$object}{$res}{$STR{'SO_ResolveTLD'}} = '-';
                          }
                        }
                      } else { $newLine .= "-\t"; }
                    }
                    # Resolve ISP (XL-Whois DB)
                    if ($IPAddr_XLWhoisDB) {
                      my $ip;
                      if ($res =~ /(?:[^0-9]|^)((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))(?:[^0-9\.]|$)/ or
                          $res =~ /($IPv6_re)/) {
                        $ip = $1;
                      } elsif ($results{bySO}{$object}{$res}{$STR{'SO_NSLookup'}}) {
                        $ip = $results{bySO}{$object}{$res}{$STR{'SO_NSLookup'}};
                        $ip = (split(/,/,$ip))[0];
                      }
                      if (exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_IPAddr_XLWhoisDB'}})) {
                        if ($results{bySO}{$object}{$res}{$STR{'SO_IPAddr_XLWhoisDB'}}) { # Already resolved
                          $newLine .= "$results{bySO}{$object}{$res}{$STR{'SO_IPAddr_XLWhoisDB'}}\t";
                        } elsif (my $resISP = &resolveISP($ip, \$dbhXLWhoisDB)) {
                          $newLine .= "$resISP\t";
                          $results{bySO}{$object}{$res}{$STR{'SO_IPAddr_XLWhoisDB'}} = $resISP;
                        } else {
                          $newLine .= "-\t";
                          $results{bySO}{$object}{$res}{$STR{'SO_IPAddr_XLWhoisDB'}} = '-';
                        }
                      } else { $newLine .= "-\t"; }
                    }
                    # Resolve GeoIP
                    if ($ResolveGeoIP) {
                      if (exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_GeoIP'}})) {
                        if ($results{bySO}{$object}{$res}{$STR{'SO_GeoIP'}}) { # Already resolved
                          $newLine .= "$results{bySO}{$object}{$res}{$STR{'SO_GeoIP'}}\t";
                        } elsif (my $resGeoIP = &resolveGeoIP($res, \$dbhGeoIP)) {
                          $newLine .= "$resGeoIP\t";
                          $results{bySO}{$object}{$res}{$STR{'SO_GeoIP'}} = $resGeoIP;
                        } else {
                          $newLine .= "-\t";
                          $results{bySO}{$object}{$res}{$STR{'SO_GeoIP'}} = '-';
                        }
                      } else { $newLine .= "-\t"; }
                    }
                    # Resolve MAC address OUI
                    if ($MACAddr_ResOUI) {
                      if (exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_MACAddr_ResOUI'}})) {
                        if ($results{bySO}{$object}{$res}{$STR{'SO_MACAddr_ResOUI'}}) { # Already resolved
                          $newLine .= "$results{bySO}{$object}{$res}{$STR{'SO_MACAddr_ResOUI'}}\t";
                        } elsif (my $resOUI = &resolveOUI($res, \$dbhMACAddr)) {
                          $newLine .= "$resOUI\t";
                          $results{bySO}{$object}{$res}{$STR{'SO_MACAddr_ResOUI'}} = $resOUI;
                        } else {
                          $newLine .= "-\t";
                          $results{bySO}{$object}{$res}{$STR{'SO_MACAddr_ResOUI'}} = '-';
                        }
                      } else { $newLine .= "-\t"; }
                    }
                    # Resolve Credit Card IIN
                    if ($CC_ResIC) {
                      if (exists($$refExtractParams{SO}{$object}{options}{$STR{'SO_CC_ResIC'}})) {
                        if ($results{bySO}{$object}{$res}{$STR{'SO_CC_ResIC'}}) { # Already resolved
                          $newLine .= "$results{bySO}{$object}{$res}{$STR{'SO_CC_ResIC'}}\t";
                        } elsif (my $resCC = &resolveCreditCard($res, $refListIIN)) {
                          $newLine .= "$resCC\t";
                          $results{bySO}{$object}{$res}{$STR{'SO_CC_ResIC'}} = $resCC;
                        } else {
                          $newLine .= "-\t";
                          $results{bySO}{$object}{$res}{$STR{'SO_CC_ResIC'}} = '-';
                        }
                      } else { $newLine .= "-\t"; }
                    }
                    chop($newLine);
                    print $tmpFH "$newLine\n";
                  }
                }
              }
              close($tmpFH);
            }
            # Compile results
            # By file
            $results{byFile}{$file}{fileSize}   =  $fileSize if $fileSize; # Size
            $results{byFile}{$file}{nbrLines}   = $fileLines;   # Number of lines
            $results{byFile}{$file}{nbrResults} = $fileResults; # Number of results
            # Add file to the grid By files
            if (my $newLine = $winResults->gridResFiles->InsertRow($file, -1)) {
              $winResults->gridResFiles->SetCellText($newLine, 0, $file        ); # File path
              $winResults->gridResFiles->SetCellFormat($newLine, 1, 2);
              $winResults->gridResFiles->SetCellFormat($newLine, 2, 2);
              $winResults->gridResFiles->SetCellFormat($newLine, 3, 2);
              $winResults->gridResFiles->SetCellText($newLine, 1, $fileSize    ) if $fileSize; # Size
              $winResults->gridResFiles->SetCellText($newLine, 2, $fileLines   ); # Number of lines
              $winResults->gridResFiles->SetCellText($newLine, 3, $fileResults ); # Number of results
            }
            $winResults->gridResFiles->AutoSize();
            $winResults->gridResFiles->ExpandColumnsToFit() if $winResults->gridResFiles->GetVirtualWidth() < $winResults->gridResFiles->Width();
            $winResults->gridResFiles->Refresh();
            # By Special object
            foreach my $object (keys %{$$refExtractParams{SO}}) {
              if ($$refExtractParams{SO}{$object}{nbrRes}) {
                my $expr;
                if (exists($results{bySO}{$object})) {
                  $results{bySO}{$object}{nbrRes} += $$refExtractParams{SO}{$object}{nbrRes};
                } else {
                  $results{bySO}{$object}{nbrRes} = $$refExtractParams{SO}{$object}{nbrRes};
                }
              }
            }
            # Update Results in grid By Object
            foreach my $object (keys %{$$refExtractParams{SO}}) {
              if ($$refExtractParams{SO}{$object}{nbrRes}) {
                my $exist = 0;
                # If Expression is already in grid, update it
                for (my $i = 1; $i < $winResults->gridResExpr->GetRows(); $i++) {
                  my $currObj = $winResults->gridResExpr->GetCellText($i, 0);
                  if ($object eq $currObj) {
                    $winResults->gridResExpr->SetCellText($i, 1, $results{bySO}{$object}{nbrRes});
                    $exist = 1;
                    last;
                  }
                }
                # Doesn't exist, create a row
                if (!$exist and my $newLine = $winResults->gridResExpr->InsertRow($object, -1)) {
                  $winResults->gridResExpr->SetCellText($newLine, 0, $object);
                  $winResults->gridResExpr->SetCellText($newLine, 1, $results{bySO}{$object}{nbrRes});
                  my $optionStr;
                  if (scalar(keys %{$$refExtractParams{SO}{$object}{options}})) {
                    foreach my $opt (keys %{$$refExtractParams{SO}{$object}{options}}) { $optionStr .= $opt . ","; }
                    chop($optionStr);
                    $winResults->gridResExpr->SetCellText($newLine, 2, $optionStr) if $optionStr;
                  }
                }
              }
            }
            $winResults->gridResExpr->AutoSize();
            if ($winResults->gridResExpr->GetVirtualWidth()  < $winResults->gridResExpr->Width() ) { $winResults->gridResExpr->ExpandColumnsToFit();  }
            $winResults->gridResExpr->Refresh();
            # Reset number of result for object
            foreach my $object (keys %{$$refExtractParams{SO}}) { $$refExtractParams{SO}{$object}{nbrRes} = 0; }
          }
          $count++;
          $winResults->lblCount->Text("$count / $nbrFiles");
          $winResults->pb->StepIt();
        }
        # Disconnect opened Database
        $dbhTLD->disconnect()       if $dbhTLD;
        $dbhXLWhoisDB->disconnect() if $dbhXLWhoisDB;
        $dbhMACAddr->disconnect()   if $dbhMACAddr;
        $winResults->btnSaveResultsExtract->Enable();
        $winResults->btnWinReport->Enable();
        # Store results in a JSON file
        if (scalar(keys %results) and open(my $json, '>:encoding(cp1252)', "$REPORTDIR\\CurrentExtractResults-" . $PROCESSID .'.json')) {
          my $jsonObj = JSON->new;
          my $jsonText = $jsonObj->encode(\%results);
          print $json $jsonText;
          close($json);
        }
      } else { Win32::GUI::MessageBox($winResults, $STR{'noFile'}, $STR{'error'}, 0x40010); } # No files
      $winResults->pb->SetPos(0);
      $winResults->pb->Hide;
      $winResults->lblCurr->Text('');
      $winResults->lblCount->Text('');
      $winResults->ChangeCursor($ARROW);
      $winResults->btnCancelExtract->Hide();
      $winResults->btnCloseWinResults->Show();
    });
  }

}  #--- End extractSOFiles

#------------------------------------------------------------------------------#
sub extractSOFileTxt
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refSO, $validEmail, $remParam, $refResults, $refTLDDB, $clipboard) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Clipboard
  if ($file eq 'Clipboard' and $clipboard eq 'Clipboard' and Win32::Clipboard::IsText() and my $text = Win32::Clipboard::GetText()) {
    my @tab = split(/\n/, $text);
    foreach (@tab) {
      s/[\n\r]//g;
      if ($_) {
        my ($nbrResLine, $refListResLine) = &extractSOString($_, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
      }
      $nbrLines++;
    }
  # Text file
  } else {
    if (open(my $fh, $file)) {
      while (<$fh>) {
        s/[\n\r]//g;
        my ($nbrResLine, $refListResLine) = &extractSOString($_, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
        $nbrLines++;
      }
      close($fh);
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractSOFileTxt

#------------------------------------------------------------------------------#
sub extractSOFileUnicode
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileType, $refSO, $validEmail, $remParam, $refResults, $refTLDDB) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  my $fh;
  # HTML type
  if ($fileType eq 'HTML') { $fh = html_file($file); }
  # Other type
  else {
    my $encoding;
    open(my $fhTmp, $file);
    binmode($fhTmp);
    if (read($fhTmp, my $filestart, 500)) {
      if (my $enc = guess_encoding($filestart)) {
        if (defined $enc and $enc !~ /ambiguous/ and $enc !~ /No appropriate encodings found/) {
          if (my $enco = $enc->name) { $encoding = "<:encoding(" . $enco . ")"; }
        }
      }
    }
    close($fhTmp);
    open($fh, $encoding, $file);
  }
  if ($fh) {
    while (<$fh>) {
      s/[\n\r]//g;
      my ($nbrResLine, $refListResLine) = &extractSOString($_, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
      if ($nbrResLine) {
        $nbrResults += $nbrResLine;
        push(@listResFile, @{$refListResLine});
      }
      $nbrLines++;
    }
    close($fh);
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractSOFileUnicode

#------------------------------------------------------------------------------#
sub extractSOFileDoc
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $MSWordOpt, $refSO, $validEmail, $remParam, $refResults, $refTLDDB) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Using MS Word (Work for Doc and Docx)
  if ($MSWordOpt eq 'MSWORD=1') {
    if (my $document = Win32::OLE->GetObject($file, sub {$_[0]->Quit;})) {
      if (my $paragraphs = $document->Paragraphs()) {
        if (my $enumerate  = new Win32::OLE::Enum($paragraphs)) {
          while(defined(my $paragraph = $enumerate->Next())) {
            my $line = $paragraph->{Range}->{Text};
            $line    =~ s/[\n\r]//g;
            $line    =~ s/\x0b/\n/g;
            my ($nbrResLine, $refListResLine) = &extractSOString($line, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
            if ($nbrResLine) {
              $nbrResults += $nbrResLine;
              push(@listResFile, @{$refListResLine});
            }
            $nbrLines++;
          }
        }
      }
      $document->close();
      $document->Quit;
      Win32::OLE->QuitMessageLoop();
      Win32::OLE->Uninitialize();
    }
  # Without MS Word (Doc)
  } elsif ($fileFormat eq 'Doc') {
    my $extract = Text::Extract::Word->new($file);
    my @tab     = split(/[\r\n]/, $extract->get_text(':raw'));
		foreach (@tab) {
      s/[\n\r]//g;
      my ($nbrResLine, $refListResLine) = &extractSOString($_, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
      if ($nbrResLine) {
        $nbrResults += $nbrResLine;
        push(@listResFile, @{$refListResLine});
      }
      $nbrLines++;
		}
  # Without MS Word (Docx)
  } elsif ($fileFormat eq 'Docx') {
    # Use Zip parser
    if (my $zip = Archive::Zip->new($file)) {
      my @members = $zip->membersMatching('^word/(document|endnotes)\.xml');
      foreach my $member (@members) {
        if (my $reader = new XML::LibXML::Reader(string => $member->contents().'')) {
          my $line;
          while ($reader->read) {
            if ($reader->nodePath =~ /\/w:p$/ and $line) {
              chop($line);
              my ($nbrResLine, $refListResLine) = &extractSOString($line, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
              if ($nbrResLine) {
                $nbrResults += $nbrResLine;
                push(@listResFile, @{$refListResLine});
              }
              $nbrLines++;
              $line = '';
            } elsif ($reader->nodePath =~ /\/w:t\/text()/) { $line .= $reader->value . "\t"; }
          }
          $reader->finish;
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractSOFileDoc

#------------------------------------------------------------------------------#
sub extractSOFileXls
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $refSO, $validEmail, $remParam, $refResults, $refTLDDB) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Xls
  if ($fileFormat eq 'Xls') {
    my $xls;
    eval { $xls = Spreadsheet::ParseExcel::Simple->read($file); };
    if ($xls) {
      foreach my $sheet ($xls->sheets) {
        while ($sheet->has_data) {
          my $line = join("\t", $sheet->next_row);
          if ($line) {
            my ($nbrResLine, $refListResLine) = &extractSOString($line, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
            if ($nbrResLine) {
              $nbrResults += $nbrResLine;
              push(@listResFile, @{$refListResLine});
            }
            $nbrLines++;
          }
        }
      }
    }
  # Xlsx
  } elsif ($fileFormat eq 'Xlsx' and my $xlsx = Spreadsheet::XLSX->new($file)) {
    foreach my $sheet (@{$xlsx->{Worksheet}}) {
      $sheet->{MaxRow} ||= $sheet->{MinRow};
      foreach my $row ($sheet->{MinRow} .. $sheet->{MaxRow}) {
        my $line;
        # Combine cells for each row
        $sheet->{MaxCol} ||= $sheet->{MinCol};
        foreach my $col ($sheet->{MinCol} ..  $sheet->{MaxCol}) {
          my $cell = $sheet->{Cells}[$row][$col];
          $line .= $cell->{Val} if $cell->{Val};
          $line .= "\t";
        }
        while ($line =~ /[\t]$/) { chop($line); }
        if ($line) {
          my ($nbrResLine, $refListResLine) = &extractSOString($line, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
          if ($nbrResLine) {
            $nbrResults += $nbrResLine;
            push(@listResFile, @{$refListResLine});
          }
        }
        $nbrLines++;
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractSOFileXls

#------------------------------------------------------------------------------#
sub extractSOFileEvt
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $fileFormat, $refSO, $validEmail, $remParam, $refResults, $refTLDDB) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  # Evt
  if ($fileFormat eq 'Evt' and my $evt = Parse::EventLog->new($file)) {
    my %c = $evt->getAll();
    foreach my $a (keys %c) {
      my $line;
      $line  .= $c{$a}{EventID}                  . "\t";
      $line  .= localtime($c{$a}{TimeGenerated}) . "\t";
      $line  .= GetEventType($c{$a}{EventType})  . "\t";
      $line  .= $c{$a}{Source}                   . "\t";
      $line  .= $c{$a}{Computer}                 . "\t";
      my $str = $c{$a}{Strings};
      if ($str) {
        foreach my $s (@$str) { if ($s) { $s =~ s/[\t\r\n]/ /g; $line .= "$s|"; } }
      }
      chop($line);
      if ($line) {
        my ($nbrResLine, $refListResLine) = &extractSOString($line, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
      }
      $nbrLines++;
    }
  # Evtx
  } elsif ($fileFormat eq 'Evtx' and open(my $fh, $file)) {
    if (my $parser = Win32::EventLog->new($file)) {
      my $nbrRecs;
      my $base;
      my $x = 0;
      $parser->GetNumber($nbrRecs);
      $parser->GetOldest($base);
      while ($x < $nbrRecs) {
        my $hashRef;
        if ($parser->Read(EVENTLOG_FORWARDS_READ|EVENTLOG_SEEK_READ,$base+$x,$hashRef)) {
          Win32::EventLog::GetMessageText($hashRef);
					my $line = $hashRef->{Message};
					if (!$line) { $line = $hashRef->{Strings}; }
					if ($line) {
            my ($nbrResLine, $refListResLine) = &extractSOString($line, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
            if ($nbrResLine) {
              $nbrResults += $nbrResLine;
              push(@listResFile, @{$refListResLine});
            }
          }
          $nbrLines++;
        }
        $x++;
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractSOFileEvt

#------------------------------------------------------------------------------#
sub extractSOFilePdf
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refSO, $validEmail, $remParam, $refResults, $refTLDDB) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  if (my $pdf = CAM::PDF->new($file)) {
    if (my $nbrPages = $pdf->numPages()) {
      for (my $i = 1; $i <= $nbrPages; $i++) {
        if (my $text = $pdf->getPageText($i)) {
          my @lines = split(/\n/, $text);
          foreach my $line (@lines) {
            if ($line) {
              my ($nbrResLine, $refListResLine) = &extractSOString($line, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
              if ($nbrResLine) {
                $nbrResults += $nbrResLine;
                push(@listResFile, @{$refListResLine});
              }
            }
            $nbrLines++;
          }
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractSOFilePdf

#------------------------------------------------------------------------------#
sub extractSOFileMsg
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refSO, $validEmail, $remParam, $refResults, $refTLDDB) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  my $msg;
  eval { $msg = new Email::Outlook::Message($file); };
  if ($msg and my $mime = $msg->to_email_mime) {
    my @tab = split(/\n/, $mime->as_string);
    foreach my $line (@tab) {
      $line =~ s/[\n\r]//g;
      if ($line) {
        my ($nbrResLine, $refListResLine) = &extractSOString($line, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
        if ($nbrResLine) {
          $nbrResults += $nbrResLine;
          push(@listResFile, @{$refListResLine});
        }
      }
      $nbrLines++;
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractSOFileMsg

#------------------------------------------------------------------------------#
sub extractSOFileZip
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refSO, $validEmail, $remParam, $refResults, $refTLDDB) = @_;
  my $nbrLines   = 0;
  my $nbrResults = 0;
  my @listResFile;
  if (my $zip = Archive::Zip->new($file)) {
    my @members = $zip->members();
    foreach (@members) {
      my $filename = $_->fileName();
      #my $zipPath  = "$file\@$filename";
      #print "$zipPath\n";
      if (! $_->isEncrypted()) {
        if (my $str = $_->contents()) {
          my @tab = split(/[\r\n]/, $str);
          foreach my $line (@tab) {
            if ($line) {
              my ($nbrResLine, $refListResLine) = &extractSOString($line, $refSO, $validEmail, $remParam, $refResults, $refTLDDB);
              if ($nbrResLine) {
                $nbrResults += $nbrResLine;
                push(@listResFile, @{$refListResLine});
              }
            }
            $nbrLines++;
          }
        }
      }
    }
  }
  return($nbrLines, $nbrResults, \@listResFile);
  
}  #--- End extractSOFileZip

#------------------------------------------------------------------------------#
sub extractSOString
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($line, $refSO, $validEmail, $remParam, $refResults, $refTLDDB) = @_;
  my $nbrResLine = 0;
  my @resLine;
  # Extract special objects
  foreach my $object (keys %{$refSO}) {
    my ($nbrRes, $refListRes);
    # Call the appropriate Extract object function
    ($nbrRes, $refListRes) = &extractIPv4Addr(   $line, $object, $refResults)                         if $object eq $STR{'SO_IPv4Addr'};
    ($nbrRes, $refListRes) = &extractIPv6Addr(   $line, $object, $refResults)                         if $object eq $STR{'SO_IPv6Addr'};
    ($nbrRes, $refListRes) = &extractURLs(       $line, $object, $remParam, $refResults)              if $object eq $STR{'SO_URLs'};
    ($nbrRes, $refListRes) = &extractEmails(     $line, $object, $validEmail, $refResults, $refTLDDB) if $object eq $STR{'SO_Emails'};
    ($nbrRes, $refListRes) = &extractHostnames(  $line, $object, $refResults, $refTLDDB)              if $object eq $STR{'SO_Hostnames'};
    ($nbrRes, $refListRes) = &extractDomainNames($line, $object, $refResults, $refTLDDB)              if $object eq $STR{'SO_DomainNames'};
    ($nbrRes, $refListRes) = &extractMACAddr(    $line, $object, $refResults)                         if $object eq $STR{'SO_MACAddr'};
    ($nbrRes, $refListRes) = &extractCreditCards($line, $object, $refResults)                         if $object eq $STR{'SO_CreditCards'};
    # If Expr has results
    if ($nbrRes) {
      $nbrResLine += $nbrRes;
      push(@resLine, @{$refListRes});
      $$refSO{$object}{nbrRes} += $nbrRes;
    }
  }
  # Return results
  return($nbrResLine, \@resLine);
  
}  #--- End extractSOString

#--------------------------#
sub extractIPv4Addr
#--------------------------#
{
  # Local variables
  my ($line, $object, $refResults) = @_;
  my $nbrResLine = 0;
  my @resLine;
  # Extraction
  chomp($line);
  while ($line =~ /(?:[^0-9]|^)((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))(?:[^0-9\.]|$)/) {
    my $el = $1;
    push(@resLine, "$object\t$el");
    $nbrResLine++;
    if (exists($$refResults{bySO}{$STR{'SO_IPv4Addr'}}{$el}) and exists($$refResults{bySO}{$STR{'SO_IPv4Addr'}}{$el}{nbr})) {
      $$refResults{bySO}{$STR{'SO_IPv4Addr'}}{$el}{nbr}++;
    } else { $$refResults{bySO}{$STR{'SO_IPv4Addr'}}{$el}{nbr} = 1; }
    my $longLigne = length($line);
    my $long      = length($el);
    my $pos       = index($line, $el);
    my $offset    = $pos+$long;
    $line         = substr($line,$offset,$longLigne-$offset);
  }
  return($nbrResLine, \@resLine);
  
}  #--- End extractIPv4Addr

#--------------------------#
sub extractIPv6Addr
#--------------------------#
{
  # Local variables
  my ($line, $object, $refResults) = @_;
  my $nbrResLine = 0;
  my @resLine;
  # Extraction
  chomp($line);
  while ($line =~ /($IPv6_re)/) {
    my $el = $1;
    push(@resLine, "$object\t$el");
    $nbrResLine++;
    if (exists($$refResults{bySO}{$STR{'SO_IPv6Addr'}}{$el}) and exists($$refResults{bySO}{$STR{'SO_IPv6Addr'}}{$el}{nbr})) {
      $$refResults{bySO}{$STR{'SO_IPv6Addr'}}{$el}{nbr}++;
    } else { $$refResults{bySO}{$STR{'SO_IPv6Addr'}}{$el}{nbr} = 1; }
    my $longLigne = length($line);
    my $long      = length($el);
    my $pos       = index($line, $el);
    my $offset    = $pos+$long;
    $line         = substr($line,$offset,$longLigne-$offset);
  }
  return($nbrResLine, \@resLine);
  
}  #--- End extractIPv6Addr

#--------------------------#
sub extractURLs
#--------------------------#
{
  # Local variables
  my ($line, $object, $remParam, $refResults) = @_;
  my $nbrResLine = 0;
  my @resLine;
  # Extraction
  chomp($line);
  while ($line =~ /((?:http:\/\/|www[0-9]?\.|ftp\.)[\w|\.|\/|\#|\=|\,|\-|\?|\%|\;|\:|\@|\&|\_|\+|\$]+)/i or
         $line =~ /((?:href=\"?|src=\"?)[\w|\.|\/|\#|\=|\,|\-|\?|\%|\;|\:|\@|\&|\_|\+|\$]+)/i) {
    my $el = $1;
    if ($remParam and $el =~ /([^\?]+)\?/) { $el = $1; } # Remove parameters
    push(@resLine, "$object\t$el");
    $nbrResLine++;
    if (exists($$refResults{bySO}{$STR{'SO_URLs'}}{$el}) and exists($$refResults{bySO}{$STR{'SO_URLs'}}{$el}{nbr})) {
      $$refResults{bySO}{$STR{'SO_URLs'}}{$el}{nbr}++;
    } else { $$refResults{bySO}{$STR{'SO_URLs'}}{$el}{nbr} = 1; }
    my $longLigne = length($line);
    my $long      = length($el);
    my $pos       = index($line, $el);
    my $offset    = $pos+$long;
    $line         = substr($line,$offset,$longLigne-$offset);
  }
  return($nbrResLine, \@resLine);
  
}  #--- End extractURLs

#--------------------------#
sub extractEmails
#--------------------------#
{
  # Local variables
  my ($line, $object, $validEmail, $refResults, $refTLDDB) = @_;
  my $nbrResLine = 0;
  my @resLine;
  # Extraction
  chomp($line);
  while ($line =~ /([\w\.\-]+@[\w\.\-]+\.+[a-zA-Z]+)/) {
    my $el    = $1;
    my $valid = 0;    
    if ($validEmail) { # Validate email domain
      my $dom = (split(/\@/, $el))[1];
      my $ext = $$refTLDDB->get_root_domain(lc($dom));
      if ($ext) {
        $dom =~ s/$ext//i; # Remove domain, left ? Ex. www
        $valid = 1 if !$dom;
      }
    } else { $valid = 1; } # We don't validate domain
    if ($valid) {
      push(@resLine, "$object\t$el");
      $nbrResLine++;
      if (exists($$refResults{bySO}{$STR{'SO_Emails'}}{$el}) and exists($$refResults{bySO}{$STR{'SO_Emails'}}{$el}{nbr})) {
        $$refResults{bySO}{$STR{'SO_Emails'}}{$el}{nbr}++;
      } else { $$refResults{bySO}{$STR{'SO_Emails'}}{$el}{nbr} = 1; }
    }
    my $longLigne = length($line);
    my $long      = length($el);
    my $pos       = index($line, $el);
    my $offset    = $pos+$long;
    $line         = substr($line,$offset,$longLigne-$offset);
  }
  return($nbrResLine, \@resLine);
  
}  #--- End extractEmails

#--------------------------#
sub extractHostnames
#--------------------------#
{
  # Local variables
  my ($line, $object, $refResults, $refTLDDB) = @_;
  my $nbrResLine = 0;
  my @resLine;
  # Extraction
  chomp($line);
  while ($line =~ /((?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.){2,}[a-zA-Z]{2,})(?:[^a-zA-Z]|$)/) {
    my $el = $1;
    if ($el and my $ext = $$refTLDDB->get_root_domain(lc($el))) {
      my $dom = $el =~ s/$ext//ir; # Remove domain, left ? Ex. www
      if ($dom) {
        push(@resLine, "$object\t$el");
        $nbrResLine++;
        if (exists($$refResults{bySO}{$STR{'SO_Hostnames'}}{$el}) and exists($$refResults{bySO}{$STR{'SO_Hostnames'}}{$el}{nbr})) {
          $$refResults{bySO}{$STR{'SO_Hostnames'}}{$el}{nbr}++;
        } else { $$refResults{bySO}{$STR{'SO_Hostnames'}}{$el}{nbr} = 1; }
      }
    }
    my $longLigne = length($line);
    my $long      = length($el);
    my $pos       = index($line, $el);
    my $offset    = $pos+$long;
    $line         = substr($line,$offset,$longLigne-$offset);
  }
  return($nbrResLine, \@resLine);
  
}  #--- End extractHostnames

#--------------------------#
sub extractDomainNames
#--------------------------#
{
  # Local variables
  my ($line, $object, $refResults, $refTLDDB) = @_;
  my $nbrResLine = 0;
  my @resLine;
  # Extraction
  chomp($line);
  while ($line =~ /((?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z]{2,})(?:[^\w\.\-]|$)/) {
    my $el = $1;
    if ($el and my $dom = $$refTLDDB->get_root_domain(lc($el))) {
      push(@resLine, "$object\t$dom");
      $nbrResLine++;
      if (exists($$refResults{bySO}{$STR{'SO_DomainNames'}}{$el}) and exists($$refResults{bySO}{$STR{'SO_DomainNames'}}{$el}{nbr})) {
        $$refResults{bySO}{$STR{'SO_DomainNames'}}{$el}{nbr}++;
      } else { $$refResults{bySO}{$STR{'SO_DomainNames'}}{$el}{nbr} = 1; }
    }
    my $longLigne = length($line);
    my $long      = length($el);
    my $pos       = index($line, $el);
    my $offset    = $pos+$long;
    $line         = substr($line,$offset,$longLigne-$offset);
  }
  return($nbrResLine, \@resLine);
  
}  #--- End extractDomainNames

#--------------------------#
sub extractMACAddr
#--------------------------#
{
  # Local variables
  my ($line, $object, $refResults) = @_;
  my $nbrResLine = 0;
  my @resLine;
  # Extraction
  chomp($line);
  while ($line =~ /(?:^|[^\-])((?:[a-fA-F0-9]{2}\-){5}[a-fA-F0-9]{2})(?:$|[^\-])/ or
         $line =~ /(?:^|[^\:])((?:[a-fA-F0-9]{2}\:){5}[a-fA-F0-9]{2})(?:$|[^\:])/) {
    my $el = $1;
    push(@resLine, "$object\t$el");
    $nbrResLine++;
    if (exists($$refResults{bySO}{$STR{'SO_MACAddr'}}{$el}) and exists($$refResults{bySO}{$STR{'SO_MACAddr'}}{$el}{nbr})) {
      $$refResults{bySO}{$STR{'SO_MACAddr'}}{$el}{nbr}++;
    } else { $$refResults{bySO}{$STR{'SO_MACAddr'}}{$el}{nbr} = 1; } 
    my $longLigne = length($line);
    my $long      = length($el);
    my $pos       = index($line, $el);
    my $offset    = $pos+$long;
    $line         = substr($line,$offset,$longLigne-$offset);
  }
  return($nbrResLine, \@resLine);
  
}  #--- End extractMACAddr

#--------------------------#
sub extractCreditCards
#--------------------------#
{
  # Local variables
  my ($line, $object, $refResults) = @_;
  my $nbrResLine = 0;
  my @resLine;
  # Extraction
  chomp($line);
  while (($line =~ /(?:[^0-9\-]|^)((?:(?:[0-9]{4}\-){3})[0-9]{4})(?:[^0-9\-]|$)/) or
         ($line =~ /(?:[^0-9]|^)((?:(?:[0-9]{4} ){3})[0-9]{4})(?:[^0-9]|$)/     ) or
         ($line =~ /(?:[^0-9\-]|(?:[^b]|^)\-|^)(4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})(?:[^0-9]|$)/) or
         ($line =~ /(?:[^0-9\-]|(?:[^b]|^)\-|^)(\d{15,18}\d)(?:[^0-9]|$)/)) {
    my $el = $1;
    push(@resLine, "$object\t$el");
    $nbrResLine++;
    if (exists($$refResults{bySO}{$STR{'SO_CreditCards'}}{$el}) and exists($$refResults{bySO}{$STR{'SO_CreditCards'}}{$el}{nbr})) {
      $$refResults{bySO}{$STR{'SO_CreditCards'}}{$el}{nbr}++;
    } else { $$refResults{bySO}{$STR{'SO_CreditCards'}}{$el}{nbr} = 1; } 
    my $longLigne = length($line);
    my $long      = length($el);
    my $pos       = index($line, $el);
    my $offset    = $pos+$long;
    $line         = substr($line,$offset,$longLigne-$offset);
  }
  return($nbrResLine, \@resLine);
  
}  #--- End extractCreditCards

#------------------------------------------------------------------------------#
sub formatFileSize
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($size) = @_; # Size in bytes
  my $sizeUnit = $STR{'b2'};
  # Round to the biggest unit
  if ($size > 1024) {
    $size = int($size/1024);
    if ($size > 1024) {
      $size = int($size/1024);
      if ($size > 1024) {
        $size = int($size/1024);
        $sizeUnit = $STR{'Gb2'};
      } else { $sizeUnit = $STR{'Mb2'}; }
    } else { $sizeUnit = $STR{'Kb2'}; }
  }
  return("$size $sizeUnit");
  
}  #--- End formatFileSize

#--------------------------#
sub getListFiles
#--------------------------#
{
  # Local variables
  my ($refListFiles, $refExtractParams) = @_;
  my $dir = encode('cp1252', $$refExtractParams{input});
  # List of files
  if (!-d $dir) {
    my $filesStr = $dir;
    # Multiple files
    if ($filesStr =~ /" "/) {
      my @items = split(/" "/, $filesStr);
      my $baseDir = shift(@items);
      $baseDir =~ s/^\"//;
      foreach my $item (@items) {
        $item =~ s/\"$//;
        $$refListFiles{$baseDir."\\".$item} = 1;
      }
    # Single file
    } else { $$refListFiles{$filesStr} = 1; }
  # Directory
  } else {
    # Local variables
    my $filter;
    my $selSize;
    my $sizeOp;
    my $regex;
    my $selDateUT;
    my $dateOp;
    my @subFolders;
    my $nbrSubFolders = 1; # The base dir count as one
    my $count         = 0;
    my $nbrFilters    = keys %{$$refExtractParams{filters}};
    # Open base directory
    $winResults->lblCurr->Text($STR{'ListingFile'}.': '.$dir);
    if (opendir(DIR,"$dir\\")) {
      while (my $file = readdir(DIR)) {
        my $filePath = "$dir\\$file";
        if ((-d $filePath) and ($file !~ /^\.\.?$/) and ($file ne 'System Volume Information')) { # It's a directory
          if ($$refExtractParams{recurseDir}) { # Subfolders option
            push(@subFolders, $filePath);
            $nbrSubFolders++;
            $winResults->lblCount->Text("$count/$nbrSubFolders");
          } else { $nbrSubFolders++; }
        } elsif (!-d $filePath and (!$nbrFilters or &testFilters($dir, $refExtractParams, $nbrFilters, $file, $filePath))) { # It's a file
          $$refListFiles{$filePath} = 0; # Filter match
        }
      }
      closedir(DIR);
    }
    $count++;
    $winResults->lblCount->Text("$count/$nbrSubFolders");
    # List folders and files in subfolders
    if ($$refExtractParams{recurseDir} and scalar(@subFolders) > 0) {
      foreach my $subFolder (@subFolders) {
        $winResults->lblCurr->Text($STR{'ListingFile'}.': '.$subFolder);
        if (opendir(DIR,"$subFolder\\")) {
          while (my $file = readdir(DIR)) {
            my $filePath = "$subFolder\\$file";
            if ((-d $filePath) and ($file !~ /^\.\.?$/)) { # It's a directory
              push(@subFolders, $filePath);
              $nbrSubFolders++;
              $winResults->lblCount->Text("$count/$nbrSubFolders");
            } elsif (!-d $filePath and (!$nbrFilters or &testFilters($dir, $refExtractParams, $nbrFilters, $file, $filePath))) { # It's a file
              $$refListFiles{$filePath} = 0; # Filter match
            }
          }
          closedir(DIR);
        }
        $count++;
        $winResults->lblCount->Text("$count/$nbrSubFolders");
      }
    }
    $winResults->lblCurr->Text('');
    $winResults->lblCount->Text('');
  }

}  #--- End getListFiles

#--------------------------#
sub testFilters
#--------------------------#
{
  # Local variables
  my ($dir, $refExtractParams, $nbrFilters, $file, $path) = @_;
  my $match       = 0;
  # Path is a folder, only Contains filter applies
  if ($path and -d $path) {
    for (my $i = 1; $i <= $nbrFilters; $i++) {
      if ($$refExtractParams{filters}{$i}{Type} eq $STR{'Contains'}) {
        # Regex option is checked
        my $expr;
        my ($case, $regex, $fileOnly) = split(/\-/, $$refExtractParams{filters}{$i}{Flags});
        if (!$regex) { $expr = quotemeta($$refExtractParams{filters}{$i}{SearchStr}); }
        else         { $expr = $$refExtractParams{filters}{$i}{SearchStr};            }
        if (!$fileOnly and
            ((!$case and $path =~ /$expr/i) or ($case and $path =~ /$expr/))) {
          # Match and next operator is OR
          if (exists($$refExtractParams{filters}{$i+1}{Operator}) and
              $$refExtractParams{filters}{$i+1}{Operator} eq $STR{'OR'}) { return(1); }
          else { $match = 1; }
        # Don't match and operator is AND
        } elsif (exists($$refExtractParams{filters}{$i+1}{Operator}) and
                 $$refExtractParams{filters}{$i+1}{Operator} eq $STR{'AND'}) { return(0); }
      # Filter size, Last accessed, Last modified, File Formats apply to files only
      } elsif (($$refExtractParams{filters}{$i}{Type} eq $STR{'rbFiltersSize'}       or
                $$refExtractParams{filters}{$i}{Type} eq $STR{'rbFiltersLastAccess'} or
                $$refExtractParams{filters}{$i}{Type} eq $STR{'rbFiltersLastModif'}  or
                $$refExtractParams{filters}{$i}{Type} eq $STR{'FileFormats'})        and
               ((exists($$refExtractParams{filters}{$i+1}{Operator}) and
                 $$refExtractParams{filters}{$i+1}{Operator} eq $STR{'AND'}) or
                ($$refExtractParams{filters}{$i}{Operator} ne $STR{'OR'}))) {
        return(0);
      }
    }
  # It's a file
  } else {
    for (my $i = 1; $i <= $nbrFilters; $i++) {
      my $matchTmp = 0;
      # Contains filter
      if      ($$refExtractParams{filters}{$i}{Type} eq $STR{'Contains'}) {
        my $expr;
        my ($case, $regex, $fileOnly) = split(/\-/, $$refExtractParams{filters}{$i}{Flags});
        if (!$regex) { $expr = quotemeta($$refExtractParams{filters}{$i}{SearchStr}); }
        else         { $expr = $$refExtractParams{filters}{$i}{SearchStr};            }
        my $relPath = $path =~ s/\Q$dir\E\\//r;
        $relPath    = $file if $fileOnly;
        if ((!$case and $relPath =~ /$expr/i) or ($case and $relPath =~ /$expr/)) { $matchTmp = 1; }
        else { $matchTmp = 0; }
      # File size filter
      } elsif ($$refExtractParams{filters}{$i}{Type} eq $STR{'rbFiltersSize'}) {
        if (&cmpFileSize($path, $$refExtractParams{filters}{$i}{SearchStr}, $$refExtractParams{filters}{$i}{TypeOp})) {
          $matchTmp = 1;
        } else { $matchTmp = 0; }
      # Filter: Last accessed or Last modified
      } elsif ($$refExtractParams{filters}{$i}{Type} eq $STR{'rbFiltersLastAccess'} or
               $$refExtractParams{filters}{$i}{Type} eq $STR{'rbFiltersLastModif'}) {
        my $cmpDateUT;
        if ($$refExtractParams{filters}{$i}{Type} eq $STR{'rbFiltersLastAccess'}) { $cmpDateUT = (stat($path))[8]; }
        else                                                                      { $cmpDateUT = (stat($path))[9]; }
        if (&cmpDates($path, $$refExtractParams{filters}{$i}{DateUT}, $cmpDateUT, $$refExtractParams{filters}{$i}{TypeOp})) {
          $matchTmp = 1;
        } else { $matchTmp = 0; }
      # File format filter
      } elsif ($$refExtractParams{filters}{$i}{Type} eq $STR{'FileFormats'}) {
        if ($path =~ /$$refExtractParams{filters}{$i}{SearchStr}/i or
            ($$refExtractParams{filters}{$i}{TypeOp} eq $STR{'PlainText'} and -T $path)) { $matchTmp = 1; }
        else { $matchTmp = 0; }
      }
      # Match
      if ($matchTmp and exists($$refExtractParams{filters}{$i+1}{Operator})) {
        # Next operator is OR
        if ($$refExtractParams{filters}{$i+1}{Operator} eq $STR{'OR'}) { return(1);  } # No need to check other filter
        else { $match = 1; }
      # Don't match
      } elsif (!$matchTmp) {
        # Next or actual operator is AND
        if ((exists($$refExtractParams{filters}{$i+1}{Operator}) and
             ($$refExtractParams{filters}{$i+1}{Operator} eq $STR{'AND'}) or
              ($$refExtractParams{filters}{$i}{Operator} eq $STR{'AND'}))) { return(0); } # No need to check other filter
        else { $match = 0; }
      } else { $match = $matchTmp; }
    }
  }
  return(1) if $match;
  return(0);

}  #--- End testFilters

#--------------------------#
sub cmpDates
#--------------------------#
{
  # Local variables
  my ($filePath, $selDateUT, $cmpDateUT, $dateOp) = @_;
  # For $cmpDateUT, Keep only date
  my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($cmpDateUT);
  my $cmpDateUTR = timelocal(0,0,0,$mday,$mon,$year); # Store in Unixtime format
  return(1) if $dateOp eq $STR{'Before'} and $cmpDateUTR  < $selDateUT;
  return(1) if $dateOp eq $STR{'Equal'}  and $cmpDateUTR == $selDateUT;
  return(1) if $dateOp eq $STR{'After'}  and $cmpDateUTR  > $selDateUT;
  return(0);

}  #--- End cmpDates

#--------------------------#
sub cmpFileSize
#--------------------------#
{
  # Local variables
  my ($filePath, $searchStr, $sizeOp) = @_;
  my $fileSize = (stat($filePath))[7];
  my ($cmpSize, $sizeUnit) = split(/ /, $searchStr);
  # Round down file size
  if    ($sizeUnit eq $STR{'b'} ) { $fileSize = $fileSize; }
  elsif ($sizeUnit eq $STR{'Kb'}) { $fileSize = $fileSize / 1024; }
  elsif ($sizeUnit eq $STR{'Mb'}) { $fileSize = $fileSize / 1024 / 1024; }
  elsif ($sizeUnit eq $STR{'Gb'}) { $fileSize = $fileSize / 1024 / 1024 / 1024; }
  $fileSize = sprintf("%.0f", $fileSize);
  return(1) if $sizeOp eq $STR{'Smaller'} and $fileSize  < $cmpSize;
  return(1) if $sizeOp eq $STR{'Equal'}   and $fileSize == $cmpSize;
  return(1) if $sizeOp eq $STR{'Bigger'}  and $fileSize  > $cmpSize;
  return(0);

}  #--- End cmpFileSize

#------------------------------------------------------------------------------#
sub loadTLDDB
#------------------------------------------------------------------------------#
{
  # Load TLD Database
  my $dbFile = shift;
  $dbFile    = encode('utf8', $dbFile);
  my $dsn    = "DBI:SQLite:dbname=$dbFile";
  if (my $dbhTLD = DBI->connect($dsn, undef, undef, { RaiseError => 1 })) { return($dbhTLD); }
  
}  #--- End loadTLDDB

#------------------------------------------------------------------------------#
sub loadXLWhoisDB
#------------------------------------------------------------------------------#
{
  # Load XL-Whois Database
  my $dbFile = shift;
  $dbFile    = encode('utf8', $dbFile);
  my $dsn    = "DBI:SQLite:dbname=$dbFile";
  if (my $dbhXLWhoisDB = DBI->connect($dsn, undef, undef, { RaiseError => 1 })) { return($dbhXLWhoisDB); }
  
}  #--- End loadXLWhoisDB

#------------------------------------------------------------------------------#
sub loadGeoIP
#------------------------------------------------------------------------------#
{
  # Load GeoIP Database
  my $dbFile = shift;
  if (my $dbhGeoIP = Geo::IP->open($dbFile, GEOIP_MEMORY_CACHE)) { return($dbhGeoIP); }
  
}  #--- End loadGeoIP

#------------------------------------------------------------------------------#
sub loadMACAddrDB
#------------------------------------------------------------------------------#
{
  # Load MAC Address OUI Database
  my $dbFile = shift;
  $dbFile    = encode('utf8', $dbFile);
  my $dsn    = "DBI:SQLite:dbname=$dbFile";
  if (my $dbhMACAddr = DBI->connect($dsn, undef, undef, { RaiseError => 1 })) { return($dbhMACAddr); }
  
}  #--- End loadMACAddrDB

#------------------------------------------------------------------------------#
sub resolveTLD
#------------------------------------------------------------------------------#
{
  # Local variables
  my $res       = shift;
  my $refDbhTLD = shift;
  # Extract and check TLD in database
  my $tld = (split(/\./, $res))[-1];
  my $sth = $$refDbhTLD->prepare('SELECT value from DATA WHERE key == ? COLLATE NOCASE');
  if ($sth->execute($tld) > -1) {
    my @fields = $sth->fetchrow_array();
    if (scalar(@fields) > 0) {
      my $answer = join('',@fields);
      return($answer);
    }
  }
  return(undef);

}  #--- End resolveTLD

#------------------------------------------------------------------------------#
sub resolveISP
#------------------------------------------------------------------------------#
{
  # Local variables
  my $res             = shift;
  my $refDbhXLWhoisDB = shift;
  if ($res =~ /(?:[^0-9]|^)((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))(?:[^0-9\.]|$)/ or $res =~ /($IPv6_re)/) {
    my $ip = $1;
    my $answer;
    if    ($res =~ /\./) { $answer = &checkIP_WhoisDB_IPv4($ip, $refDbhXLWhoisDB); } # IPv4
    elsif ($res =~ /\:/) { $answer = &checkIP_WhoisDB_IPv6($ip, $refDbhXLWhoisDB); } # IPv6
    return($answer) if $answer;
  }
  return(undef);

}  #--- End resolveISP

#------------------------------------------------------------------------------#
sub resolveGeoIP
#------------------------------------------------------------------------------#
{
  # Local variables
  my $res         = shift;
  my $refDbhGeoIP = shift;
  if ($res =~ /(?:[^0-9]|^)((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))(?:[^0-9\.]|$)/) {
    if (my $record = $$refDbhGeoIP->record_by_addr($1)) {
      my $answer;
      $answer .= $record->city        .', ' if $record->city;
      $answer .= $record->region_name .', ' if $record->region_name;
      $answer .= $record->country_name.', ' if $record->country_name;
      chop($answer); chop($answer);
      return($answer);
    }
  }
  return(undef);

}  #--- End resolveGeoIP

#------------------------------------------------------------------------------#
sub resolveOUI
#------------------------------------------------------------------------------#
{
  # Local variables
  my $res           = shift;
  my $refDbhMACAddr = shift;
  # Extract and check first part of MAC Address in database
  my $sth = $$refDbhMACAddr->prepare('SELECT org from MACOUI WHERE prefix == ?');
  if ($res =~ /((?:[a-fA-F0-9]{2}[\:\-]?){2}[a-fA-F0-9]{2})[\-\:]?(?:[a-fA-F0-9]{2}[\:\-]?){2}[a-fA-F0-9]{2}/) {
    my $prefix =  $1;
    $prefix    =~ s/[\:\-]//g;
    $prefix    =~ tr/a-f/A-F/;
    if ($sth->execute($prefix) > -1) {
      my @fields = $sth->fetchrow_array();
      if (scalar(@fields) > 0) {
        my $answer = join('',@fields);
        return($answer);
      }
    }
  }
  return(undef);

}  #--- End resolveOUI

#------------------------------------------------------------------------------#
sub resolveCreditCard
#------------------------------------------------------------------------------#
{
  # Local variables
  my $res        = shift;
  my $refListIIN = shift;
  my $issuer;
  # Check the card number with Business::CreditCard (Luhn Algorithm)
  my $genIssuer = &cardtype($res);
  # If number valid, check in the IIN Database for a more precise result
  if ($genIssuer and $genIssuer ne 'Not a credit card') {
    my $exactIssuer;
    if ($res =~ /(^[0-9]{2})/) {
      if (exists($$refListIIN{$1})) {
        foreach my $IIN (sort @{$$refListIIN{$1}}) {
          my ($prefix, $issuerName) = split(/\=/, $IIN);
          $exactIssuer = $issuerName if $res =~ /^$prefix/;
        }
      }
    }
    if ($exactIssuer) { $issuer = $exactIssuer; }
    else              { $issuer = $genIssuer;   }
  }
  return($issuer) if $issuer and $issuer !~ /Unknown/i;
  return(undef);

}  #--- End resolveCreditCard

#--------------------------#
sub checkIP_WhoisDB_IPv4
#--------------------------#
{
  # Local variables
  my ($ip, $refDbh) = @_;
  my $ipInt = unpack 'N', pack 'C4', split '\.', $ip;
  my $isp;
  my $country;
  my $date;
  my $interMin = 4294967295;
  # Check if IP address fit any range in database
  my $sth = $$refDbh->prepare("SELECT range_s,range_e,isp,country,date from WHOIS_DB WHERE $ipInt >= range_s AND $ipInt <= range_e");
  my $rv  = $sth->execute();
  if ($rv > -1) {
    # Select the best answer (smaller range)
    my $refAllRows = $sth->fetchall_arrayref();
    foreach my $refRow (@{$refAllRows}) {
      my $inter = $$refRow[1] - $$refRow[0];
      if ($inter < $interMin) {
        $interMin = $inter;
        $isp     = $$refRow[2];
        $country = $$refRow[3];
      }
    }
  }
  return("$isp, $country") if $isp and $country;
  return(undef);

}  #--- End checkIP_WhoisDB_IPv4

#--------------------------#
sub checkIP_WhoisDB_IPv6
#--------------------------#
{
  # Local variables
  my ($ip, $refDbh) = @_;
  # Check if IP address fit any range in database
  my $all = $$refDbh->selectall_arrayref('SELECT * FROM WHOIS_DB_6');
  foreach my $row (@$all) {
    my $cidr = @$row[0];
    return("@$row[1], @$row[2]") if Net::CIDR::cidrlookup($ip, ($cidr));
  }

}  #--- End checkIP_WhoisDB_IPv6

#------------------------------------------------------------------------------#
sub loadListIIN
#------------------------------------------------------------------------------#
{
  # Local variables
  my $IIN_DB = shift;
  my %listIIN;
  # Load IIN Database
  $IIN_DB   = encode('utf8', $IIN_DB);
  my $dsn   = "DBI:SQLite:dbname=$IIN_DB";
  my $dbhCC = DBI->connect($dsn, undef, undef, { RaiseError => 1, AutoCommit => 1 });
  my $all   = $dbhCC->selectall_arrayref('SELECT * FROM IIN');
  foreach my $row (@$all) {
    my @values = @$row;
    push(@{$listIIN{$1}}, "$values[0]=$values[1]") if $values[0] =~ /(^[0-9]{2})/;
  }
  $dbhCC->disconnect();
  return(\%listIIN);
  
}  #--- End loadListIIN

#--------------------------#
sub rbResByFile_Click
#--------------------------#
{
  $winResults->gridResFiles->Show();
  $winResults->gridResExpr->Hide();
  
}  #--- End rbResByFile_Click

#--------------------------#
sub rbResByExpr_Click
#--------------------------#
{
  $winResults->gridResExpr->Show();
  $winResults->gridResFiles->Hide();
  
}  #--- End rbResByExpr_Click

#--------------------------#
sub gridResFiles_Click
#--------------------------#
{
  # Sort rows
  my ($row, $column) = @_;
  if (!$row) {
    $winResults->gridResFiles->SetHeaderSort();
    my $order = $winResults->gridResFiles->GetSortAscending();
    my $colHeaderName = $winResults->gridResFiles->GetCellText($row, $column);
    # Sort Results (numeric)
    if ($colHeaderName eq $STR{'Results'}) {
      $winResults->gridResFiles->SortCells($column, $order, sub { my ($e1, $e2) = @_; return ($e1 <=> $e2); });
    # Else, sort as text
    } else {
      $winResults->gridResFiles->SortCells($column, $order, sub { my ($e1, $e2) = @_; return (lc($e1) cmp lc($e2)); });
    }
    $winResults->gridResFiles->Refresh();
  }

}  #--- End gridResFiles_Click

#--------------------------#
sub gridResFiles_RClick
#--------------------------#
{
  # Show popup menu
  my ($row, $column) = @_;
  my (@coord) = $winResults->gridResFiles->GetSelectedCellRange();
  # Select the right entry if not selected or select has change
  $winResults->gridResFiles->SetSelectedCellRange($row, 0, $row, 5)
  if (($coord[0] and ($row < $coord[0])) or ($coord[2] and ($row > $coord[2])) or !$coord[0]);
  my ($X, $Y) = Win32::GUI::GetCursorPos();
  $winResults->TrackPopupMenu($gridResFilesMenu->{gridResFilesMenu},$X, $Y);
  return(1);

}  #--- End gridResFiles_RClick

#--------------------------#
sub gridResFiles_DblClick
#--------------------------#
{
  # Local variables
  my $row = shift;
  if ($row != 0) {
    my $file = $winResults->gridResFiles->GetCellText($row, 0);
    my %selFiles;
    $selFiles{$file} = 1;
    threads->create(sub { &showTmpFileResult(\%selFiles); });
  }

}  #--- End gridResFiles_DblClick

#--------------------------#
sub showResFileResults_Click
#--------------------------#
{
  # Get selected row number(s)
  my (@coord) = $winResults->gridResFiles->GetSelectedCellRange();
  my $firstSelectedRow;
  my $lastSelectedRow;
  if    ($coord[2]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[2]; }
  elsif ($coord[0]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[0]; }
  else {
    $firstSelectedRow = $winResults->gridResFiles->GetRows()-1;
    $lastSelectedRow  = $winResults->gridResFiles->GetRows()-1;
  }
  my %selFiles;
  for (my $row = $lastSelectedRow; $row >= $firstSelectedRow; $row--) {
    $selFiles{$winResults->gridResFiles->GetCellText($row, 0)} = 1 if $winResults->gridResFiles->IsCellSelected($row, 0);
  }
  threads->create(sub { &showTmpFileResult(\%selFiles); });

}  #--- End showResFileResults_Click

#--------------------------#
sub showResFileResultsNoDupl_Click
#--------------------------#
{
  # Get selected row number(s)
  my (@coord) = $winResults->gridResFiles->GetSelectedCellRange();
  my $firstSelectedRow;
  my $lastSelectedRow;
  if    ($coord[2]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[2]; }
  elsif ($coord[0]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[0]; }
  else {
    $firstSelectedRow = $winResults->gridResFiles->GetRows()-1;
    $lastSelectedRow  = $winResults->gridResFiles->GetRows()-1;
  }
  my %selFiles;
  for (my $row = $lastSelectedRow; $row >= $firstSelectedRow; $row--) {
    $selFiles{$winResults->gridResFiles->GetCellText($row, 0)} = 1 if $winResults->gridResFiles->IsCellSelected($row, 0);
  }
  threads->create(sub { &showTmpFileResultNoDupl(\%selFiles); });

}  #--- End showResFileResultsNoDupl_Click

#--------------------------#
sub showResFileResultsResOnly_Click
#--------------------------#
{
  # Get selected row number(s)
  my (@coord) = $winResults->gridResFiles->GetSelectedCellRange();
  my $firstSelectedRow;
  my $lastSelectedRow;
  if    ($coord[2]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[2]; }
  elsif ($coord[0]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[0]; }
  else {
    $firstSelectedRow = $winResults->gridResFiles->GetRows()-1;
    $lastSelectedRow  = $winResults->gridResFiles->GetRows()-1;
  }
  my %selFiles;
  for (my $row = $lastSelectedRow; $row >= $firstSelectedRow; $row--) {
    $selFiles{$winResults->gridResFiles->GetCellText($row, 0)} = 1 if $winResults->gridResFiles->IsCellSelected($row, 0);
  }
  threads->create(sub { &showTmpFileResultResOnly(\%selFiles); });

}  #--- End showResFileResultsResOnly_Click

#--------------------------#
sub showResFileResultsResOnlyNoDupl_Click
#--------------------------#
{
  # Get selected row number(s)
  my (@coord) = $winResults->gridResFiles->GetSelectedCellRange();
  my $firstSelectedRow;
  my $lastSelectedRow;
  if    ($coord[2]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[2]; }
  elsif ($coord[0]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[0]; }
  else {
    $firstSelectedRow = $winResults->gridResFiles->GetRows()-1;
    $lastSelectedRow  = $winResults->gridResFiles->GetRows()-1;
  }
  my %selFiles;
  for (my $row = $lastSelectedRow; $row >= $firstSelectedRow; $row--) {
    $selFiles{$winResults->gridResFiles->GetCellText($row, 0)} = 1 if $winResults->gridResFiles->IsCellSelected($row, 0);
  }
  threads->create(sub { &showTmpFileResultResOnlyNoDupl(\%selFiles); });

}  #--- End showResFileResultsResOnlyNoDupl_Click

#--------------------------#
sub openResFile_Click
#--------------------------#
{
  # Get selected row number(s)
  my (@coord) = $winResults->gridResFiles->GetSelectedCellRange();
  my $firstSelectedRow;
  my $lastSelectedRow;
  if    ($coord[2]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[2]; }
  elsif ($coord[0]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[0]; }
  else {
    $firstSelectedRow = $winResults->gridResFiles->GetRows()-1;
    $lastSelectedRow  = $winResults->gridResFiles->GetRows()-1;
  }
  # Open file, one by one
  for (my $row = $lastSelectedRow; $row >= $firstSelectedRow; $row--) {
    if ($winResults->gridResFiles->IsCellSelected($row, 0)) {
      my $file = $winResults->gridResFiles->GetCellText($row, 0);
      $winResults->ShellExecute('open', $file,'','',1);
    }
  }
  return(1);

}  #--- End openResFile_Click

#--------------------------#
sub copyResFile_Click
#--------------------------#
{
  # Get selected row number(s)
  my (@coord) = $winResults->gridResFiles->GetSelectedCellRange();
  my $firstSelectedRow;
  my $lastSelectedRow;
  if    ($coord[2]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[2]; }
  elsif ($coord[0]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[0]; }
  else {
    $firstSelectedRow = $winResults->gridResFiles->GetRows()-1;
    $lastSelectedRow  = $winResults->gridResFiles->GetRows()-1;
  }
  # Ask for a destination directory
  my $dstFolder = Win32::GUI::BrowseForFolder(-owner => $winResults, -title => $STR{'selDirDst'}.':', -folderonly => 1, -newui => 1);
  if ($dstFolder and -d $dstFolder) {
    # List files to be copied and calculate total size
    my $totalSize;
    my @listFile2Copy;
    for (my $row = $lastSelectedRow; $row >= $firstSelectedRow; $row--) {
      if ($winResults->gridResFiles->IsCellSelected($row, 0)) {
        push(@listFile2Copy, $winResults->gridResFiles->GetCellText($row, 0));
        $totalSize += $winResults->gridResFiles->GetCellText($row, 1);
      }
    }
    # Check if enough space on the destination volume
    if ($dstFolder =~ /^([a-zA-Z])\:/i) {
      my $dstDriveLetter = $1;
      my $freeSpace = (Win32::DriveInfo::DriveSpace("$dstDriveLetter:"))[6];
      if ($totalSize and $totalSize >= $freeSpace) { # Not enough space, show an error message
        Win32::GUI::MessageBox($winResults, $STR{'errSpace'}, $STR{'Error'}, 0x40010);
      } else {
        # Local variables
        my $count    = 0;
        my $nbrFiles = scalar(@listFile2Copy);
        # Show progress
        $winResults->pb->Show();
        $winResults->ChangeCursor($HOURGLASS);
        $winResults->pb->SetRange(0, $nbrFiles);
        $winResults->pb->SetPos(0);
        $winResults->pb->SetStep(1);
        $winResults->lblCount->Text("0 / $nbrFiles");
        $winResults->lblCurr->Text("$STR{'Copying'} $STR{'Started'}");
        # Copy files
        my $statusCopy = 1;
        my $copyMsg;
        foreach my $file (@listFile2Copy) {
          $winResults->lblCurr->Text("$STR{'Copying'} $file");
          # Set destination file path
          my @pathParts = split(/\\/, $file);
          my $filename  = pop(@pathParts);
          my $dstFile   = $dstFolder . "\\" . $filename;
          # Copy the file
          if (Win32::CopyFile($file, $dstFile, 0)) {
            $count++;
            $winResults->lblCount->Text("$count / $nbrFiles");
            $winResults->pb->StepIt();
          } else { $statusCopy = 0; $copyMsg = $!; }
        }
        # Hide Progress
        $winResults->pb->SetPos(0);
        $winResults->pb->Hide();
        $winResults->lblCurr->Text('');
        $winResults->lblCount->Text('');
        $winResults->ChangeCursor($ARROW);
        # Final message
        if ($statusCopy) { Win32::GUI::MessageBox($winResults, "$STR{'Copying'} $STR{'Finished'}", "XL-Parser $VERSION", 0x40040); }
        else             { Win32::GUI::MessageBox($winResults, "$STR{'errorCopying'}: $copyMsg", $STR{'error'}, 0x40010); }
      }
    }
  }
  return(1);

}  #--- End copyResFile_Click

#--------------------------#
sub selectAllResFiles_Click
#--------------------------#
{
  $winResults->gridResFiles->OnEditSelectAll();
  return(1);

}  #--- End selectAllResFiles_Click

#--------------------------#
sub copySelResFilesRow_Click
#--------------------------#
{
  my (@coord) = $winResults->gridResFiles->GetSelectedCellRange();
  my $content;
  # Selected IPs
  my @listIPs;
  my $lastSelectedRow; 
  if ($coord[2]) { $lastSelectedRow = $coord[2]; }
  else           { $lastSelectedRow = $coord[0]; }
  # Header is always inserted
  for (my $col = 0; $col <= $winResults->gridResFiles->GetColumns(); $col++) {
    $content .= $winResults->gridResFiles->GetCellText(0, $col) . "\t";
  }
  chop($content);
  $content .= "\r\n";
  for (my $row = $coord[0]; $row <= $lastSelectedRow; $row++) {
    if ($winResults->gridResFiles->IsCellSelected($row, 1)) {
      for (my $col = 0; $col <= $winResults->gridResFiles->GetColumns(); $col++) {
        $content .= $winResults->gridResFiles->GetCellText($row, $col) . "\t";
      }
      chop($content);
      $content .= "\r\n";
    }
  }
  Win32::Clipboard::Set($content) if $content;
  return(1);

}  #--- End copySelResFilesRow_Click

#--------------------------#
sub gridResExpr_Click
#--------------------------#
{
  # Sort rows
  my ($row, $column) = @_;
  if (!$row) {
    $winResults->gridResExpr->SetHeaderSort();
    my $order = $winResults->gridResExpr->GetSortAscending();
    my $colHeaderName = $winResults->gridResExpr->GetCellText($row, $column);
    # Sort Results (numeric)
    if ($colHeaderName eq $STR{'Results'}) {
      $winResults->gridResExpr->SortCells($column, $order, sub { my ($e1, $e2) = @_; return ($e1 <=> $e2); });
    # Else, sort as text
    } else {
      $winResults->gridResExpr->SortCells($column, $order, sub { my ($e1, $e2) = @_; return (lc($e1) cmp lc($e2)); });
    }
    $winResults->gridResExpr->Refresh();
  }

}  #--- End gridResExpr_Click

#--------------------------#
sub gridResExpr_RClick
#--------------------------#
{
  # Show popup menu
  my ($row, $column) = @_;
  my (@coord) = $winResults->gridResExpr->GetSelectedCellRange();
  # Select the right entry if not selected or select has change
  $winResults->gridResExpr->SetSelectedCellRange($row, 0, $row, 5)
  if (($coord[0] and ($row < $coord[0])) or ($coord[2] and ($row > $coord[2])) or !$coord[0]);
  my ($X, $Y) = Win32::GUI::GetCursorPos();
  $winResults->TrackPopupMenu($gridResExprMenu->{gridResExprMenu},$X, $Y);
  return(1);

}  #--- End gridResExpr_RClick

#--------------------------#
sub gridResExpr_DblClick
#--------------------------#
{
  # Local variables
  my $row = shift;
  if ($row != 0) {
    my $expr = $winResults->gridResExpr->GetCellText($row, 0);
    my %selExpr;
    $selExpr{$expr} = 1;
    threads->create(sub {
      if ($winResults->rbResByExpr->Text() eq $STR{'rbResByExpr'}) { &showTmpExprResult(\%selExpr); } # Expression
      else                                                          { &showTmpSOResult( \%selExpr); } # Special Object
    });
  }

}  #--- End gridResExpr_DblClick

#--------------------------#
sub showResExprResults_Click
#--------------------------#
{
  # Get selected row number(s)
  my (@coord) = $winResults->gridResExpr->GetSelectedCellRange();
  my $firstSelectedRow;
  my $lastSelectedRow;
  if    ($coord[2]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[2]; }
  elsif ($coord[0]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[0]; }
  else {
    $firstSelectedRow = $winResults->gridResExpr->GetRows()-1;
    $lastSelectedRow  = $winResults->gridResExpr->GetRows()-1;
  }
  my %selExpr;
  for (my $row = $lastSelectedRow; $row >= $firstSelectedRow; $row--) {
    $selExpr{$winResults->gridResExpr->GetCellText($row, 0)} = 1 if $winResults->gridResExpr->IsCellSelected($row, 0);
  }
  threads->create(sub { &showTmpExprResult(\%selExpr); });

}  #--- End showResExprResults_Click

#--------------------------#
sub showResExprResultsNoDupl_Click
#--------------------------#
{
  # Get selected row number(s)
  my (@coord) = $winResults->gridResExpr->GetSelectedCellRange();
  my $firstSelectedRow;
  my $lastSelectedRow;
  if    ($coord[2]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[2]; }
  elsif ($coord[0]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[0]; }
  else {
    $firstSelectedRow = $winResults->gridResExpr->GetRows()-1;
    $lastSelectedRow  = $winResults->gridResExpr->GetRows()-1;
  }
  my %selExpr;
  for (my $row = $lastSelectedRow; $row >= $firstSelectedRow; $row--) {
    $selExpr{$winResults->gridResExpr->GetCellText($row, 0)} = 1 if $winResults->gridResExpr->IsCellSelected($row, 0);
  }
  threads->create(sub { &showTmpExprResultNoDupl(\%selExpr); });

}  #--- End showResExprResultsNoDupl_Click

#--------------------------#
sub showResExprResultsResOnly_Click
#--------------------------#
{
  # Get selected row number(s)
  my (@coord) = $winResults->gridResExpr->GetSelectedCellRange();
  my $firstSelectedRow;
  my $lastSelectedRow;
  if    ($coord[2]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[2]; }
  elsif ($coord[0]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[0]; }
  else {
    $firstSelectedRow = $winResults->gridResExpr->GetRows()-1;
    $lastSelectedRow  = $winResults->gridResExpr->GetRows()-1;
  }
  my %selExpr;
  for (my $row = $lastSelectedRow; $row >= $firstSelectedRow; $row--) {
    $selExpr{$winResults->gridResExpr->GetCellText($row, 0)} = 1 if $winResults->gridResExpr->IsCellSelected($row, 0);
  }
  threads->create(sub { &showTmpExprResultResOnly(\%selExpr); });

}  #--- End showResExprResultsResOnly_Click

#--------------------------#
sub showResExprResultsResOnlyNoDupl_Click
#--------------------------#
{
  # Get selected row number(s)
  my (@coord) = $winResults->gridResExpr->GetSelectedCellRange();
  my $firstSelectedRow;
  my $lastSelectedRow;
  if    ($coord[2]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[2]; }
  elsif ($coord[0]) { $firstSelectedRow = $coord[0]; $lastSelectedRow = $coord[0]; }
  else {
    $firstSelectedRow = $winResults->gridResExpr->GetRows()-1;
    $lastSelectedRow  = $winResults->gridResExpr->GetRows()-1;
  }
  my %selExpr;
  for (my $row = $lastSelectedRow; $row >= $firstSelectedRow; $row--) {
    $selExpr{$winResults->gridResExpr->GetCellText($row, 0)} = 1 if $winResults->gridResExpr->IsCellSelected($row, 0);
  }
  threads->create(sub { &showTmpExprResultResOnlyNoDupl(\%selExpr); });

}  #--- End showResExprResultsResOnlyNoDupl_Click

#--------------------------#
sub selectAllResExpr_Click
#--------------------------#
{
  $winResults->gridResExpr->OnEditSelectAll();
  return(1);

}  #--- End selectAllResExpr_Click

#--------------------------#
sub copySelResExprRow_Click
#--------------------------#
{
  my (@coord) = $winResults->gridResExpr->GetSelectedCellRange();
  my $content;
  # Selected IPs
  my @listIPs;
  my $lastSelectedRow; 
  if ($coord[2]) { $lastSelectedRow = $coord[2]; }
  else           { $lastSelectedRow = $coord[0]; }
  # Header is always inserted
  for (my $col = 0; $col <= $winResults->gridResExpr->GetColumns(); $col++) {
    $content .= $winResults->gridResExpr->GetCellText(0, $col) . "\t";
  }
  chop($content);
  $content .= "\r\n";
  for (my $row = $coord[0]; $row <= $lastSelectedRow; $row++) {
    if ($winResults->gridResExpr->IsCellSelected($row, 1)) {
      for (my $col = 0; $col <= $winResults->gridResExpr->GetColumns(); $col++) {
        $content .= $winResults->gridResExpr->GetCellText($row, $col) . "\t";
      }
      chop($content);
      $content .= "\r\n";
    }
  }
  Win32::Clipboard::Set($content) if $content;
  return(1);

}  #--- End copySelResExprRow_Click

#--------------------------#
sub showTmpExprResult
#--------------------------#
{
  # Local variable
	my $refSelExpr = shift;
  my $nbrSelExpr = scalar(keys %{$refSelExpr});
  # Compile results
  my $tmpReport  = "$REPORTDIR\\.XL-Parser_tmp-"     . $PROCESSID .'.txt';
  my $tmpResults = "$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt';
  my $totalTmpResults = 0;
  if ($tmpReport and -f $tmpReport and open(my $tmpReportFH, $tmpReport) and open(my $tmpResFH, '>', $tmpResults)) {
    while (<$tmpReportFH>) {
      if (/^([^\t]+)\t([^\t]+)\t(.+)/) {
        if (exists($$refSelExpr{$2})) {
          if ($nbrSelExpr > 1) { print $tmpResFH $_; 				 }
          else                 { print $tmpResFH "$1\t$3\n"; }
          $totalTmpResults++;
        }
      }
    }
    close($tmpReportFH);
    close($tmpResFH);
  }
	if ($totalTmpResults) {
		$winResults->ShellExecute('open', $tmpResults,'','',1);
	} else { Win32::GUI::MessageBox($winResults, $STR{'noResult'}, "XL-Parser $VERSION", 0x40040); }
  
}  #--- End showTmpExprResult

#--------------------------#
sub showTmpExprResultNoDupl
#--------------------------#
{
  # Local variable
  my $refSelExpr = shift;
  my $nbrSelExpr = scalar(keys %{$refSelExpr});
  my %resByExpr;
  # Compile results
  my $tmpReport  = "$REPORTDIR\\.XL-Parser_tmp-"     . $PROCESSID .'.txt';
  my $tmpResults = "$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt';
  my $totalTmpResults = 0;
  # Compile results
  if ($tmpReport and -f $tmpReport and open(my $tmpReportFH, $tmpReport)) {
    while (<$tmpReportFH>) {
      if (/^[^\t]+\t([^\t]+)\t([^\t]+)/) {
        my $object = $1;
        my $result = $2;
        chomp($result);
        if (exists($$refSelExpr{$object})) { # Selected object
          if (exists($resByExpr{$object}) and exists($resByExpr{$object}{$result})) {
            $resByExpr{$object}{$result}++;
          } else { $resByExpr{$object}{$result} = 1; }
          $totalTmpResults++;
        }
      }
    }
    close($tmpReportFH);
    # Print results
    if ($totalTmpResults) {
      if (open(my $tmpResFH, ">$tmpResults")) {
        foreach my $object (keys %resByExpr) {
          foreach my $result (sort {$resByExpr{$object}{$b} <=> $resByExpr{$object}{$a}} keys %{$resByExpr{$object}}) {
            if ($nbrSelExpr > 1) { print $tmpResFH "$object\t$result\t$resByExpr{$object}{$result}\n"; }
            else                 { print $tmpResFH "$result\t$resByExpr{$object}{$result}\n";          }
          }
        }
        close($tmpResFH);
      }
      $winResults->ShellExecute('open', $tmpResults,'','',1);
    } else { Win32::GUI::MessageBox($winResults, $STR{'noResult'} , "XL-Parser $VERSION", 0x40040); }
  }
  
}  #--- End showTmpExprResultNoDupl

#--------------------------#
sub showTmpExprResultResOnly
#--------------------------#
{
  # Local variable
	my $refSelExpr = shift;
  my $nbrSelExpr = scalar(keys %{$refSelExpr});
  # Compile results
  my $tmpReport  = "$REPORTDIR\\.XL-Parser_tmp-"     . $PROCESSID .'.txt';
  my $tmpResults = "$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt';
  my $totalTmpResults = 0;
  if ($tmpReport and -f $tmpReport and open(my $tmpReportFH, $tmpReport) and open(my $tmpResFH, '>', $tmpResults)) {
    while (<$tmpReportFH>) {
      if (/^[^\t]+\t([^\t]+)\t(.+)/) {
        if (exists($$refSelExpr{$1})) {
          if ($nbrSelExpr > 1) { print $tmpResFH $_;     }
          else                 { print $tmpResFH "$2\n"; }
          $totalTmpResults++;
        }
      }
    }
    close($tmpReportFH);
    close($tmpResFH);
  }
	if ($totalTmpResults) {
		$winResults->ShellExecute('open', $tmpResults,'','',1);
	} else { Win32::GUI::MessageBox($winResults, $STR{'noResult'}, "XL-Parser $VERSION", 0x40040); }
  
}  #--- End showTmpExprResultResOnly

#--------------------------#
sub showTmpExprResultResOnlyNoDupl
#--------------------------#
{
  # Local variable
  my $refSelExpr = shift;
  my $nbrSelExpr = scalar(keys %{$refSelExpr});
  my %resByExpr;
  # Compile results
  my $tmpReport  = "$REPORTDIR\\.XL-Parser_tmp-"     . $PROCESSID .'.txt';
  my $tmpResults = "$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt';
  my $totalTmpResults = 0;
  # Compile results
  if ($tmpReport and -f $tmpReport and open(my $tmpReportFH, $tmpReport)) {
    while (<$tmpReportFH>) {
      if (/^[^\t]+\t([^\t]+)\t([^\t]+)/) {
        my $object = $1;
        my $result = $2;
        chomp($result);
        if (exists($$refSelExpr{$object})) { # Selected object
          if (exists($resByExpr{$object}) and exists($resByExpr{$object}{$result})) {
            $resByExpr{$object}{$result}++;
          } else { $resByExpr{$object}{$result} = 1; }
          $totalTmpResults++;
        }
      }
    }
    close($tmpReportFH);
    # Print results
    if ($totalTmpResults) {
      if (open(my $tmpResFH, ">$tmpResults")) {
        foreach my $object (keys %resByExpr) {
          foreach my $result (sort {$resByExpr{$object}{$b} <=> $resByExpr{$object}{$a}} keys %{$resByExpr{$object}}) {
            print $tmpResFH "$result\n";
          }
        }
        close($tmpResFH);
      }
      $winResults->ShellExecute('open', $tmpResults,'','',1);
    } else { Win32::GUI::MessageBox($winResults, $STR{'noResult'} , "XL-Parser $VERSION", 0x40040); }
  }
  
}  #--- End showTmpExprResultResOnlyNoDupl

#--------------------------#
sub showTmpSOResult
#--------------------------#
{
  # Local variable
  my $refSelExpr = shift;
  my $nbrSelExpr = scalar(keys %{$refSelExpr});
  # Compile results
  my $tmpReport  = "$REPORTDIR\\.XL-Parser_tmp2-"    . $PROCESSID .'.txt';
  my $tmpResults = "$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt';
  my $totalTmpResults = 0;
  if ($tmpReport and -f $tmpReport and open(my $tmpReportFH, $tmpReport) and open(my $tmpResFH, '>', $tmpResults)) {
    while (<$tmpReportFH>) {
      if (/^([^\t]+)\t([^\t]+)\t(.+)/) {
        if (exists($$refSelExpr{$1})) {
          if ($nbrSelExpr > 1) { print $tmpResFH $_; }
          else                 { print $tmpResFH "$2\t$3\n"; }
          $totalTmpResults++;
        }
      }
    }
    close($tmpReportFH);
    close($tmpResFH);
  }
	if ($totalTmpResults) {
		$winResults->ShellExecute('open', $tmpResults,'','',1);
	} else { Win32::GUI::MessageBox($winResults, $STR{'noResult'} , "XL-Parser $VERSION", 0x40040); }
  
}  #--- End showTmpSOResult

#--------------------------#
sub showTmpFileResult
#--------------------------#
{
  # Local variable
	my $refSelFiles = shift;
  my $nbrSelFiles = scalar(keys %{$refSelFiles});
  # Compile results
  my $tmpReport  = "$REPORTDIR\\.XL-Parser_tmp-"     . $PROCESSID .'.txt';
  my $tmpResults = "$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt';
  my $totalTmpResults = 0;
  if ($tmpReport and -f $tmpReport and open(my $tmpReportFH, $tmpReport) and open(my $tmpResFH, ">$tmpResults")) {
    while (<$tmpReportFH>) {
      if (/^([^\t]+)\t(.+)/) {
        if (exists($$refSelFiles{$1})) {
          if ($nbrSelFiles > 1) { print $tmpResFH $_;     }
          else                  { print $tmpResFH "$2\n"; }
          $totalTmpResults++;
        }
      }
    }
    close($tmpReportFH);
    close($tmpResFH);
    if ($totalTmpResults) {
      $winResults->ShellExecute('open', $tmpResults,'','',1);
    } else { Win32::GUI::MessageBox($winResults, $STR{'noResult'} , "XL-Parser $VERSION", 0x40040); }
  }
  
}  #--- End showTmpFileResult


#--------------------------#
sub showTmpFileResultResOnly
#--------------------------#
{
  # Local variable
	my $refSelFiles = shift;
  my $nbrSelFiles = scalar(keys %{$refSelFiles});
  # Compile results
  my $tmpReport  = "$REPORTDIR\\.XL-Parser_tmp-"     . $PROCESSID .'.txt';
  my $tmpResults = "$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt';
  my $totalTmpResults = 0;
  if ($tmpReport and -f $tmpReport and open(my $tmpReportFH, $tmpReport) and open(my $tmpResFH, ">$tmpResults")) {
    while (<$tmpReportFH>) {
      if (/^([^\t]+)\t([^\t]+)\t(.+)/ or /^([^\t]+)\t(.+)/) {
        if (exists($$refSelFiles{$1})) {
          if ($nbrSelFiles > 1) { print $tmpResFH $_;     }
          else {
						if ($3) { print $tmpResFH "$3\n"; }
						else    { print $tmpResFH "$2\n"; }
					}
          $totalTmpResults++;
        }
      }
    }
    close($tmpReportFH);
    close($tmpResFH);
    if ($totalTmpResults) {
      $winResults->ShellExecute('open', $tmpResults,'','',1);
    } else { Win32::GUI::MessageBox($winResults, $STR{'noResult'} , "XL-Parser $VERSION", 0x40040); }
  }
  
}  #--- End showTmpFileResultResOnly

#--------------------------#
sub showTmpFileResultNoDupl
#--------------------------#
{
  # Local variable
  my $refSelFiles = shift;
  my $nbrSelFiles = scalar(keys %{$refSelFiles});
  my %resByFile;
  # Compile results
  my $tmpReport  = "$REPORTDIR\\.XL-Parser_tmp-"     . $PROCESSID .'.txt';
  my $tmpResults = "$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt';
  my $totalTmpResults = 0;
  # Compile results
  if ($tmpReport and -f $tmpReport and open(my $tmpReportFH, $tmpReport)) {
    while (<$tmpReportFH>) {
      if (/^([^\t]+)\t([^\t]+)\t([^\t]+)/) {
        my $file   = $1;
        my $object = $2;
        my $result = $3;
        chomp($result);
        if (exists($$refSelFiles{$file})) { # Selected file
          if (exists($resByFile{$file}) and exists($resByFile{$file}{$object}) and exists($resByFile{$file}{$object}{$result})) {
            $resByFile{$file}{$object}{$result}++;
          } else { $resByFile{$file}{$object}{$result} = 1; }
          $totalTmpResults++;
        }
      }
    }
    close($tmpReportFH);
    # Print results
    if ($totalTmpResults) {
      if (open(my $tmpResFH, ">$tmpResults")) {
        foreach my $file (keys %resByFile) {
          foreach my $object (keys %{$resByFile{$file}}) {
            foreach my $result (sort {$resByFile{$file}{$object}{$b} <=> $resByFile{$file}{$object}{$a}} keys %{$resByFile{$file}{$object}}) {
              if ($nbrSelFiles > 1) { print $tmpResFH "$file\t$object\t$result\t$resByFile{$file}{$object}{$result}\n"; }
              else                  { print $tmpResFH "$object\t$result\t$resByFile{$file}{$object}{$result}\n";        }
            }
          }
        }
        close($tmpResFH);
      }
      $winResults->ShellExecute('open', $tmpResults,'','',1);
    } else { Win32::GUI::MessageBox($winResults, $STR{'noResult'} , "XL-Parser $VERSION", 0x40040); }
  }
  
}  #--- End showTmpFileResultNoDupl

#--------------------------#
sub showTmpFileResultResOnlyNoDupl
#--------------------------#
{
  # Local variable
  my $refSelFiles = shift;
  my $nbrSelFiles = scalar(keys %{$refSelFiles});
  my %resByFile;
  # Compile results
  my $tmpReport  = "$REPORTDIR\\.XL-Parser_tmp-"     . $PROCESSID .'.txt';
  my $tmpResults = "$REPORTDIR\\.XL-Parser_tmp_res-" . $PROCESSID .'.txt';
  my $totalTmpResults = 0;
  # Compile results
  if ($tmpReport and -f $tmpReport and open(my $tmpReportFH, $tmpReport)) {
    while (<$tmpReportFH>) {
      if (/^([^\t]+)\t([^\t]+)\t([^\t]+)/) {
        my $file   = $1;
        my $object = $2;
        my $result = $3;
        chomp($result);
        if (exists($$refSelFiles{$file})) { # Selected file
          if (exists($resByFile{$file}) and exists($resByFile{$file}{$object}) and exists($resByFile{$file}{$object}{$result})) {
            $resByFile{$file}{$object}{$result}++;
          } else { $resByFile{$file}{$object}{$result} = 1; }
          $totalTmpResults++;
        }
      }
    }
    close($tmpReportFH);
    # Print results
    if ($totalTmpResults) {
      if (open(my $tmpResFH, ">$tmpResults")) {
        foreach my $file (keys %resByFile) {
          foreach my $object (keys %{$resByFile{$file}}) {
            foreach my $result (sort {$resByFile{$file}{$object}{$b} <=> $resByFile{$file}{$object}{$a}} keys %{$resByFile{$file}{$object}}) {
              print $tmpResFH "$result\n";
            }
          }
        }
        close($tmpResFH);
      }
      $winResults->ShellExecute('open', $tmpResults,'','',1);
    } else { Win32::GUI::MessageBox($winResults, $STR{'noResult'} , "XL-Parser $VERSION", 0x40040); }
  }
  
}  #--- End showTmpFileResultResOnlyNoDupl

#--------------------------#
sub btnSaveResultsExtract_Click
#--------------------------#
{
  if (my $resFile = Win32::GUI::GetSaveFileName(-owner     => $winResults,
                                                -title     => $STR{'selFile'}.':',
                                                -filter    => ["JSON files (*.json)", '*.json'],
                                                -directory => $REPORTDIR,
                                                -overwriteprompt => 1,
                                                -explorer  => 1)) {
    $THR = threads->create(sub {
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        $winResults->lblCurr->Text('');
        $winResults->lblCount->Text('');
        $winResults->pb->Hide();
        $winResults->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winResults, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      # Progress
      $winResults->pb->Show();
      $winResults->pb->SetRange(0, 2);
      $winResults->pb->SetPos(0);
      $winResults->pb->SetStep(1);
      $winResults->lblCount->Text('0 / 2');
      $winResults->ChangeCursor($HOURGLASS);
      # Load results
      $winResults->lblCurr->Text($STR{'LoadingResults'}.'...');
      $resFile .= '.json' if $resFile !~ /\.json$/;
      my ($refResults, $refSearchParams);
      if (open(my $json, "$REPORTDIR\\CurrentExtractResults-" . $PROCESSID .'.json')) {
        my $jsonText = <$json>;
        close($json);
        my $jsonObj = JSON->new;
        $refResults = $jsonObj->decode($jsonText);
      }
      # Load params
      my $extractParamsFilename = $REPORTDIR;
      if    ($PROCESSNAME eq 'Extract-Expr') { $extractParamsFilename .= "\\ExtractExprParams-" . $PROCESSID .'.json'; }
      elsif ($PROCESSNAME eq 'Extract-SO'  ) { $extractParamsFilename .= "\\ExtractSOParams-"   . $PROCESSID .'.json'; }
      if (open(my $json, $extractParamsFilename)) {
        my $jsonText = <$json>;
        close($json);
        my $jsonObj = JSON->new;
        $refSearchParams = $jsonObj->decode($jsonText);
        $$refSearchParams{procID} = $PROCESSID;
      }
      $winResults->lblCount->Text('1 / 2');
      $winResults->pb->StepIt();
      # Saved Results to JSON files
      $winResults->lblCurr->Text($STR{'SavingResults'}.'...');
      my %mergedHash  = (%$refSearchParams, %$refResults);
      if (open(my $json, '>:encoding(cp1252)', $resFile)) {
        my $jsonObj = JSON->new;
        my $jsonText = $jsonObj->encode(\%mergedHash);
        print $json $jsonText;
        close($json);
      }
      # Saved temp results
      my $tmpResult1 = "$REPORTDIR\\.XL-Parser_tmp-"  . $PROCESSID .'.txt';
      my $tmpResult2 = "$REPORTDIR\\.XL-Parser_tmp2-" . $PROCESSID .'.txt';
      my $resFilename;
      if ($resFile =~ /(.+?)\.json$/) {
        $resFilename = $1;
        if (-f $tmpResult1 and Win32::CopyFile($tmpResult1, $resFilename . ".XL-Parser_tmp.txt", 1)) {
          $winResults->lblCount->Text('2 / 2');
          $winResults->pb->StepIt();
          $winResults->ChangeCursor($ARROW);
          if ($PROCESSNAME eq 'Extract-SO') {
            if (-f $tmpResult2 and Win32::CopyFile($tmpResult2, $resFilename . ".XL-Parser_tmp2.txt", 1)) {
              Win32::GUI::MessageBox($winResults, "$STR{'ResultsSaved'}!", "XL-Parser $VERSION", 0x40040);
            }
          } else { Win32::GUI::MessageBox($winResults, "$STR{'ResultsSaved'}!", "XL-Parser $VERSION", 0x40040); }
        }
      } else {
        $winResults->lblCount->Text('2 / 2');
        $winResults->pb->StepIt();
        $winResults->ChangeCursor($ARROW);
      }
      # Progress
      $winResults->lblCurr->Text('');
      $winResults->lblCount->Text('');
      $winResults->pb->Hide();
    });
  }
  return(1);
  
}  #--- End btnSaveResultsExtract_Click
  
#--------------------------#
sub btnWinReport_Click
#--------------------------#
{
  # Create window
  &createWinReport() if !$winReport;
  my $nbrExprObj = $winResults->gridResExpr->GetRows();
  $winReport->tfReportDir->Text($REPORTDIR);
  $winReport->chReportOptIncSource->Show();
  $winReport->chReportOptIncExpr->Show();
  $winReport->chReportOptSeparateReports->Show();
  $winReport->chReportOptIncISP->Hide();
  $winReport->chReportOptIncGeoIP->Hide();
  $winReport->chReportOptIncUADetails->Hide();
  $winReport->chReportOptIncWeekday->Hide();
  $winReport->lblOutputDTFormat->Hide();
  $winReport->cbOutputDTFormat->Hide();
  $winReport->btnOutputFormatDTDB->Hide();
  $winReport->lblReportCaller->Text(0);
  $winReport->btnReportGo->Text($STR{'Go'}.' >>');
  # By Expression
  if ($winResults->rbResByExpr->Text() eq $STR{'rbResByExpr'}) {
    $winReport->cbReportFormat->SetCurSel(2); # Default report format is TXT
    &cbReportFormat_Change;
    $winReport->chReportOptIncSource->Enable();
    $winReport->chReportOptIncExpr->Text($STR{'Expression'});
    if ($nbrExprObj < 3) { $winReport->chReportOptSeparateReports->Hide(); } # Only one expression
    else                 { $winReport->chReportOptSeparateReports->Show(); }
  # By Special object
  } else {
    my $nbrObjects;
    $winReport->cbReportFormat->SetCurSel(0); # Default report format is XLSX
    &cbReportFormat_Change;
    $winReport->chReportOptIncSource->Disable();
    $winReport->chReportOptIncExpr->Text($STR{'Object'});
    if ($nbrExprObj < 3) { $winReport->chReportOptSeparateReports->Hide(); } # Only one object
    else                 { $winReport->chReportOptSeparateReports->Show(); }
  }
  # Enable Go button ?
  my $tmpReport = "$REPORTDIR\\.XL-Parser_tmp-" . $PROCESSID .'.txt';
  if ($tmpReport and -f $tmpReport and $winResults->lblResStatsResultsVal->Text()) {
    $winReport->btnReportGo->Enable();
  } else { $winReport->btnReportGo->Disable(); }
  # Show window
  $winReport->Center($winResults);
  $winReport->Show();
  
}  #--- End btnWinReport_Click

#--------------------------#
sub tfReportDir_Change
#--------------------------#
{
  # Local variables
  my $saveDir = $winReport->tfReportDir->Text();
  if ($saveDir and -d $saveDir) { $winReport->btnReportGo->Enable(); }
  else { # Invalid dir or no dir
    $winReport->btnReportGo->Disable();
    if ($saveDir) {
      $winReport->tfReportDir->Text('');
      Win32::GUI::MessageBox($winReport, $STR{'invalidDir'}, $STR{'error'}, 0x40010);
    }
  }

}  #--- End tfReportDir_Change

#--------------------------#
sub cbReportFormat_Change
#--------------------------#
{
  # Local variables
  my $format = $winReport->cbReportFormat->GetCurSel();
  # Possible values are: 0 = XLSX, 1 = HTML, 2 = TXT (TSV)
  if ($winResults->rbResByExpr->Text() eq $STR{'rbResByExpr'}) { # By Expression
    if    (!$format    ) { $winReport->chReportOptSeparateReports->Text($STR{'chReportOptSeparateSheetsExpr'});  }
    elsif ($format == 1) { $winReport->chReportOptSeparateReports->Text($STR{'chReportOptSeparatePagesExpr'});   }
    else                 { $winReport->chReportOptSeparateReports->Text($STR{'chReportOptSeparateReportsExpr'}); }
  } else { # By Special objects
    if    (!$format    ) { $winReport->chReportOptSeparateReports->Text($STR{'chReportOptSeparateSheetsObject'});  }
    elsif ($format == 1) { $winReport->chReportOptSeparateReports->Text($STR{'chReportOptSeparatePagesObject'});   }
    else                 { $winReport->chReportOptSeparateReports->Text($STR{'chReportOptSeparateReportsObject'}); }
  }
  
}  #--- End cbReportFormat_Change
  
#--------------------------#
sub btnReportDir_Click
#--------------------------#
{
  # Local variables
  my $lastDir = $winReport->tfReportDir->Text();
  my $dir;
  # Show BrowseForFolder dialog window
  if ($lastDir) {
    my(@parts) = split(/\\/, $lastDir);
    if (pop(@parts) =~ /\./) {
      while ($lastDir =~ /[^\\]$/) { chop($lastDir); }
    }
    $dir = Win32::GUI::BrowseForFolder( -owner      => $winReport          ,
                                        -title      => $STR{'btnReportDirTip'},
                                        -folderonly => 1                      ,
                                        -directory  => $lastDir               ,
                                        -newui      => 1                      , );
  } else {
    $dir = Win32::GUI::BrowseForFolder( -owner      => $winReport          ,
                                        -title      => $STR{'btnReportDirTip'},
                                        -folderonly => 1                      ,
                                        -newui      => 1                      , );
  }
  # Selected folder
  if ($dir and -d $dir) {
    chop($dir) if $dir =~ /\\$/;
    $winReport->tfReportDir->Text($dir);
  }
  return(1);
  
}  #--- End btnReportDir_Click

#--------------------------#
sub btnOpenReportDir_Click
#--------------------------#
{
  # Local variables
  my $outputDir = $winReport->tfReportDir->Text();
  Win32::Process::Create(my $ProcessObj,"$ENV{'WINDIR'}\\explorer.exe", "explorer $outputDir", 0, NORMAL_PRIORITY_CLASS,".") if -d $outputDir;

}  #--- End btnOpenReportDir_Click

#--------------------------#
sub winReport_Terminate
#--------------------------#
{
  $winReport->Hide();
  return(0);
  
}  #--- End winReport_Terminate

#--------------------------#
sub btnReportGo_Click
#--------------------------#
{
  # Avoid new thread
  if ($THR and $THR->is_running()) { Win32::GUI::MessageBox($winResults, $STR{'processRunning'}, $STR{'error'}, 0x40010); }
  else {
    # Local variables
    my $reportDir = $winReport->tfReportDir->Text();
    my $caller    = $winReport->lblReportCaller->Text();
    # Processing if caller is Extraction Results
    if (!$caller) {
      my $tmpReport;
      my $nbrResults;
      if ($winResults->rbResByExpr->Text() eq $STR{'rbResByExpr'}) { $tmpReport = "$REPORTDIR\\.XL-Parser_tmp-"  . $PROCESSID .'.txt';  }
      else                                                         { $tmpReport = "$REPORTDIR\\.XL-Parser_tmp2-" . $PROCESSID .'.txt'; }
      # Use temp report
      if ($tmpReport and -f $tmpReport) {
        $nbrResults = $winResults->lblResStatsResultsVal->Text();
        if ($reportDir and $nbrResults) {
          $THR = threads->create(sub {
            # Thread cancel signal handler
            $SIG{'KILL'} = sub {
              $winResults->pb->SetPos(0);
              $winResults->pb->Hide;
              $winResults->lblCurr->Text('');
              $winResults->lblCount->Text('');
              $winResults->ChangeCursor($ARROW);
              threads->exit();
            };
            # Thread die signal handler
            $SIG{__DIE__} = sub {
              my $errMsg = (split(/ at /, $_[0]))[0];
              $errMsg =~ s/[\t\r\n]/ /g;
              $winResults->pb->SetPos(0);
              $winResults->pb->Hide;
              $winResults->lblCurr->Text('');
              $winResults->lblCount->Text('');
              $winResults->ChangeCursor($ARROW);
              Win32::GUI::MessageBox($winResults, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
              threads->exit();
            };
            # Close Report Window
            $winReport->Hide();
            # Show progress
            $winResults->pb->Show();
            $winResults->pb->SetRange(0, $nbrResults);
            $winResults->pb->SetPos(0);
            $winResults->pb->SetStep(1);
            $winResults->lblCount->Text("0 / $nbrResults");
            $winResults->lblCurr->Text("$STR{'WritingReport'}...");
            $winResults->ChangeCursor($HOURGLASS);
            # Local variables
            my $reportFormat = $winReport->cbReportFormat->GetCurSel(); # Possible values: 0 = XLSX, 1 = HTML, 2 = TXT
            my $refReports;
            # Results of Extraction - Expression
            if ($winResults->rbResByExpr->Text() eq $STR{'rbResByExpr'}) {
              if (!$reportFormat) {
                $refReports = &writeReportExprXLSX($nbrResults, $reportDir, $tmpReport);
              } elsif ($reportFormat == 1) {
                $refReports = &writeReportExprHTML($nbrResults, $reportDir, $tmpReport);
              } else {
                $refReports = &writeReportExprTXT($nbrResults, $reportDir, $tmpReport);
              }
            # Results of Extraction - Special Object
            } else {
              # Gather objects and options
              my %SO;
              for (my $row = 1; $row <= $winResults->gridResExpr->GetRows(); $row++) {
                my $object     = $winResults->gridResExpr->GetCellText($row, 0);
                my $optionsStr = $winResults->gridResExpr->GetCellText($row, 2);
                $SO{$object}{'obj'} = 1;
                if ($optionsStr) {
                  my @opt = split(/,/, $optionsStr);
                  foreach (@opt) { $SO{$object}{'opt'}{$_} = 1; }
                }
              }
              if (!$reportFormat) {
                $refReports = &writeReportSOXLSX(\%SO, $nbrResults, $reportDir, $tmpReport);
              } elsif ($reportFormat == 1) {
                $refReports = &writeReportSOHTML(\%SO, $nbrResults, $reportDir, $tmpReport);
              } else {
                $refReports = &writeReportSOTXT(\%SO, $nbrResults, $reportDir, $tmpReport);
              }
            }
            # Turn off progress bar
            $winResults->pb->SetPos(0);
            $winResults->pb->Hide;
            $winResults->lblCurr->Text('');
            $winResults->lblCount->Text('');
            $winResults->ChangeCursor($ARROW);
            # Open report
            if (scalar(@{$refReports}) < 26) { # Max 25
              foreach (@{$refReports}) { $winResults->ShellExecute('open', $_,'','',1); }
            } elsif ($winReport->chOpenReport->Checked()) {
              # Open folder in Window Explorer
              Win32::Process::Create(my $ProcessObj, "$ENV{'WINDIR'}\\explorer.exe", "explorer $reportDir", 0, NORMAL_PRIORITY_CLASS, ".");
            }
          });
        }
      }
    # Caller is Query or Search Database
    } else { $winReport->Hide(); }
  }
  
}  #--- End btnReportGo_Click

#--------------------------#
sub writeReportExprXLSX
#--------------------------#
{
  # Local variables
  my ($nbrResults, $reportDir, $tmpReport) = @_;
  my $separatedReport = 1 if $winReport->chReportOptSeparateReports->Checked();
  my $incSource       = 1 if $winReport->chReportOptIncSource->Checked();
  my $incExpression   = 1 if $winReport->chReportOptIncExpr->Checked();
  my $replaceReport   = 1 if $winReport->chReplaceReport->Checked();
  my @return;
  if (open(my $tmpReportFH, $tmpReport)) {
    # Single report
    if (!$separatedReport) {
      my $report = "$reportDir\\XL-Parser $STR{'report'}.xlsx";
      # Replace report if exists ?
      if (!$replaceReport) {
        my $i = 1;
        while (-e $report) { $report = "$reportDir\\XL-Parser $STR{'report'} ($i).xlsx"; $i++; }
      }
      # Create an XLSX workbook with a single sheet
      if (my $excel = Excel::Writer::XLSX->new($report)) {
        if (my $sheet = $excel->add_worksheet($STR{'Results'})) {
          my @maxColWidth;
          my $i = 0;
          # Headers
          if ($winReport->chReportOptIncHeaders->Checked()) {
            my $formatHeader = $excel->add_format();
            $formatHeader->set_bold();
            $formatHeader->set_align('center');
            $formatHeader->set_align('vcenter');
            my $j = 0; # Column no
            if ($incSource)     { # Include Source
              $sheet->write(0, $j, $STR{'chReportOptIncSource'}, $formatHeader );
              push(@maxColWidth, length($STR{'chReportOptIncSource'}));
              $j++;
            } 
            if ($incExpression) { # Include Expression
              $sheet->write(0, $j, $STR{'Expression'}, $formatHeader );
              push(@maxColWidth, length($STR{'Expression'}));
              $j++;
            }
            # Results
            $sheet->write(0, $j, $STR{'Results'} , $formatHeader );
            push(@maxColWidth, length($STR{'Results'}));
            $j++;
            $i = 1;
          }
          while (<$tmpReportFH>) {
            my $j = 0; # Column no
            my @fields     = split(/\t/, $_);
            my $source     = shift(@fields);
            my $expression = shift(@fields);
            if ($incSource    ) { # Add source
              $sheet->write_string($i, $j, $source);
              my $length = length($source);
              $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]);
              $j++;
            } 
            if ($incExpression) { # Add Expression
              $sheet->write_string($i, $j, $expression);
              my $length = length($expression);
              $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]);
              $j++;
            } 
            foreach (@fields) { # Add results
              $sheet->write_string($i, $j, $_);
              my $length = length($_);
              if ($maxColWidth[$j]) {
                $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]);
              } else { push(@maxColWidth, $length); }
              $j++;
            }
            # Update progress
            $i++;
            $winResults->lblCount->Text("$i / $nbrResults");
            $winResults->pb->StepIt();
          }
          # Resize colum width
          my $j = 0;
          foreach (@maxColWidth) { $sheet->set_column($j, $j, $_); $j++; }
          $excel->close(); # Close the file
          push(@return, $report);
        }
      }
    # One sheet per expression
    } else {
      my %sheets;
      # Select or create a new filehandle
      my $report = "$reportDir\\XL-Parser $STR{'report'}.xlsx";
      # Replace report if exists ?
      if (!$replaceReport) {
        my $i = 1;
        while (-e $report) { $report = "$reportDir\\XL-Parser $STR{'report'} ($i).xlsx"; $i++; }
      }
      if (my $excel = Excel::Writer::XLSX->new($report)) { # Open a new report
        my $count = 0;
        my $no    = 1;
        while (<$tmpReportFH>) {
          my @fields     = split(/\t/, $_);
          my $source     = shift(@fields);
          my $expression = shift(@fields);
          my $sheetName;
          my $curSheet;
          if ($expression =~ /[\\\/\*\[\]\:\?]/ or length($expression) > 31) { $sheetName = "Expr_$no"; $no++; }
          else { $sheetName = $expression; }
          # Select sheet if already open
          if (exists($sheets{$sheetName}) and exists($sheets{$sheetName}{handle})) { $curSheet = $sheets{$sheetName}{handle}; }
          # Else, create a new sheet
          elsif ($curSheet = $excel->add_worksheet($sheetName)) {
            $sheets{$sheetName}{handle}         = $curSheet;
            $sheets{$sheetName}{curRow}         = 0;
            @{$sheets{$sheetName}{maxColWidth}} = ();
            # Headers
            if ($winReport->chReportOptIncHeaders->Checked()) {
              # Headers
              my $formatHeader = $excel->add_format();
              $formatHeader->set_bold();
              $formatHeader->set_align('center');
              $formatHeader->set_align('vcenter');
              my $j = 0; # Column no
              if ($incSource)     { # Include Source
                $curSheet->write(0, $j, $STR{'chReportOptIncSource'}, $formatHeader );
                push(@{$sheets{$sheetName}{maxColWidth}}, length($STR{'chReportOptIncSource'}));
                $j++;
              } 
              if ($incExpression) { # Include Expression
                $curSheet->write(0, $j, $STR{'Expression'}, $formatHeader );
                push(@{$sheets{$sheetName}{maxColWidth}}, length($STR{'Expression'}));
                $j++;
              }
              # Results
              $curSheet->write(0, $j, $STR{'Results'} , $formatHeader );
              push(@{$sheets{$sheetName}{maxColWidth}}, length($STR{'Results'}));
              $j++;
              $sheets{$sheetName}{curRow}++;
            }
          }
          if ($curSheet) {
            my $j = 0; # Column no
            my @fields     = split(/\t/, $_);
            my $source     = shift(@fields);
            my $expression = shift(@fields);
            if ($incSource) { # Add source
              $curSheet->write_string($sheets{$sheetName}{curRow}, $j, $source);
              my $length = length($source);
              $sheets{$sheetName}{maxColWidth}[$j] = $length if ($length > $sheets{$sheetName}{maxColWidth}[$j]);
              $j++;
            } 
            if ($incExpression) { # Add Expression
              $curSheet->write_string($sheets{$sheetName}{'curRow'}, $j, $expression);
              my $length = length($expression);
              $sheets{$sheetName}{maxColWidth}[$j] = $length if ($length > $sheets{$sheetName}{maxColWidth}[$j]);
              $j++;
            } 
            foreach (@fields) { # Add results
              $curSheet->write_string($sheets{$sheetName}{curRow}, $j, $_);
              my $length = length($_);
              if ($sheets{$sheetName}{maxColWidth}[$j]) {
                $sheets{$sheetName}{maxColWidth}[$j] = $length if ($length > $sheets{$sheetName}{maxColWidth}[$j]);
              } else { push(@{$sheets{$sheetName}{maxColWidth}}, $length); }
              $j++;
            }
            $sheets{$sheetName}{curRow}++;
          }
          # Update progress
          $count++;
          $winResults->lblCount->Text("$count / $nbrResults");
          $winResults->pb->StepIt();
        }
        # Resize columns in each sheet
        for my $sheet ($excel->sheets()) {
          my $j = 0;
          my $sheetName = $sheet->get_name();
          if (exists($sheets{$sheetName}) and @{$sheets{$sheetName}{maxColWidth}}) {
            foreach (@{$sheets{$sheetName}{maxColWidth}}) { $sheet->set_column($j, $j, $_); $j++; }
          }
        }
        $excel->close(); # Close the file
        push(@return, $report);
      }
    }
    close($tmpReportFH);
  }
  return(\@return);

}  #--- End writeReportExprXLSX

#--------------------------#
sub writeReportExprHTML
#--------------------------#
{
  # Local variables
  my ($nbrResults, $reportDir, $tmpReport) = @_;
  my $separatedReport = 1 if $winReport->chReportOptSeparateReports->Checked();
  my $incSource       = 1 if $winReport->chReportOptIncSource->Checked();
  my $incExpression   = 1 if $winReport->chReportOptIncExpr->Checked();
  my $replaceReport   = 1 if $winReport->chReplaceReport->Checked();
  my @return;
  if (open(my $tmpReportFH, $tmpReport)) {
    # Single report
    if (!$separatedReport) {
      my $report = "$reportDir\\XL-Parser $STR{'report'}.html";
      # Replace report if exists ?
      if (!$replaceReport and -e $report) {
        my $i = 1;
        while (-e $report) { $report = "$reportDir\\XL-Parser $STR{'report'} ($i).html"; $i++; }
      }
      # Open 
      if (open(my $fhReport, '>', $report)) {
        my $count = 0;
        my @headers;
        # Headers
        if ($winReport->chReportOptIncHeaders->Checked()) {
          push(@headers, $STR{'chReportOptIncSource'}) if $incSource;
          push(@headers, $STR{'Expression'})           if $incExpression;
          push(@headers, $STR{'Results'});
        }
        &createReportHTML($fhReport, \@headers);
        while (<$tmpReportFH>) {
          print $fhReport "<tr>";
          my @fields = split(/\t/, $_);
          my $source     = shift(@fields);
          my $expression = shift(@fields);
          print $fhReport "<td>$source</td>"     if $incSource;
          print $fhReport "<td>$expression</td>" if $incExpression;
          foreach (@fields) {
            s/</&lt;/g;
            s/>/&gt;/g;
            print $fhReport "<td>$_</td>";
          }
          print $fhReport "</tr>\n";
          # Update progress
          $count++;
          $winResults->lblCount->Text("$count / $nbrResults");
          $winResults->pb->StepIt();
        }
        print $fhReport "</table>\n</body>\n</html>\n";
        close($fhReport);
        push(@return, $report);
      }
    # One page per expression
    } else {
      my %fhReports;
      my $count = 0;
      while (<$tmpReportFH>) {
        my @fields = split(/\t/, $_);
        my $source     = shift(@fields);
        my $expression = shift(@fields);
        my $reportName;
        my $fhReport;
        my $no = 1;
        # Select or create a new filehandle
        if ($expression =~ /[\<\>\:\"\/\\\|\?\*]/) { $reportName = "XL-Parser $STR{'report'} - Expr_$no"; $no++; }
        else {
          $reportName = "XL-Parser $STR{'report'} - $expression";
          if (length("$reportDir\\$reportName") > 256) { # Path is too long
            $reportName = "XL-Parser $STR{'report'} - Expr_$no";
            $no++;
          }
        }
        my $report = "$reportDir\\$reportName.html";
        # Replace report if exists ?
        if (!$replaceReport and -e $report) {
          my $i = 1;
          while (-e $report) { $report = "$reportDir\\$reportName ($i).html"; $i++; }
        }
        if (exists($fhReports{$expression})) { # Already open
          $fhReport = $fhReports{$expression};
        } elsif (open(my $fh, '>', $report)) { # Open a new report
          $fhReport = $fh;
          $fhReports{$expression} = $fh;
          push(@return, $report);
          my @headers;
          # Headers
          if ($winReport->chReportOptIncHeaders->Checked()) {
            push(@headers, $STR{'chReportOptIncSource'}) if $incSource;
            push(@headers, $STR{'Expression'})           if $incExpression;
            push(@headers, $STR{'Results'});
          }
          &createReportHTML($fhReport, \@headers);
        }
        if ($fhReport) {
          print $fhReport "<tr>";
          print $fhReport "<td>$source</td>"     if $incSource;
          print $fhReport "<td>$expression</td>" if $incExpression;
          foreach (@fields) {
            s/</&lt;/g;
            s/>/&gt;/g;
            print $fhReport "<td>$_</td>";
          }
          print $fhReport "</tr>\n";
        }
        # Update progress
        $count++;
        $winResults->lblCount->Text("$count / $nbrResults");
        $winResults->pb->StepIt();
      }
      # Close all filehandles
      foreach (values %fhReports) {
        print $_ "</table>\n</body>\n</html>\n";
        close($_);
      }
    }
    close($tmpReportFH);
  }
  return(\@return);

}  #--- End writeReportExprHTML

#--------------------------#
sub writeReportExprTXT
#--------------------------#
{
  # Local variables
  my ($nbrResults, $reportDir, $tmpReport) = @_;
  my $separatedReport = 1 if $winReport->chReportOptSeparateReports->Checked();
  my $incSource       = 1 if $winReport->chReportOptIncSource->Checked();
  my $incExpression   = 1 if $winReport->chReportOptIncExpr->Checked();
  my $replaceReport   = 1 if $winReport->chReplaceReport->Checked();
  my @return;
  if (open(my $tmpReportFH, $tmpReport)) {
    # Single report
    if (!$separatedReport) {
      my $report = "$reportDir\\XL-Parser $STR{'report'}.txt";
      # Replace report if exists ?
      if (!$replaceReport and -e $report) {
        my $i = 1;
        while (-e $report) { $report = "$reportDir\\XL-Parser $STR{'report'} ($i).txt"; $i++; }
      }
      # Open 
      if (open(my $fhReport, '>', $report)) {
        my $count = 0;
        # Headers
        if ($winReport->chReportOptIncHeaders->Checked()) {
          my $headers;
          $headers .= "$STR{'chReportOptIncSource'}\t" if $incSource;
          $headers .= "$STR{'Expression'}\t"           if $incExpression;
          $headers .= "$STR{'Results'}\n";
          print $fhReport $headers;
        }
        while (<$tmpReportFH>) {
          my @fields = split(/\t/, $_);
          my $source     = shift(@fields);
          my $expression = shift(@fields);
          my $newLine;
          $newLine .= "$source\t"     if $incSource;
          $newLine .= "$expression\t" if $incExpression;
          $newLine .= join("\t", @fields);
          print $fhReport $newLine;
          # Update progress
          $count++;
          $winResults->lblCount->Text("$count / $nbrResults");
          $winResults->pb->StepIt();
        }        
        close($fhReport);
        push(@return, $report);
      }
    # One report per expression
    } else {
      my %fhReports;
      my $count = 0;
      while (<$tmpReportFH>) {
        my @fields     = split(/\t/, $_);
        my $source     = shift(@fields);
        my $expression = shift(@fields);
        my $reportName;
        my $fhReport;
        my $no = 1;
        # Select or create a new filehandle
        if ($expression =~ /[\<\>\:\"\/\\\|\?\*]/) { $reportName = "XL-Parser $STR{'report'} - Expr_$no"; $no++; }
        else {
          $reportName = "XL-Parser $STR{'report'} - $expression";
          if (length("$reportDir\\$reportName") > 256) { # Path is too long
            $reportName = "XL-Parser $STR{'report'} - Expr_$no";
            $no++;
          }
        }
        my $report = "$reportDir\\$reportName.txt";
        # Replace report if exists ?
        if (!$replaceReport and -e $report) {
          my $i = 1;
          while (-e $report) { $report = "$reportDir\\$reportName ($i).txt"; $i++; }
        }
        if (exists($fhReports{$expression})) { # Already open
          $fhReport = $fhReports{$expression};
        } elsif (open(my $fh, '>', $report)) { # Open a new report
          $fhReport = $fh;
          $fhReports{$expression} = $fh;
          push(@return, $report);
          # Headers
          if ($winReport->chReportOptIncHeaders->Checked()) {
            my $headers;
            $headers .= "$STR{'chReportOptIncSource'}\t" if $incSource;
            $headers .= "$STR{'Expression'}\t"           if $incExpression;
            $headers .= "$STR{'Results'}\n";
            print $fhReport $headers;
          }
        }
        if ($fhReport) {
          my $newLine;
          $newLine .= "$source\t"     if $incSource;
          $newLine .= "$expression\t" if $incExpression;
          $newLine .= join("\t", @fields);
          print $fhReport $newLine;
        }
        # Update progress
        $count++;
        $winResults->lblCount->Text("$count / $nbrResults");
        $winResults->pb->StepIt();
      }
      # Close all filehandles
      foreach (values %fhReports) { close($_); }
    }
    close($tmpReportFH);
  }
  return(\@return);

}  #--- End writeReportExprTXT

#--------------------------#
sub writeReportSOXLSX
#--------------------------#
{
  # Local variables
  my ($refSO, $nbrResults, $reportDir, $tmpReport) = @_;
  my $separatedReport = 1 if $winReport->chReportOptSeparateReports->Checked();
  my $incSO           = 1 if $winReport->chReportOptIncExpr->Checked();
  my $replaceReport   = 1 if $winReport->chReplaceReport->Checked();
  my @return;
  if (open(my $tmpReportFH, $tmpReport)) {
    # Check existing options data
    my $NSLookup         = 0;
    my $ResolveTLD       = 0;
    my $IPAddr_XLWhoisDB = 0;
    my $ResolveGeoIP     = 0;
    my $MACAddr_ResOUI   = 0;
    my $CC_ResIC         = 0;
    foreach my $object (keys %{$refSO}) {
      if (exists($$refSO{$object}{opt})) {
        $NSLookup         = 1 if exists($$refSO{$object}{opt}{$STR{'SO_NSLookup'}})         and !$NSLookup;
        $ResolveTLD       = 1 if exists($$refSO{$object}{opt}{$STR{'SO_ResolveTLD'}})       and !$ResolveTLD;
        $IPAddr_XLWhoisDB = 1 if exists($$refSO{$object}{opt}{$STR{'SO_IPAddr_XLWhoisDB'}}) and !$IPAddr_XLWhoisDB;
        $ResolveGeoIP     = 1 if exists($$refSO{$object}{opt}{$STR{'SO_GeoIP'}})            and !$ResolveGeoIP;
        $MACAddr_ResOUI   = 1 if exists($$refSO{$object}{opt}{$STR{'SO_MACAddr_ResOUI'}})   and !$MACAddr_ResOUI;
        $CC_ResIC         = 1 if exists($$refSO{$object}{opt}{$STR{'SO_CC_ResIC'}})         and !$CC_ResIC;
      }
    }
    # Keep order of options
    my $col = 2;
    $NSLookup         = $col++ if $NSLookup;
    $ResolveTLD       = $col++ if $ResolveTLD;
    $IPAddr_XLWhoisDB = $col++ if $IPAddr_XLWhoisDB;
    $ResolveGeoIP     = $col++ if $ResolveGeoIP;
    $MACAddr_ResOUI   = $col++ if $MACAddr_ResOUI;
    $CC_ResIC         = $col++ if $CC_ResIC;
    # Single report
    if (!$separatedReport) {
      my $report = "$reportDir\\XL-Parser $STR{'report'}.xlsx";
      # Replace report if exists ?
      if (!$replaceReport) {
        my $i = 1;
        while (-e $report) { $report = "$reportDir\\XL-Parser $STR{'report'} ($i).xlsx"; $i++; }
      }
      # Create an XLSX workbook with a single sheet
      if (my $excel = Excel::Writer::XLSX->new($report)) {
        if (my $sheet = $excel->add_worksheet($STR{'Results'})) {
          my @maxColWidth;
          my $count = 0;
          my $i     = 0;
          # Headers
          if ($winReport->chReportOptIncHeaders->Checked()) {
            my $formatHeader = $excel->add_format();
            $formatHeader->set_bold();
            $formatHeader->set_align('center');
            $formatHeader->set_align('vcenter');
            my $j = 0; # Column no
            if ($incSO) { # Include special object
              $sheet->write(0, $j, $STR{'Object'}, $formatHeader );
              push(@maxColWidth, length($STR{'Object'}));
              $j++;
            }
            # Results
            $sheet->write(0, $j, $STR{'Results'} , $formatHeader );
            push(@maxColWidth, length($STR{'Results'}));
            $j++;
            # Number of Results
            $sheet->write(0, $j, $STR{'Count'} , $formatHeader );
            push(@maxColWidth, 10);
            $j++;
            # Options
            if ($NSLookup) {
              $sheet->write(0, $j, $STR{'SO_NSLookup'} , $formatHeader );
              push(@maxColWidth, length($STR{'SO_NSLookup'}));
              $j++;
            }
            if ($ResolveTLD) {
              $sheet->write(0, $j, $STR{'SO_ResolveTLD'} , $formatHeader );
              push(@maxColWidth, length($STR{'SO_ResolveTLD'}));
              $j++;
            }
            if ($IPAddr_XLWhoisDB) {
              $sheet->write(0, $j, $STR{'SO_IPAddr_XLWhoisDB'} , $formatHeader );
              push(@maxColWidth, length($STR{'SO_IPAddr_XLWhoisDB'}));
              $j++;
            }
            if ($ResolveGeoIP) {
              $sheet->write(0, $j, $STR{'SO_GeoIP'} , $formatHeader );
              push(@maxColWidth, length($STR{'SO_GeoIP'}));
              $j++;
            }
            if ($MACAddr_ResOUI) {
              $sheet->write(0, $j, $STR{'SO_MACAddr_ResOUI'} , $formatHeader );
              push(@maxColWidth, length($STR{'SO_MACAddr_ResOUI'}));
              $j++;
            }
            if ($CC_ResIC) {
              $sheet->write(0, $j, $STR{'SO_CC_ResIC'} , $formatHeader );
              push(@maxColWidth, length($STR{'SO_CC_ResIC'}));
              $j++;
            }
            $i = 1;
          }
          while (<$tmpReportFH>) {
            my $j = 0; # Column no
            my @fields = split(/\t/, $_);
            my $object = shift(@fields);
            my $result = shift(@fields);
            my $nbrRes = shift(@fields);
            if ($incSO) {
              $sheet->write_string($i, $j, $object);
              my $length = length($object);
              $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]);
              $j++;
            }
            $sheet->write_string($i, $j, $result);
            my $length = length($result);
            $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]);
            $j++;
            $sheet->write_number($i, $j, $nbrRes);
            $length = length($nbrRes);
            $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]);
            $j++;
            # Add other fields
            foreach (@fields) {
              $sheet->write_string($i, $j, $_);
              my $length = length($_);
              if ($maxColWidth[$j]) { $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]); }
              else { push(@maxColWidth, $length); }
              $j++;
            }
            $i++;
            # Update progress
            $count += $nbrRes;
            $winResults->lblCount->Text("$count / $nbrResults");
            $winResults->pb->SetStep($nbrRes);
            $winResults->pb->StepIt();
          }
          # Resize colum width
          my $j = 0;
          foreach (@maxColWidth) { $sheet->set_column($j, $j, $_); $j++; }
          # Set autofilter
          $sheet->autofilter(0, 0, 0, --$j) if $winReport->chReportOptIncHeaders->Checked();
          $sheet->freeze_panes(1, 0);
          $excel->close(); # Close the file
          push(@return, $report);
        }
      }
    # One sheet per object
    } else {
      my %sheets;
      # Select or create a new filehandle
      my $report = "$reportDir\\XL-Parser $STR{'report'}.xlsx";
      # Replace report if exists ?
      if (!$replaceReport) {
        my $i = 1;
        while (-e $report) { $report = "$reportDir\\XL-Parser $STR{'report'} ($i).xlsx"; $i++; }
      }
      if (my $excel = Excel::Writer::XLSX->new($report)) { # Open a new report
        my $count = 0;
        while (<$tmpReportFH>) {
          my @fields = split(/\t/, $_);
          my $object = shift(@fields);
          my $curSheet;
          # Select sheet if already open
          if (exists($sheets{$object}) and exists($sheets{$object}{handle})) { $curSheet = $sheets{$object}{handle}; }
          # Else, create a new sheet
          elsif ($curSheet = $excel->add_worksheet($object)) {
            $sheets{$object}{handle}         = $curSheet;
            $sheets{$object}{curRow}         = 0;
            @{$sheets{$object}{maxColWidth}} = ();
            # Headers
            if ($winReport->chReportOptIncHeaders->Checked()) {
              # Headers
              my $formatHeader = $excel->add_format();
              $formatHeader->set_bold();
              $formatHeader->set_align('center');
              $formatHeader->set_align('vcenter');
              my $j = 0; # Column no
              # Results
              $curSheet->write(0, $j, $STR{'Results'} , $formatHeader);
              push(@{$sheets{$object}{maxColWidth}}, length($STR{'Results'}));
              $j++;
              # Number of Results
              $curSheet->write(0, $j, $STR{'Count'} , $formatHeader);
              push(@{$sheets{$object}{maxColWidth}}, 10);
              $j++;
              # Options
              if (exists($$refSO{$object}{'opt'}{$STR{'SO_NSLookup'}})) {
                $curSheet->write(0, $j, $STR{'SO_NSLookup'} , $formatHeader);
                push(@{$sheets{$object}{maxColWidth}}, length($STR{'SO_NSLookup'}));
                $j++;
              }
              if (exists($$refSO{$object}{opt}{$STR{'SO_ResolveTLD'}})) {
                $curSheet->write(0, $j, $STR{'SO_ResolveTLD'} , $formatHeader);
                push(@{$sheets{$object}{maxColWidth}}, length($STR{'SO_ResolveTLD'}));
                $j++;
              }
              if (exists($$refSO{$object}{opt}{$STR{'SO_IPAddr_XLWhoisDB'}})) {
                $curSheet->write(0, $j, $STR{'SO_IPAddr_XLWhoisDB'} , $formatHeader);
                push(@{$sheets{$object}{maxColWidth}}, length($STR{'SO_IPAddr_XLWhoisDB'}));
                $j++;
              }
              if (exists($$refSO{$object}{opt}{$STR{'SO_GeoIP'}})) {
                $curSheet->write(0, $j, $STR{'SO_GeoIP'} , $formatHeader);
                push(@{$sheets{$object}{maxColWidth}}, length($STR{'SO_GeoIP'}));
                $j++;
              }
              if (exists($$refSO{$object}{opt}{$STR{'SO_MACAddr_ResOUI'}})) {
                $curSheet->write(0, $j, $STR{'SO_MACAddr_ResOUI'} , $formatHeader);
                push(@{$sheets{$object}{maxColWidth}}, length($STR{'SO_MACAddr_ResOUI'}));
                $j++;
              }
              if (exists($$refSO{$object}{opt}{$STR{'SO_CC_ResIC'}})) {
                $curSheet->write(0, $j, $STR{'SO_CC_ResIC'} , $formatHeader);
                push(@{$sheets{$object}{maxColWidth}}, length($STR{'SO_CC_ResIC'}));
                $j++;
              }
              $sheets{$object}{curRow}++;
            }
          }
          if ($curSheet) {
            chomp($_);
            my @fields = split(/\t/, $_);
            shift(@fields); # Remove object
            # Result
            $curSheet->write_string($sheets{$object}{curRow}, 0, $fields[0]);
            my $length = length($fields[0]);
            if ($sheets{$object}{maxColWidth}[0]) {
              $sheets{$object}{maxColWidth}[0] = $length if ($length > $sheets{$object}{maxColWidth}[0]);
            } else { push(@{$sheets{$object}{maxColWidth}}, $length); }
            # Number of result
            $curSheet->write_number($sheets{$object}{curRow}, 1, $fields[1]);
            # Options
            my $col = 2;
            for (my $j = 2; $j < scalar(@fields); $j++) { # Add results
              if ($fields[$j] eq '-') { # Options
                if    ($NSLookup         and $j == $NSLookup         and !exists($$refSO{$object}{opt}{$STR{'SO_NSLookup'}})        ) { next; }
                elsif ($ResolveTLD       and $j == $ResolveTLD       and !exists($$refSO{$object}{opt}{$STR{'SO_ResolveTLD'}})      ) { next; }
                elsif ($IPAddr_XLWhoisDB and $j == $IPAddr_XLWhoisDB and !exists($$refSO{$object}{opt}{$STR{'SO_IPAddr_XLWhoisDB'}})) { next; }
                elsif ($ResolveGeoIP     and $j == $ResolveGeoIP     and !exists($$refSO{$object}{opt}{$STR{'SO_GeoIP'}})           ) { next; }
                elsif ($MACAddr_ResOUI   and $j == $MACAddr_ResOUI   and !exists($$refSO{$object}{opt}{$STR{'SO_MACAddr_ResOUI'}})  ) { next; }
                elsif ($CC_ResIC         and $j == $CC_ResIC         and !exists($$refSO{$object}{opt}{$STR{'SO_CC_ResIC'}})        ) { next; }
              }
              $curSheet->write_string($sheets{$object}{curRow}, $col, $fields[$j]);
              my $length = length($fields[$j]);
              if ($sheets{$object}{maxColWidth}[$col]) {
                $sheets{$object}{maxColWidth}[$col] = $length if ($length > $sheets{$object}{maxColWidth}[$col]);
              } else { push(@{$sheets{$object}{maxColWidth}}, $length); }
              $col++;
            }
            $sheets{$object}{curRow}++;
            # Update progress
            $count += $fields[1];
            $winResults->lblCount->Text("$count / $nbrResults");
            $winResults->pb->SetStep($fields[1]);
            $winResults->pb->StepIt();
          }
        }
        # Resize columns in each sheet
        for my $sheet ($excel->sheets()) {
          my $j = 0;
          my $sheetName = $sheet->get_name();
          if (exists($sheets{$sheetName})) {
            if (@{$sheets{$sheetName}{maxColWidth}}) {
              foreach (@{$sheets{$sheetName}{maxColWidth}}) { $sheet->set_column($j, $j, $_); $j++; }
            }
            # Set autofilter and freeze first row
            if ($winReport->chReportOptIncHeaders->Checked()) {
              $sheet->autofilter(0, 0, 0, --$j);
              $sheet->freeze_panes(1, 0);
            }
          }
        }
        $excel->close(); # Close the file
        push(@return, $report);
      }
    }
    close($tmpReportFH);
  }
  return(\@return);

}  #--- End writeReportSOXLSX

#--------------------------#
sub writeReportSOHTML
#--------------------------#
{
  # Local variables
  my ($refSO, $nbrResults, $reportDir, $tmpReport) = @_;
  my $separatedReport = 1 if $winReport->chReportOptSeparateReports->Checked();
  my $incSO           = 1 if $winReport->chReportOptIncExpr->Checked();
  my $replaceReport   = 1 if $winReport->chReplaceReport->Checked();
  my @return;
  if (open(my $tmpReportFH, $tmpReport)) {
    # Check existing options data
    my $NSLookup         = 0;
    my $ResolveTLD       = 0;
    my $IPAddr_XLWhoisDB = 0;
    my $ResolveGeoIP     = 0;
    my $MACAddr_ResOUI   = 0;
    my $CC_ResIC         = 0;
    foreach my $object (keys %{$refSO}) {
      if (exists($$refSO{$object}{opt})) {
        $NSLookup         = 1 if exists($$refSO{$object}{opt}{$STR{'SO_NSLookup'}})         and !$NSLookup;
        $ResolveTLD       = 1 if exists($$refSO{$object}{opt}{$STR{'SO_ResolveTLD'}})       and !$ResolveTLD;
        $IPAddr_XLWhoisDB = 1 if exists($$refSO{$object}{opt}{$STR{'SO_IPAddr_XLWhoisDB'}}) and !$IPAddr_XLWhoisDB;
        $ResolveGeoIP     = 1 if exists($$refSO{$object}{opt}{$STR{'SO_GeoIP'}})            and !$ResolveGeoIP;
        $MACAddr_ResOUI   = 1 if exists($$refSO{$object}{opt}{$STR{'SO_MACAddr_ResOUI'}})   and !$MACAddr_ResOUI;
        $CC_ResIC         = 1 if exists($$refSO{$object}{opt}{$STR{'SO_CC_ResIC'}})         and !$CC_ResIC;
      }
    }
    # Keep order of options
    my $col = 2;
    $NSLookup         = $col++ if $NSLookup;
    $ResolveTLD       = $col++ if $ResolveTLD;
    $IPAddr_XLWhoisDB = $col++ if $IPAddr_XLWhoisDB;
    $ResolveGeoIP     = $col++ if $ResolveGeoIP;
    $MACAddr_ResOUI   = $col++ if $MACAddr_ResOUI;
    $CC_ResIC         = $col++ if $CC_ResIC;
    # Single report
    if (!$separatedReport) {
      my $report = "$reportDir\\XL-Parser $STR{'report'}.html";
      # Replace report if exists ?
      if (!$replaceReport and -e $report) {
        my $i = 1;
        while (-e $report) { $report = "$reportDir\\XL-Parser $STR{'report'} ($i).html"; $i++; }
      }
      # Open 
      if (open(my $fhReport, '>', $report)) {
        my $count = 0;
        my @headers;
        # Headers
        if ($winReport->chReportOptIncHeaders->Checked()) {
          push(@headers, $STR{'Object'})              if $incSO;
          push(@headers, $STR{'Results'});
          push(@headers, $STR{'Count'});
          # Options
          push(@headers, $STR{'SO_NSLookup'})         if $NSLookup;
          push(@headers, $STR{'SO_ResolveTLD'})       if $ResolveTLD;
          push(@headers, $STR{'SO_IPAddr_XLWhoisDB'}) if $IPAddr_XLWhoisDB;
          push(@headers, $STR{'SO_GeoIP'})            if $ResolveGeoIP;
          push(@headers, $STR{'SO_MACAddr_ResOUI'})   if $MACAddr_ResOUI;
          push(@headers, $STR{'SO_CC_ResIC'})         if $CC_ResIC;
        }
        &createReportHTML($fhReport, \@headers);
        while (<$tmpReportFH>) {
          print $fhReport "<tr>";
          my @fields = split(/\t/, $_);
          print $fhReport "<td>$fields[0]</td>" if $incSO;
          shift(@fields);
          print $fhReport "<td>".shift(@fields)."</td>"; # Result
          my $nbrRes = shift(@fields);
          print $fhReport "<td>$nbrRes</td>";
          # All other fields
          foreach (@fields) { print $fhReport "<td>$_</td>"; }
          print $fhReport "</tr>\n";
          # Update progress
          $count += $nbrRes;
          $winResults->lblCount->Text("$count / $nbrResults");
          $winResults->pb->SetStep($nbrRes);
          $winResults->pb->StepIt();
        }
        print $fhReport "</table>\n</body>\n</html>\n";
        close($fhReport);
        push(@return, $report);
      }
    # One page per object
    } else {
      my %fhReports;
      my $count = 0;
      while (<$tmpReportFH>) {
        chomp($_);
        my @fields     = split(/\t/, $_);
        my $object     = shift(@fields);
        my $reportName = "XL-Parser $STR{'report'} - $object";
        my $report     = "$reportDir\\$reportName.html";
        my $fhReport;
        my $no = 1;
        # Replace report if exists ?
        if (!$replaceReport and -e $report) {
          my $i = 1;
          while (-e $report) { $report = "$reportDir\\$reportName ($i).html"; $i++; }
        }
        if (exists($fhReports{$object})) { # Already open
          $fhReport = $fhReports{$object};
        } elsif (open(my $fh, '>', $report)) { # Open a new report
          $fhReport = $fh;
          $fhReports{$object} = $fh;
          push(@return, $report);
          my @headers;
          # Headers
          if ($winReport->chReportOptIncHeaders->Checked()) {
            push(@headers, $STR{'Results'});
            push(@headers, $STR{'Count'});
            # Options
            push(@headers, $STR{'SO_NSLookup'})         if (exists($$refSO{$object}{opt}{$STR{'SO_NSLookup'}}));
            push(@headers, $STR{'SO_ResolveTLD'})       if (exists($$refSO{$object}{opt}{$STR{'SO_ResolveTLD'}}));
            push(@headers, $STR{'SO_IPAddr_XLWhoisDB'}) if (exists($$refSO{$object}{opt}{$STR{'SO_IPAddr_XLWhoisDB'}}));
            push(@headers, $STR{'SO_GeoIP'})            if (exists($$refSO{$object}{opt}{$STR{'SO_GeoIP'}}));
            push(@headers, $STR{'SO_MACAddr_ResOUI'})   if (exists($$refSO{$object}{opt}{$STR{'SO_MACAddr_ResOUI'}}));
            push(@headers, $STR{'SO_CC_ResIC'})         if (exists($$refSO{$object}{opt}{$STR{'SO_CC_ResIC'}}));
          }
          &createReportHTML($fhReport, \@headers);
        }
        if ($fhReport) {
          print $fhReport "<tr>";
          print $fhReport "<td>$fields[0]</td>"; # Result
          print $fhReport "<td>$fields[1]</td>"; # Number of results
          # Options
          my $col = 2;
          for (my $j = 2; $j < scalar(@fields); $j++) { # Add results
            if ($fields[$j] eq '-') { # Options
              if    ($NSLookup         and $j == $NSLookup         and !exists($$refSO{$object}{opt}{$STR{'SO_NSLookup'}})        ) { next; }
              elsif ($ResolveTLD       and $j == $ResolveTLD       and !exists($$refSO{$object}{opt}{$STR{'SO_ResolveTLD'}})      ) { next; }
              elsif ($IPAddr_XLWhoisDB and $j == $IPAddr_XLWhoisDB and !exists($$refSO{$object}{opt}{$STR{'SO_IPAddr_XLWhoisDB'}})) { next; }
              elsif ($ResolveGeoIP     and $j == $ResolveGeoIP     and !exists($$refSO{$object}{opt}{$STR{'SO_GeoIP'}})           ) { next; }
              elsif ($MACAddr_ResOUI   and $j == $MACAddr_ResOUI   and !exists($$refSO{$object}{opt}{$STR{'SO_MACAddr_ResOUI'}})  ) { next; }
              elsif ($CC_ResIC         and $j == $CC_ResIC         and !exists($$refSO{$object}{opt}{$STR{'SO_CC_ResIC'}})        ) { next; }
            }
            print $fhReport "<td>$fields[$j]</td>";
            $col++;
          }
          print $fhReport "</tr>\n";
        }
        # Update progress
        $count += $fields[1];
        $winResults->lblCount->Text("$count / $nbrResults");
        $winResults->pb->SetStep($fields[1]);
        $winResults->pb->StepIt();
      }
      # Close all filehandles
      foreach (values %fhReports) {
        print $_ "</table>\n</body>\n</html>\n";
        close($_);
      }
    }
    close($tmpReportFH);
  }
  return(\@return);

}  #--- End writeReportSOHTML

#--------------------------#
sub writeReportSOTXT
#--------------------------#
{
  # Local variables
  my ($refSO, $nbrResults, $reportDir, $tmpReport) = @_;
  my $separatedReport = 1 if $winReport->chReportOptSeparateReports->Checked();
  my $incSO           = 1 if $winReport->chReportOptIncExpr->Checked();
  my $replaceReport   = 1 if $winReport->chReplaceReport->Checked();
  my @return;
  if (open(my $tmpReportFH, $tmpReport)) {
    # Check existing options data
    my $NSLookup         = 0;
    my $ResolveTLD       = 0;
    my $IPAddr_XLWhoisDB = 0;
    my $ResolveGeoIP     = 0;
    my $MACAddr_ResOUI   = 0;
    my $CC_ResIC         = 0;
    foreach my $object (keys %{$refSO}) {
      if (exists($$refSO{$object}{opt})) {
        $NSLookup         = 1 if exists($$refSO{$object}{opt}{$STR{'SO_NSLookup'}})         and !$NSLookup;
        $ResolveTLD       = 1 if exists($$refSO{$object}{opt}{$STR{'SO_ResolveTLD'}})       and !$ResolveTLD;
        $IPAddr_XLWhoisDB = 1 if exists($$refSO{$object}{opt}{$STR{'SO_IPAddr_XLWhoisDB'}}) and !$IPAddr_XLWhoisDB;
        $ResolveGeoIP     = 1 if exists($$refSO{$object}{opt}{$STR{'SO_GeoIP'}})            and !$ResolveGeoIP;
        $MACAddr_ResOUI   = 1 if exists($$refSO{$object}{opt}{$STR{'SO_MACAddr_ResOUI'}})   and !$MACAddr_ResOUI;
        $CC_ResIC         = 1 if exists($$refSO{$object}{opt}{$STR{'SO_CC_ResIC'}})         and !$CC_ResIC;
      }
    }
    # Keep order of options
    my $col = 2;
    $NSLookup         = $col++ if $NSLookup;
    $ResolveTLD       = $col++ if $ResolveTLD;
    $IPAddr_XLWhoisDB = $col++ if $IPAddr_XLWhoisDB;
    $ResolveGeoIP     = $col++ if $ResolveGeoIP;
    $MACAddr_ResOUI   = $col++ if $MACAddr_ResOUI;
    $CC_ResIC         = $col++ if $CC_ResIC;
    # Single report
    if (!$separatedReport) {
      my $report = "$reportDir\\XL-Parser $STR{'report'}.txt";
      # Replace report if exists ?
      if (!$replaceReport and -e $report) {
        my $i = 1;
        while (-e $report) { $report = "$reportDir\\XL-Parser $STR{'report'} ($i).txt"; $i++; }
      }
      # Open 
      if (open(my $fhReport, ">$report")) {
        my $count = 0;
        # Check existing options data
        my $NSLookup         = 0;
        my $ResolveTLD       = 0;
        my $IPAddr_XLWhoisDB = 0;
        my $ResolveGeoIP     = 0;
        my $MACAddr_ResOUI   = 0;
        my $CC_ResIC         = 0;
        foreach my $object (keys %{$refSO}) {
          if (exists($$refSO{$object}{opt})) {
            $NSLookup         = 1 if exists($$refSO{$object}{opt}{$STR{'SO_NSLookup'}})         and !$NSLookup;
            $ResolveTLD       = 1 if exists($$refSO{$object}{opt}{$STR{'SO_ResolveTLD'}})       and !$ResolveTLD;
            $IPAddr_XLWhoisDB = 1 if exists($$refSO{$object}{opt}{$STR{'SO_IPAddr_XLWhoisDB'}}) and !$IPAddr_XLWhoisDB;
            $ResolveGeoIP     = 1 if exists($$refSO{$object}{opt}{$STR{'SO_GeoIP'}})            and !$ResolveGeoIP;
            $MACAddr_ResOUI   = 1 if exists($$refSO{$object}{opt}{$STR{'SO_MACAddr_ResOUI'}})   and !$MACAddr_ResOUI;
            $CC_ResIC         = 1 if exists($$refSO{$object}{opt}{$STR{'SO_CC_ResIC'}})         and !$CC_ResIC;
          }
        }
        # Headers
        if ($winReport->chReportOptIncHeaders->Checked()) {
          my $headers;
          $headers .= "$STR{'Object'}\t"              if $incSO;
          $headers .= "$STR{'Results'}\t";
          $headers .= "$STR{'Count'}\t";
          $headers .= "$STR{'SO_NSLookup'}\t"         if $NSLookup;
          $headers .= "$STR{'SO_ResolveTLD'}\t"       if $ResolveTLD;
          $headers .= "$STR{'SO_IPAddr_XLWhoisDB'}\t" if $IPAddr_XLWhoisDB;
          $headers .= "$STR{'SO_GeoIP'}\t"            if $ResolveGeoIP;
          $headers .= "$STR{'SO_MACAddr_ResOUI'}\t"   if $MACAddr_ResOUI;
          $headers .= "$STR{'SO_CC_ResIC'}\t"         if $CC_ResIC;
          chop($headers);
          print $fhReport "$headers\n";
        }
        while (<$tmpReportFH>) {
          my @fields = split(/\t/, $_);
          my $newLine;
          $newLine  .= shift(@fields) . "\t" if $incSO;
          my $result = shift(@fields);
          my $nbrRes = shift(@fields);
          $newLine  .= "$result\t$nbrRes\t";
          $newLine  .= join("\t", @fields) . "\t";
          chop($newLine);
          print $fhReport "$newLine\n";
          
          # Update progress
          $count += $nbrRes;
          $winResults->lblCount->Text("$count / $nbrResults");
          $winResults->pb->SetStep($nbrRes);
          $winResults->pb->StepIt();
        }        
        close($fhReport);
        push(@return, $report);
      }
    # One report per object
    } else {
      my %fhReports;
      my $count = 0;
      while (<$tmpReportFH>) {
        chomp($_);
        my @fields     = split(/\t/, $_);
        my $object     = shift(@fields);
        my $reportName = "XL-Parser $STR{'report'} - $object";
        my $report     = "$reportDir\\$reportName.html";
        my $fhReport;
        my $no = 1;
        # Replace report if exists ?
        if (!$replaceReport and -e $report) {
          my $i = 1;
          while (-e $report) { $report = "$reportDir\\$reportName ($i).txt"; $i++; }
        }
        if (exists($fhReports{$object})) { $fhReport = $fhReports{$object}; } # Already open
        elsif (open(my $fh, '>', $report)) { # Open a new report
          $fhReport = $fh;
          $fhReports{$object} = $fh;
          push(@return, $report);
          # Headers
          if ($winReport->chReportOptIncHeaders->Checked()) {
            my $headers;
            $headers .= "$STR{'Results'}\t";
            $headers .= "$STR{'Count'}\t";
            # Options
            $headers .= "$STR{'SO_NSLookup'}\t"         if exists($$refSO{$object}{opt}{$STR{'SO_NSLookup'}});
            $headers .= "$STR{'SO_ResolveTLD'}\t"       if exists($$refSO{$object}{opt}{$STR{'SO_ResolveTLD'}});
            $headers .= "$STR{'SO_IPAddr_XLWhoisDB'}\t" if exists($$refSO{$object}{opt}{$STR{'SO_IPAddr_XLWhoisDB'}});
            $headers .= "$STR{'SO_GeoIP'}\t"            if exists($$refSO{$object}{opt}{$STR{'SO_GeoIP'}});
            $headers .= "$STR{'SO_MACAddr_ResOUI'}\t"   if exists($$refSO{$object}{opt}{$STR{'SO_MACAddr_ResOUI'}});
            $headers .= "$STR{'SO_CC_ResIC'}\t"         if exists($$refSO{$object}{opt}{$STR{'SO_CC_ResIC'}});
            chop($headers);
            print $fhReport "$headers\n";
          }
        }
        if ($fhReport) {
          my $newLine;
          $newLine .= "$fields[0]\t"; # Result
          $newLine .= "$fields[1]\t"; # Number of results
          # Options
          my $col = 2;
          for (my $j = 2; $j < scalar(@fields); $j++) { # Add results
            if ($fields[$j] eq '-') { # Options
              if    ($NSLookup         and $j == $NSLookup         and !exists($$refSO{$object}{opt}{$STR{'SO_NSLookup'}})        ) { next; }
              elsif ($ResolveTLD       and $j == $ResolveTLD       and !exists($$refSO{$object}{opt}{$STR{'SO_ResolveTLD'}})      ) { next; }
              elsif ($IPAddr_XLWhoisDB and $j == $IPAddr_XLWhoisDB and !exists($$refSO{$object}{opt}{$STR{'SO_IPAddr_XLWhoisDB'}})) { next; }
              elsif ($ResolveGeoIP     and $j == $ResolveGeoIP     and !exists($$refSO{$object}{opt}{$STR{'SO_GeoIP'}})           ) { next; }
              elsif ($MACAddr_ResOUI   and $j == $MACAddr_ResOUI   and !exists($$refSO{$object}{opt}{$STR{'SO_MACAddr_ResOUI'}})  ) { next; }
              elsif ($CC_ResIC         and $j == $CC_ResIC         and !exists($$refSO{$object}{opt}{$STR{'SO_CC_ResIC'}})        ) { next; }
            }
            $newLine .= "$fields[$j]\t";
            $col++;
          }
          chop($newLine);          
          print $fhReport "$newLine\n";
        }
        # Update progress
        $count += $fields[1];
        $winResults->lblCount->Text("$count / $nbrResults");
        $winResults->pb->SetStep($fields[1]);
        $winResults->pb->StepIt();
      }
      foreach (values %fhReports) { close($_); } # Close all filehandles
    }
    close($tmpReportFH);
  }
  return(\@return);

}  #--- End writeReportSOTXT

#--------------------------#
sub ExtractResults
#--------------------------#
{
  # Local variables
  my $resFile = $$REF_ARG[3];
	if (-f $resFile and open(my $json, $resFile)) {
    $THR = threads->create(sub {
      $winResults->pb->Hide();
      $winResults->ChangeCursor($HOURGLASS);
      # Local variable
      my %results;
      my $refResults = \%results;
      # Thread 'cancellation' signal handler
      $SIG{'KILL'} = sub {
        $winResults->ChangeCursor($ARROW);
        threads->exit();
      };
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        $winResults->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winResults, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      my $jsonText = <$json>;
      close($json);
      # Set Result Files grid header
      $winResults->gridResFiles->SetCellText(0, 0, $STR{'ResStatsFiles'} );
      $winResults->gridResFiles->SetCellText(0, 1, $STR{'Size'}          );
      $winResults->gridResFiles->SetCellText(0, 2, $STR{'ResStatsLines'} );
      $winResults->gridResFiles->SetCellText(0, 3, $STR{'Results'});
      $winResults->gridResFiles->SetCellFormat(0, 0, 1); # Center column headers
      $winResults->gridResFiles->SetCellFormat(0, 1, 1);
      $winResults->gridResFiles->SetCellFormat(0, 2, 1);
      $winResults->gridResFiles->SetCellFormat(0, 3, 1);
      $winResults->gridResFiles->AutoSize();
      $winResults->gridResFiles->ExpandColumnsToFit() if $winResults->gridResFiles->GetVirtualWidth() < $winResults->gridResFiles->Width();
      $winResults->gridResFiles->Refresh();
      # Load results
      $winResults->lblCurr->Text($STR{'LoadingResults'}.'...');
      my $jsonObj = JSON->new;
      $refResults = $jsonObj->decode($jsonText);
      $winResults->lblCurr->Text('');
      # Set stats
      my $sizeStr = &formatFileSize($$refResults{totResSize});
      $winResults->lblResStatsFilesVal->Text($$refResults{totResFiles});
      $winResults->lblResStatsLinesVal->Text($$refResults{totResLines});
      $winResults->lblResStatsSizeVal->Text($sizeStr);
      $winResults->lblResStatsDurationVal->Text(0);
      $winResults->lblResStatsResultsVal->Text($$refResults{totResResults});
      $winResults->btnWinReport->Enable() if $$refResults{totResResults};
      # Feed the grid By file
      foreach my $file (keys %{$$refResults{byFile}}) {
        $file = encode('cp1252', $file);
        if (my $newLine = $winResults->gridResFiles->InsertRow($file, -1)) {
          $winResults->gridResFiles->SetCellText($newLine, 0, $file); # File path
          $winResults->gridResFiles->SetCellFormat($newLine, 1, 2);
          $winResults->gridResFiles->SetCellFormat($newLine, 2, 2);
          $winResults->gridResFiles->SetCellFormat($newLine, 3, 2);
          $winResults->gridResFiles->SetCellText($newLine, 1, $$refResults{byFile}{$file}{fileSize}  ) if $$refResults{byFile}{$file}{fileSize}; # Size
          $winResults->gridResFiles->SetCellText($newLine, 2, $$refResults{byFile}{$file}{nbrLines}  ); # Number of lines
          $winResults->gridResFiles->SetCellText($newLine, 3, $$refResults{byFile}{$file}{nbrResults}); # Number of results
        }
      }
      $winResults->gridResFiles->Refresh();
      $winResults->gridResFiles->AutoSize();
      $winResults->gridResFiles->ExpandColumnsToFit() if $winResults->gridResFiles->GetVirtualWidth() < $winResults->gridResFiles->Width();
      if (exists($$refResults{byExpr})) {
        # Set Result Expressions grid header
        $winResults->gridResExpr->SetColumns(5);
        $winResults->rbResByExpr->Text($STR{'rbResByExpr'});
        $winResults->gridResExpr->SetCellText(0, 0, $STR{'Expression'} );
        $winResults->gridResExpr->SetCellText(0, 1, $STR{'Case'}           );
        $winResults->gridResExpr->SetCellText(0, 2, $STR{'Regex'}          );
        $winResults->gridResExpr->SetCellText(0, 3, $STR{'Invert'}         );
        $winResults->gridResExpr->SetCellText(0, 4, $STR{'Results'} );
        $winResults->gridResExpr->SetCellFormat(0, 0, 1); # Center column headers
        $winResults->gridResExpr->SetCellFormat(0, 1, 1);
        $winResults->gridResExpr->SetCellFormat(0, 2, 1);
        $winResults->gridResExpr->SetCellFormat(0, 3, 1);
        $winResults->gridResExpr->SetCellFormat(0, 4, 1);
        # Feed the grid By expression
        foreach my $expr (keys %{$$refResults{byExpr}}) {
          if (my $newLine = $winResults->gridResExpr->InsertRow($expr, -1)) {
            $winResults->gridResExpr->SetCellText($newLine, 0, $expr);
            $winResults->gridResExpr->SetCellType($newLine, 1, 4);
            $winResults->gridResExpr->SetCellType($newLine, 2, 4);
            $winResults->gridResExpr->SetCellType($newLine, 3, 4);
            if ($$refResults{byExpr}{$expr}{case})   { $winResults->gridResExpr->SetCellCheck($newLine, 1, 1); }
            else                                     { $winResults->gridResExpr->SetCellCheck($newLine, 1, 0); }
            if ($$refResults{byExpr}{$expr}{regex})  { $winResults->gridResExpr->SetCellCheck($newLine, 2, 1); }
            else                                     { $winResults->gridResExpr->SetCellCheck($newLine, 2, 0); }
            if ($$refResults{byExpr}{$expr}{invert}) { $winResults->gridResExpr->SetCellCheck($newLine, 3, 1); }
            else                                     { $winResults->gridResExpr->SetCellCheck($newLine, 3, 0); }
            $winResults->gridResExpr->SetCellText($newLine, 4, $$refResults{byExpr}{$expr}{nbrRes});
          }
        }
      } elsif (exists($$refResults{bySO})) {
        # Set Result Objects grid header
        $winResults->gridResExpr->SetColumns(3);
        $winResults->rbResByExpr->Text($STR{'rbResByObject'});
        $winResults->gridResExpr->SetCellText(0, 0, $STR{'Object'});
        $winResults->gridResExpr->SetCellText(0, 1, $STR{'Results'});
        $winResults->gridResExpr->SetCellText(0, 2, $STR{'Options'});
        $winResults->gridResExpr->SetCellFormat(0, 0, 1); # Center column headers
        $winResults->gridResExpr->SetCellFormat(0, 1, 1);
        $winResults->gridResExpr->SetCellFormat(0, 2, 1);
        # Feed the grid By Special Objects
        foreach my $object (keys %{$$refResults{bySO}}) {
          if (my $newLine = $winResults->gridResExpr->InsertRow($object, -1)) {
            $winResults->gridResExpr->SetCellText($newLine, 0, $object);
            $winResults->gridResExpr->SetCellText($newLine, 1, $$refResults{bySO}{$object}{nbrRes});
            my $optionStr;
            if (scalar(keys %{$$refResults{SO}{$object}{options}})) {
              foreach my $opt (keys %{$$refResults{SO}{$object}{options}}) { $optionStr .= $opt . ","; }
              chop($optionStr);
              $winResults->gridResExpr->SetCellText($newLine, 2, $optionStr) if $optionStr;
            }
          }
        }
      }
      $winResults->gridResExpr->Refresh();
      $winResults->gridResExpr->AutoSize();
      $winResults->gridResExpr->ExpandColumnsToFit() if $winResults->gridResExpr->GetVirtualWidth() < $winResults->gridResExpr->Width();
      # Copy tmp results
      if ($resFile =~ /(.+?)\.json$/) {
        my $tmpSavedResult1 = $1 . '.XL-Parser_tmp.txt';
        my $tmpSavedResult2 = $1 . '.XL-Parser_tmp2.txt';
        Win32::CopyFile($tmpSavedResult1, "$REPORTDIR\\.XL-Parser_tmp-"  . $PROCESSID .'.txt' , 0) if -f $tmpSavedResult1;
        Win32::CopyFile($tmpSavedResult2, "$REPORTDIR\\.XL-Parser_tmp2-" . $PROCESSID .'.txt' , 0) if -f $tmpSavedResult2;
      }
      $winResults->btnCancelExtract->Hide();
      $winResults->btnCloseWinResults->Show();
      $winResults->ChangeCursor($ARROW);
    });
  }
  
}  #--- End ExtractResults

#--------------------------#
sub queryDB
#--------------------------#
{
  if (open(my $json, "$REPORTDIR\\CurrentQueryParams-" . $PROCESSID .'.json')) {
    $THR = threads->create(sub {
      # Local variables
      my %queryParams;
      my $refQueryParams = \%queryParams;
      my ($dbh, $sth);
      # Thread 'cancellation' signal handler
      $SIG{'KILL'} = sub {
        # Finish statement handle and disconnect database
        undef $dbh;
        $winPb->ChangeCursor($ARROW);
        threads->exit();
      };
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        # Finish statement handle and disconnect database
        undef $dbh;
        $winPb->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winPb, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      $winPb->ChangeCursor($HOURGLASS);
      my $jsonText = <$json>;
      close($json);
      my $jsonObj = JSON->new;
      $refQueryParams = $jsonObj->decode($jsonText);
      $$refQueryParams{outTZ} = $$refQueryParams{localTZ} if $$refQueryParams{outTZ} eq 'local';
      my $locale = DateTime::Locale->load($$refQueryParams{language});
      my $refWeekdays = $locale->day_format_wide();
      my %columnNameStr = ('id' => 'id', 'remoteIP' => $STR{'LFclientIP'}, 'remoteIPInt' => 'remoteIPInt', 'datetimeInt' => $STR{'DTDB'},
                           'timeOfDay' => 'timeOfDay', 'weekday' => $STR{'Weekday'}, 'http_method' => $STR{'LFHTTPmethod'},
                           'http_request' => $STR{'LFHTTPreq'}, 'http_params' => $STR{'LFHTTPparam'}, 'http_protocol' => $STR{'LFHTTPprot'},
                           'http_status' => $STR{'LFHTTPstatus'}, 'size' => $STR{'LFsize'}, 'referer' => $STR{'LFReferer'},
                           'useragent' => $STR{'LFUA'}, 'file' => $STR{'SourceFile'});
      my @columnNames;
      my $all;
      # Report filename
      my $reportExt;
      if    ($$refQueryParams{reportFormat} eq 'XLSX') { $reportExt = 'xlsx'; }
      elsif ($$refQueryParams{reportFormat} eq 'HTML') { $reportExt = 'html'; }
      else                                             { $reportExt = 'txt';  }
      my $report = $$refQueryParams{reportDir}."\\XL-Parser $STR{'report'}\.$reportExt";
      # Replace report if exists ?
      if (-e $report and !$$refQueryParams{replReport}) {
        my $i = 1;
        while (-e $report) { $report = $$refQueryParams{reportDir}."\\XL-Parser $STR{'report'} ($i)\.$reportExt"; $i++; }
      }
      # Column names
      if ($$refQueryParams{query} =~ /^SELECT (?:DISTINCT )?(.+?) FROM /) {
        my $colStr = $1;
        if ($colStr eq '*') {
          @columnNames = ('id', 'remoteIP', 'remoteIPInt', 'datetimeInt', 'timeOfDay', 'weekday', 'http_method', 'http_request',
                          'http_params', 'http_protocol', 'http_status', 'size', 'referer', 'useragent', 'file');
          $all = 1;
        } else {
          @columnNames = split(/, ?/, $colStr);
          my $i = 0;
          foreach (@columnNames) { $columnNames[$i] = $1 if /AS ([^, ]+)/; $i++; }
        }
      }
      # Connect to log database
      my $dsn = "DBI:SQLite:dbname=$$refQueryParams{dbFile}";
      if ($dbh = DBI->connect($dsn, undef, undef, { RaiseError => 1, AutoCommit => 0})) {
        eval { $sth = $dbh->prepare($$refQueryParams{query}); };
        if ($@) {
          my $errMsg = (split(/ at /,$@))[0];
          Win32::GUI::MessageBox($winPb, $errMsg , $STR{'error'}, 0x40010);
        } else {
          # Set progress
          $winPb->pb->SetRange(0, 1);
          $winPb->pb->SetPos(0);
          $winPb->pb->SetStep(1);
          $winPb->lblCount->Text('0');
          $winPb->lblCurr->Text($STR{'ExecQuery'}.'...');
          if    ($$refQueryParams{reportFormat} eq 'XLSX') {
            &writeQueryDBResultXLSX($report, $refQueryParams, \@columnNames, \%columnNameStr, $all, \$dbh, \$sth, $refWeekdays);
          } elsif ($$refQueryParams{reportFormat} eq 'HTML') {
            &writeQueryDBResultHTML($report, $refQueryParams, \@columnNames, \%columnNameStr, $all, \$dbh, \$sth, $refWeekdays);
          } else {
            &writeQueryDBResultTXT( $report, $refQueryParams, \@columnNames, \%columnNameStr, $all, \$dbh, \$sth, $refWeekdays);
          }
          $winPb->pb->StepIt();
          $winPb->ShellExecute('open', $report,'','',1) if $$refQueryParams{openReport};
        }
        $dbh->disconnect();
      }
      $winPb->ChangeCursor($ARROW);
      # Delete temp file
      unlink("$REPORTDIR\\CurrentQueryParams-" . $PROCESSID .'.json') if -e "$REPORTDIR\\CurrentQueryParams-" . $PROCESSID .'.json';
      exit(0);
    });
  }
  
}  #--- End queryDB

#--------------------------#
sub writeQueryDBResultXLSX
#--------------------------#
{
  # Local variables
  my ($report, $refQueryParams, $refColumnNames, $refColumnNameStr, $all, $refDbh, $refSth, $refWeekdays) = @_;
  # Create an XLSX workbook with a single sheet
  if (my $excel = Excel::Writer::XLSX->new($report)) {
    if (my $sheet = $excel->add_worksheet($STR{'Results'})) {
      my @maxColWidth;
      my $count = 0;
      my $i     = 0;
      # Include headers
      if ($$refQueryParams{incHeader}) {
        my $formatHeader = $excel->add_format();
        $formatHeader->set_bold();
        $formatHeader->set_align('center');
        $formatHeader->set_align('vcenter');
        my $header;
        my $countCol = 0;
        my $j = 0; # Column No
        foreach (@{$refColumnNames}) {
          if (!$all or ($$refColumnNames[$countCol] ne 'id' and $$refColumnNames[$countCol] ne 'remoteIPInt' and
                        $$refColumnNames[$countCol] ne 'timeOfDay')) {
            if ($$refColumnNames[$countCol] eq 'remoteIP' and ($$refQueryParams{incISP} or $$refQueryParams{incGeoIP})) {
              $sheet->write(0, $j, $$refColumnNameStr{$_}, $formatHeader );
              push(@maxColWidth, length($$refColumnNameStr{$_})+10); $j++;
              if ($$refQueryParams{incISP}) {
                $sheet->write(0, $j, $STR{'isp'}, $formatHeader );
                push(@maxColWidth, length($STR{'isp'})+10); $j++;
              }
              if ($$refQueryParams{incGeoIP}) {
                $sheet->write(0, $j, $STR{'GeoIPDB'}, $formatHeader );
                push(@maxColWidth, length($STR{'GeoIPDB'})+10); $j++;
              }
            } elsif ($$refColumnNames[$countCol] eq 'useragent' and $$refQueryParams{incUADetails}) {
              $sheet->write(0, $j, $$refColumnNameStr{$_}, $formatHeader );
              push(@maxColWidth, length($$refColumnNameStr{$_})+10); $j++;
              $sheet->write(0, $j, $STR{'Type'}, $formatHeader );
              push(@maxColWidth, length($STR{'Type'})+10); $j++;
              $sheet->write(0, $j, $STR{'uaOS'}, $formatHeader );
              push(@maxColWidth, length($STR{'uaOS'})+10); $j++;
              $sheet->write(0, $j, $STR{'uaBrowser'}, $formatHeader );
              push(@maxColWidth, length($STR{'uaBrowser'})+10); $j++;
              $sheet->write(0, $j, $STR{'uaDevice'}, $formatHeader );
              push(@maxColWidth, length($STR{'uaDevice'})+10); $j++;
              $sheet->write(0, $j, $STR{'uaLang'}, $formatHeader );
              push(@maxColWidth, length($STR{'uaLang'})+10); $j++;
            } elsif ($$refColumnNames[$countCol] eq 'weekday') {
              if ($$refQueryParams{incWeekdays}) {
                $sheet->write(0, $j, $$refColumnNameStr{$_}, $formatHeader );
                push(@maxColWidth, length($$refColumnNameStr{$_})+10); $j++;
              }
            } elsif ($$refColumnNames[$countCol] eq 'file') {
              if ($$refQueryParams{incSource}) {
                $sheet->write(0, $j, $$refColumnNameStr{$_}, $formatHeader );
                push(@maxColWidth, length($$refColumnNameStr{$_})+10); $j++;
              }
            } elsif ($$refColumnNameStr{$_}) {
              $sheet->write(0, $j, $$refColumnNameStr{$_}, $formatHeader );
              push(@maxColWidth, length($$refColumnNameStr{$_})+10); $j++;
            } else {
              $sheet->write(0, $j, $_, $formatHeader );
              push(@maxColWidth, length($_)+10); $j++;
            }
          }
          $countCol++;
        }
        $i++;
      }
      $$refSth->execute();
      my $countRow = 0;
      while (my $refEntryFields = $$refSth->fetchrow_arrayref()) {
        my $newLine;
        my $countCol = 0;
        my $j = 0; # Column no
        foreach my $value (@$refEntryFields) {
          if (!$all or ($$refColumnNames[$countCol] ne 'id' and $$refColumnNames[$countCol] ne 'remoteIPInt') and
                        $$refColumnNames[$countCol] ne 'timeOfDay') {
            if (defined($value)) {
              if ($$refColumnNames[$countCol] eq 'datetimeInt') {
                my $dt = DateTime->from_epoch(epoch => ($value));
                $dt->set(locale => $$refQueryParams{language});
                $dt->set_time_zone($$refQueryParams{outTZ});
                my $dateTime = $dt->strftime($$refQueryParams{outPattern});
                $sheet->write_string($i, $j, $dateTime);
                my $length = length($dateTime);
                $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]); $j++;
              } elsif ($$refColumnNames[$countCol] eq 'remoteIP' and ($$refQueryParams{incISP} or $$refQueryParams{incGeoIP})) {
                $sheet->write_string($i, $j, $value);
                my $length = length($value);
                $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]); $j++;
                my ($isp, $geoIP) = $$refDbh->selectrow_array('SELECT isp,geoIP FROM IP WHERE ip == ?', undef, $value);
                if ($$refQueryParams{incISP}) {
                  if ($isp  ) {
                    $sheet->write_string($i, $j, $isp);
                    my $length = length($isp);
                    $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]); $j++;
                  } else { $j++; }
                }
                if ($$refQueryParams{incGeoIP}) {
                  if ($geoIP) {
                    $sheet->write_string($i, $j, $geoIP);
                    my $length = length($geoIP);
                    $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]); $j++;
                  } else { $j++; }
                }
              } elsif ($$refColumnNames[$countCol] eq 'weekday') {
                if ($$refQueryParams{incWeekdays}) {
                  $sheet->write_string($i, $j, $$refWeekdays[$value]);
                  my $length = length($$refWeekdays[$value]);
                  $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]); $j++;
                }
              } elsif ($$refColumnNames[$countCol] eq 'useragent' and $$refQueryParams{incUADetails}) {
                $sheet->write_string($i, $j, $value);
                my $length = length($value);
                $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]); $j++;
                my (@UADetails) = $$refDbh->selectrow_array('SELECT * FROM UA WHERE ua == ?', undef, $value);
                for (my $k = 1; $k < 6; $k++) {
                  if ($UADetails[$k]) {
                    $sheet->write_string($i, $j, $UADetails[$k]);
                    my $length = length($UADetails[$k]);
                    $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]); $j++;
                  } else { $j++; }
                }
              } elsif ($$refColumnNames[$countCol] eq 'file') {
                if ($$refQueryParams{incSource}) {
                  my $file = $$refDbh->selectrow_array('SELECT path FROM FILES WHERE id == ?', undef, $value);
                  if ($file) {
                    $sheet->write_string($i, $j, $file);
                    my $length = length($file);
                    $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]); $j++;
                  } else { $j++; }
                }
              } else {
                $sheet->write_string($i, $j, $value);
                my $length = length($value);
                $maxColWidth[$j] = $length if ($length > $maxColWidth[$j]); $j++;
              }
            } else { $j++; }
          }
          $countCol++;
        }
        $i++;
        # Update progress
        $countRow++;
        $winPb->lblCount->Text($countRow);
      }
      # Resize colum width
      my $j = 0;
      foreach (@maxColWidth) { $sheet->set_column($j, $j, $_); $j++; }
      # Set autofilter
      $sheet->autofilter(0, 0, 0, --$j) if $$refQueryParams{incHeader};
      $sheet->freeze_panes(1, 0);
    }
    $excel->close(); # Close the file
  }

}  #--- End writeQueryDBResultXLSX

#--------------------------#
sub writeQueryDBResultHTML
#--------------------------#
{
  # Local variables
  my ($report, $refQueryParams, $refColumnNames, $refColumnNameStr, $all, $refDbh, $refSth, $refWeekdays) = @_;
  # Create report
  if (open(my $fhQueryRes, ">$report")) {
    # Include headers
    my @headers;
    if ($$refQueryParams{incHeader}) {
      my $countCol = 0;
      foreach (@{$refColumnNames}) {
        if (!$all or ($$refColumnNames[$countCol] ne 'id' and $$refColumnNames[$countCol] ne 'remoteIPInt' and
                      $$refColumnNames[$countCol] ne 'timeOfDay')) {
          if ($$refColumnNames[$countCol] eq 'remoteIP' and ($$refQueryParams{incISP} or $$refQueryParams{incGeoIP})) {
            push(@headers, $$refColumnNameStr{$_});
            push(@headers, $STR{'isp'}    ) if $$refQueryParams{incISP};
            push(@headers, $STR{'GeoIPDB'}) if $$refQueryParams{incGeoIP};
          } elsif ($$refColumnNames[$countCol] eq 'useragent' and $$refQueryParams{incUADetails}) {
            push(@headers, $$refColumnNameStr{$_});
            push(@headers, $STR{'Type'});
            push(@headers, $STR{'uaOS'});
            push(@headers, $STR{'uaBrowser'});
            push(@headers, $STR{'uaDevice'});
            push(@headers, $STR{'uaLang'});
          } elsif ($$refColumnNames[$countCol] eq 'weekday') {
            push(@headers, $$refColumnNameStr{$_}) if $$refQueryParams{incWeekdays};
          } elsif ($$refColumnNames[$countCol] eq 'file') {
            push(@headers, $$refColumnNameStr{$_}) if $$refQueryParams{incSource};
          } elsif ($$refColumnNameStr{$_}) { push(@headers, $$refColumnNameStr{$_});
          } else { push(@headers, $_); }
        }
        $countCol++;
      }
    }
    &createReportHTML($fhQueryRes, \@headers);
    $$refSth->execute();
    my $countRow = 0;
    while (my $refEntryFields = $$refSth->fetchrow_arrayref()) {
      my $countCol = 0;
      print $fhQueryRes "<tr>";
      foreach my $value (@$refEntryFields) {
        if (!$all or ($$refColumnNames[$countCol] ne 'id' and $$refColumnNames[$countCol] ne 'remoteIPInt') and
                      $$refColumnNames[$countCol] ne 'timeOfDay') {
          if (defined($value)) {
            $value =~ s/</&lt;/g;
            $value =~ s/>/&gt;/g;
            if ($$refColumnNames[$countCol] eq 'datetimeInt') {
              my $dt = DateTime->from_epoch(epoch => ($value));
              $dt->set(locale => $$refQueryParams{language});
              $dt->set_time_zone($$refQueryParams{outTZ});
              print $fhQueryRes '<td>'.$dt->strftime($$refQueryParams{outPattern}).'</td>';
            } elsif ($$refColumnNames[$countCol] eq 'remoteIP' and ($$refQueryParams{incISP} or $$refQueryParams{incGeoIP})) {
              print $fhQueryRes '<td>'.$value.'</td>';
              my ($isp, $geoIP) = $$refDbh->selectrow_array('SELECT isp,geoIP FROM IP WHERE ip == ?', undef, $value);
              if ($$refQueryParams{incISP}  ) { if ($isp  ) { print $fhQueryRes '<td>'.$isp  .'</td>'; } else { print $fhQueryRes '<td></td>'; } }
              if ($$refQueryParams{incGeoIP}) { if ($geoIP) { print $fhQueryRes '<td>'.$geoIP.'</td>'; } else { print $fhQueryRes '<td></td>'; } }
            } elsif ($$refColumnNames[$countCol] eq 'weekday') {
              print $fhQueryRes '<td>'.$$refWeekdays[$value].'</td>' if $$refQueryParams{incWeekdays};
            } elsif ($$refColumnNames[$countCol] eq 'useragent' and $$refQueryParams{incUADetails}) {
              print $fhQueryRes '<td>'.$value.'</td>';
              my (@UADetails) = $$refDbh->selectrow_array('SELECT * FROM UA WHERE ua == ?', undef, $value);
              for (my $i = 1; $i < 6; $i++) { if ($UADetails[$i]) { print $fhQueryRes '<td>'.$UADetails[$i].'</td>'; } else { print $fhQueryRes '<td></td>'; } }
            } elsif ($$refColumnNames[$countCol] eq 'file') {
              if ($$refQueryParams{incSource}) {
                my $file = $$refDbh->selectrow_array('SELECT path FROM FILES WHERE id == ?', undef, $value);
                if ($file) { print $fhQueryRes '<td>'.$file."\t"; } else { print $fhQueryRes '<td></td>'; }
              }
            } else { print $fhQueryRes '<td>'.$value.'</td>'; }
          } else { print $fhQueryRes '<td></td>'; }
        }
        $countCol++;
      }
      print $fhQueryRes "</tr>";
      # Update progress
      $countRow++;
      $winPb->lblCount->Text($countRow);
    }
    print $fhQueryRes "</table>\n</body>\n</html>\n";
    close($fhQueryRes);
  }

}  #--- End writeQueryDBResultHTML

#--------------------------#
sub writeQueryDBResultTXT
#--------------------------#
{
  # Local variables
  my ($report, $refQueryParams, $refColumnNames, $refColumnNameStr, $all, $refDbh, $refSth, $refWeekdays) = @_;
  # Create report
  if (open(my $fhQueryRes, ">$report")) {
    # Include headers
    if ($$refQueryParams{incHeader}) {
      my $header;
      my $countCol = 0;
      foreach (@{$refColumnNames}) {
        if (!$all or ($$refColumnNames[$countCol] ne 'id' and $$refColumnNames[$countCol] ne 'remoteIPInt' and
                      $$refColumnNames[$countCol] ne 'timeOfDay')) {
          if ($$refColumnNames[$countCol] eq 'remoteIP' and ($$refQueryParams{incISP} or $$refQueryParams{incGeoIP})) {
            $header .= $$refColumnNameStr{$_}."\t";
            $header .= $STR{'isp'}    ."\t" if $$refQueryParams{incISP};
            $header .= $STR{'GeoIPDB'}."\t" if $$refQueryParams{incGeoIP};
          } elsif ($$refColumnNames[$countCol] eq 'useragent' and $$refQueryParams{incUADetails}) {
            $header .= $$refColumnNameStr{$_}."\t";
            $header .= $STR{'Type'}."\t".$STR{'uaOS'}."\t".$STR{'uaBrowser'}."\t".$STR{'uaDevice'}."\t".$STR{'uaLang'}."\t";
          } elsif ($$refColumnNames[$countCol] eq 'weekday') {
            $header .= $$refColumnNameStr{$_}."\t" if $$refQueryParams{incWeekdays};
          } elsif ($$refColumnNames[$countCol] eq 'file') {
            $header .= $$refColumnNameStr{$_}."\t" if $$refQueryParams{incSource};
          } elsif ($$refColumnNameStr{$_}) { $header .= $$refColumnNameStr{$_}."\t";
          } else { $header .= $_."\t"; }
        }
        $countCol++;
      }
      chop($header);
      print $fhQueryRes $header."\n";
    }
    $$refSth->execute();
    my $countRow = 0;
    while (my $refEntryFields = $$refSth->fetchrow_arrayref()) {
      my $newLine;
      my $countCol = 0;
      foreach my $value (@$refEntryFields) {
        if (!$all or ($$refColumnNames[$countCol] ne 'id' and $$refColumnNames[$countCol] ne 'remoteIPInt') and
                      $$refColumnNames[$countCol] ne 'timeOfDay') {
          if (defined($value)) {
            if ($$refColumnNames[$countCol] eq 'datetimeInt') {
              my $dt = DateTime->from_epoch(epoch => ($value));
              $dt->set(locale => $$refQueryParams{language});
              $dt->set_time_zone($$refQueryParams{outTZ});
              $newLine .= $dt->strftime($$refQueryParams{outPattern})."\t";
            } elsif ($$refColumnNames[$countCol] eq 'remoteIP' and ($$refQueryParams{incISP} or $$refQueryParams{incGeoIP})) {
              $newLine .= $value."\t";
              my ($isp, $geoIP) = $$refDbh->selectrow_array('SELECT isp,geoIP FROM IP WHERE ip == ?', undef, $value);
              if ($$refQueryParams{incISP}  ) { if ($isp  ) { $newLine .= $isp   ."\t"; } else { $newLine .= "\t"; } }
              if ($$refQueryParams{incGeoIP}) { if ($geoIP) { $newLine .= $geoIP ."\t"; } else { $newLine .= "\t"; } }
            } elsif ($$refColumnNames[$countCol] eq 'weekday') {
              $newLine .= $$refWeekdays[$value]."\t" if $$refQueryParams{incWeekdays};
            } elsif ($$refColumnNames[$countCol] eq 'useragent' and $$refQueryParams{incUADetails}) {
              $newLine .= $value."\t";
              my (@UADetails) = $$refDbh->selectrow_array('SELECT * FROM UA WHERE ua == ?', undef, $value);
              for (my $i = 1; $i < 6; $i++) { if ($UADetails[$i]) { $newLine .= $UADetails[$i]."\t"; } else { $newLine .= "\t"; } }
            } elsif ($$refColumnNames[$countCol] eq 'file') {
              if ($$refQueryParams{incSource}) {
                my $file = $$refDbh->selectrow_array('SELECT path FROM FILES WHERE id == ?', undef, $value);
                if ($file) { $newLine .= $file."\t"; } else { $newLine .= "\t"; }
              }
            } else { $newLine .= $value."\t"; }
          } else { $newLine .= "\t"; }
        }
        $countCol++;
      }
      chop($newLine);
      print $fhQueryRes $newLine."\n";
      # Update progress
      $countRow++;
      $winPb->lblCount->Text($countRow);
    }
    close($fhQueryRes);
  }

}  #--- End writeQueryDBResultTXT

#--------------------------#
sub createReportHTML
#--------------------------#
{
  # Local variables
  my ($fhReport, $refHeaders) = @_;
  print $fhReport "<!DOCTYPE html>\n";
  print $fhReport "<html>\n<head>\n<title>XL-Parser $STR{'report'}</title>\n";
  print $fhReport "<meta charset=\"ISO-8859-1\">\n<style>\n";
  print $fhReport "table, td { border-collapse: collapse; border: 1px solid black; padding: 5px; }\n";
  print $fhReport "td { font-size:11pt; vertical-align: top; white-space: nowrap; }\n";
  print $fhReport ".header { text-align: center; font-weight: bold }\n";
  print $fhReport "</style>\n</head>\n<body>\n";
  print $fhReport "<table style=\"margin: auto;\">\n";
  # Headers
  if (scalar(@{$refHeaders})) {
    print $fhReport "<tr>";
    foreach (@{$refHeaders}) { print $fhReport "<td class=\"header\">$_</td>" }
    print $fhReport "</tr>\n";
  }
  
}  #--- End createReportHTML

#--------------------------#
sub searchDB
#--------------------------#
{
  &createWinSearchSA();
  if (open(my $json, "$REPORTDIR\\CurrentSearchParams-" . $PROCESSID .'.json')) {
    $THR = threads->create(sub {
      # Local variable
      my %searchParams;
      my $refSearchParams = \%searchParams;
      my ($dbh, $sth);
      # Thread 'cancellation' signal handler
      $SIG{'KILL'} = sub {
        # Finish statement handle and disconnect database
        undef $dbh;
        $winPb->ChangeCursor($ARROW);
        threads->exit();
      };
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        # Finish statement handle and disconnect database
        undef $dbh;
        $winPb->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winPb, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      $winPb->ChangeCursor($HOURGLASS);
      my $jsonText = <$json>;
      close($json);
      my $jsonObj = JSON->new;
      $refSearchParams = $jsonObj->decode($jsonText);
      my $nbrTasks = scalar(keys %{$$refSearchParams{selIndicators}});
      # Set progress
      $winPb->pb->SetRange(0, $nbrTasks);
      $winPb->pb->SetPos(0);
      $winPb->pb->SetStep(1);
      $winPb->lblCount->Text("0 / $nbrTasks");
      # Connect to log database
      my $dsn = "DBI:SQLite:dbname=$$refSearchParams{dbFile}";
      $dbh = DBI->connect($dsn, undef, undef, { RaiseError => 1, AutoCommit => 0}) or return(0);
      my $count = 0;
      # Number of entries in database
      my ($nbrEntries) = $dbh->selectrow_array("SELECT value FROM INFO WHERE key == 'nbrLogEntries'");
      # Get results
      my %results;
      foreach my $indicator (keys %{$$refSearchParams{selIndicators}}) {
        $winPb->lblCurr->Text($STR{'Indicator'} . ': ' . $indicator.'...');
        # High number of requests
        if      ($indicator eq $STR{'SDSAI1'}) {
          my $SQLQuery = 'SELECT remoteIP,count(remoteIP) AS Number FROM (SELECT remoteIP FROM LOG) GROUP BY remoteIP HAVING COUNT(remoteIP) > ' .
                         '(SELECT round(avg(Number)) FROM (SELECT remoteIP,count(remoteIP) AS Number FROM (SELECT remoteIP FROM LOG) GROUP BY remoteIP)) ' .
                         'ORDER BY Number DESC LIMIT ' . $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI1'}} = $$refEntryFields[1];
            $index++;
          }
        # Request length (nbr)
        } elsif ($indicator eq $STR{'SDSAI2a'}) {
          my $minLength = $$refSearchParams{selIndicators}{$indicator}{option};
          $minLength    = 50 if !$minLength;
          my $avgLengthRequest = $dbh->selectrow_array('SELECT round(avg(length)) FROM (SELECT length(http_request) ' .
                                                       'AS length FROM LOG GROUP BY length HAVING length > '.$minLength.')');
          my $avgLengthParams = $dbh->selectrow_array('SELECT round(avg(length)) FROM (SELECT length(http_params) ' .
                                                      'AS length FROM LOG GROUP BY length HAVING length > '.$minLength.')');
          $avgLengthRequest = $minLength if !$avgLengthRequest;
          $avgLengthParams  = $minLength if !$avgLengthParams;
          my $SQLQuery;
          $SQLQuery = 'SELECT remoteIP,COUNT(remoteIP) AS number FROM (SELECT id,remoteIP,length(http_request) AS length ' .
                      'FROM LOG GROUP BY remoteIP,length HAVING length > ' . $avgLengthRequest . ' UNION SELECT id,remoteIP,length(http_params) ' .
                      'AS length FROM LOG GROUP BY remoteIP,length HAVING length > ' . $avgLengthParams . ') GROUP BY remoteIP ' .
                      'ORDER BY number DESC LIMIT ' . $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI2a'}} = $$refEntryFields[1];
            $index++;
          }
        # Request length (max)
        } elsif ($indicator eq $STR{'SDSAI2b'}) {
          my $minLength = $$refSearchParams{selIndicators}{$indicator}{option};
          $minLength = 50 if !$minLength;
          my $SQLQuery;
          $SQLQuery = 'SELECT remoteIP,length FROM (SELECT remoteIP,length(http_request) AS length FROM LOG GROUP BY remoteIP,length ' .
                      'HAVING length > ' . $minLength . ' UNION SELECT remoteIP,length(http_params) AS length FROM LOG ' .
                      'GROUP BY remoteIP,length HAVING length > ' . $minLength . ') GROUP BY remoteIP ORDER BY length ' .
                      'DESC LIMIT ' . $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI2b'}} = $$refEntryFields[1];
            $index++;
          }
          # Activities only
          $SQLQuery = 'SELECT COUNT(remoteIP) FROM (SELECT remoteIP,http_request,length(http_request) AS length FROM LOG GROUP BY ' .
                      'remoteIP,length HAVING length > ' . $minLength . ' UNION SELECT remoteIP,http_params,length(http_params) AS ' .
                      'length FROM LOG GROUP BY remoteIP,length HAVING length > ' . $minLength . ')';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          $results{ACTs}{$STR{'SDSAI2b'}} = ($sth->fetchrow_array())[0];
        # URI Encoding
        } elsif ($indicator eq $STR{'SDSAI3'}) {
          my $charList = $$refSearchParams{selIndicators}{$indicator}{option};
          $charList = '%' if !$charList;
          my $SQLQuery;
          $SQLQuery = 'SELECT remoteIP,count(remoteIP) AS Number FROM LOG WHERE http_request REGEXP ' . "'" . $charList . "'" .
                      'OR http_params REGEXP ' . "'" . $charList . "'" . ' GROUP BY remoteIP ORDER BY Number DESC LIMIT ' .
                      $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI3'}} = $$refEntryFields[1];
            $index++;
          }
          # Activities only
          $SQLQuery = 'SELECT COUNT(remoteIP) FROM (SELECT remoteIP,http_request FROM LOG WHERE http_request REGEXP ' . "'" .
                      $charList . "'" . ' OR http_params REGEXP ' . "'" . $charList . "'" . ')';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          $results{ACTs}{$STR{'SDSAI3'}} = ($sth->fetchrow_array())[0];
        # Method
        } elsif ($indicator eq $STR{'SDSAI4'}) {
          my $method = $$refSearchParams{selIndicators}{$indicator}{option};
          $method = 'POST|HEAD|TRACE|OPTIONS|CONNECT' if !$method;
          my $SQLQuery;
          $SQLQuery = 'SELECT remoteIP,count(http_method) AS NumberOf FROM (SELECT remoteIP,http_method FROM LOG WHERE http_method REGEXP ' . "'" .
                      $method . "'" . ') GROUP BY remoteIP ORDER BY NumberOf DESC LIMIT ' . $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI4'}} = $$refEntryFields[1];
            $index++;
          }
          # Activities only
          $SQLQuery = 'SELECT COUNT(remoteIP) FROM (SELECT remoteIP,http_method FROM LOG WHERE http_method REGEXP ' . "'" .
                      $method . "'" . ')';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          $results{ACTs}{$STR{'SDSAI4'}} = ($sth->fetchrow_array())[0];
        # High number of errors
        } elsif ($indicator eq $STR{'SDSAI5'}) {
          my $status = $$refSearchParams{selIndicators}{$indicator}{option};
          $status = '40|50' if !$status;
          my $SQLQuery;
          # By IP address
          $SQLQuery = 'SELECT remoteIP,count(http_status) AS NumberOfErrors FROM (SELECT remoteIP,http_status FROM LOG WHERE http_status REGEXP ' .
                      "'" . $status . "'" . ') GROUP BY remoteIP HAVING NumberOfErrors > 10 ORDER BY NumberOfErrors DESC LIMIT ' .
                      $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI5'}} = $$refEntryFields[1];
            $index++;
          }
          # Activities only
          $SQLQuery = 'SELECT COUNT(remoteIP) FROM (SELECT remoteIP,http_status FROM LOG WHERE http_status REGEXP ' . "'" .
                      $status . "'" . ')';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          $results{ACTs}{$STR{'SDSAI5'}} = ($sth->fetchrow_array())[0];
        # SQL queries
        } elsif ($indicator eq $STR{'SDSAI6'}) {
          my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
          $keywords = '[^\w]union[^\w]|[^\w]select[^\w]' if !$keywords;
          my $SQLQuery;
          $SQLQuery = 'SELECT remoteIP,count(remoteIP) AS Number FROM LOG WHERE http_request REGEXP ' . "'" . $keywords . "'" .
                      ' OR http_params REGEXP ' . "'" . $keywords . "'" . ' OR useragent REGEXP ' . "'" . $keywords . "'" .
                      ' GROUP BY remoteIP ORDER BY Number DESC LIMIT ' .
                      $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI6'}} = $$refEntryFields[1];
            $index++;
          }
          # Activities only
          $SQLQuery = 'SELECT COUNT(remoteIP) FROM (SELECT remoteIP,http_request FROM LOG WHERE http_request REGEXP ' . "'" . $keywords .
                      "'" . ' OR http_params REGEXP ' . "'" . $keywords . "'" . ' OR useragent REGEXP ' . "'" . $keywords . "'" . ')';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          $results{ACTs}{$STR{'SDSAI6'}} = ($sth->fetchrow_array())[0];
        # Use of quotes (or double-quotes)
        } elsif ($indicator eq $STR{'SDSAI7'}) {
          my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
          $keywords = "'|\"|%27|%22" if !$keywords;
          $keywords =~ s/'/''/g;
          my $SQLQuery;
          $SQLQuery = 'SELECT remoteIP,count(remoteIP) AS Number FROM LOG WHERE http_request REGEXP ' . "'" . $keywords . "'" .
                      'OR http_params REGEXP ' . "'" . $keywords . "'" . ' GROUP BY remoteIP ORDER BY Number DESC LIMIT ' .
                      $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI7'}} = $$refEntryFields[1];
            $index++;
          }
          # Activities only
          $SQLQuery = 'SELECT COUNT(remoteIP) FROM (SELECT remoteIP,http_request FROM LOG WHERE http_request REGEXP ' . "'" . $keywords .
                      "'" . ' OR http_params REGEXP ' . "'" . $keywords . "'" . ')';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          $results{ACTs}{$STR{'SDSAI7'}} = ($sth->fetchrow_array())[0];
        # Directory traversal
        } elsif ($indicator eq $STR{'SDSAI8'}) {
          my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
          $keywords = '\\.\\./|\\.\\.%2[Ff]' if !$keywords;
          my $SQLQuery;
          $SQLQuery = 'SELECT remoteIP,count(remoteIP) AS Number FROM LOG WHERE http_request REGEXP ' . "'" . $keywords . "'" .
                      'OR http_params REGEXP ' . "'" . $keywords . "'" . ' GROUP BY remoteIP ORDER BY Number DESC LIMIT ' .
                      $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI8'}} = $$refEntryFields[1];
            $index++;
          }
          # Activities only
          $SQLQuery = 'SELECT COUNT(remoteIP) FROM (SELECT remoteIP,http_request FROM LOG WHERE http_request REGEXP ' . "'" . $keywords .
                      "'" . ' OR http_params REGEXP ' . "'" . $keywords . "'" . ')';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          $results{ACTs}{$STR{'SDSAI8'}} = ($sth->fetchrow_array())[0];
        # Remote file inclusion
        } elsif ($indicator eq $STR{'SDSAI9'}) {
          my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
          $keywords = 'http[:%]' if !$keywords;
          my $SQLQuery;
          $SQLQuery = 'SELECT remoteIP,count(remoteIP) AS Number FROM LOG WHERE http_request REGEXP ' . "'" . $keywords . "'" .
                      'OR http_params REGEXP ' . "'" . $keywords . "'" . ' GROUP BY remoteIP ORDER BY Number DESC LIMIT ' .
                      $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI9'}} = $$refEntryFields[1];
            $index++;
          }
          # Activities only
          $SQLQuery = 'SELECT COUNT(remoteIP) FROM (SELECT remoteIP,http_request FROM LOG WHERE http_request REGEXP ' . "'" . $keywords .
                      "'" . ' OR http_params REGEXP ' . "'" . $keywords . "'" . ')';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          $results{ACTs}{$STR{'SDSAI9'}} = ($sth->fetchrow_array())[0];
        # Admin or login scan
        } elsif ($indicator eq $STR{'SDSAI10'}) {
          my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
          $keywords = 'admin|login' if !$keywords;
          my $SQLQuery;
          $SQLQuery = 'SELECT remoteIP,count(remoteIP) AS Number FROM LOG WHERE http_request REGEXP ' . "'" . $keywords . "'" .
                      'OR http_params REGEXP ' . "'" . $keywords . "'" . ' GROUP BY remoteIP ORDER BY Number DESC LIMIT ' .
                      $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI10'}} = $$refEntryFields[1];
            $index++;
          }
          # Activities only
          $SQLQuery = 'SELECT COUNT(remoteIP) FROM (SELECT remoteIP,http_request FROM LOG WHERE http_request REGEXP ' . "'" . $keywords .
                      "'" . ' OR http_params REGEXP ' . "'" . $keywords . "'" . ')';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          $results{ACTs}{$STR{'SDSAI10'}} = ($sth->fetchrow_array())[0];
        # Web scanner signatures
        } elsif ($indicator eq $STR{'SDSAI11'}) {
          my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
          $keywords = 'havij|sqlmap|nikto|webcruiser|zap|acunetix|dirbuster|zap|WCRTEXTAREATESTINPUT|r3dm0v3|ApacheBench' if !$keywords;
          my $SQLQuery;
          $SQLQuery = 'SELECT remoteIP,count(remoteIP) AS Number FROM (SELECT remoteIP FROM LOG WHERE useragent REGEXP ' . "'" .
                      $keywords . "'" . ' OR http_request REGEXP ' . "'" . $keywords . "'" . ' OR http_params REGEXP ' . "'" .
                      $keywords . "'" . ') GROUP BY remoteIP ORDER BY Number DESC LIMIT ' . $$refSearchParams{selIndicators}{$indicator}{limit};
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $index = 0;
          while (my $refEntryFields = $sth->fetchrow_arrayref()) {
            if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
              $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
              ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
            } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                    ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
            $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI11'}} = $$refEntryFields[1];
            $index++;
          }
          # Activities only
          $SQLQuery = 'SELECT COUNT(remoteIP) FROM (SELECT remoteIP,http_request FROM LOG WHERE http_request REGEXP ' . "'" . $keywords .
                      "'" . ' OR useragent REGEXP ' . "'" . $keywords . "'" . ' OR http_params REGEXP ' . "'" . $keywords . "'" . ')';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          $results{ACTs}{$STR{'SDSAI11'}} = ($sth->fetchrow_array())[0];
        # No useragent
        } elsif ($indicator eq $STR{'SDSAI12'}) {
          my $length = $$refSearchParams{selIndicators}{$indicator}{option};
          $length = 3 if !$length;
          # Activities only
          my $SQLQuery = 'SELECT COUNT(remoteIP) FROM LOG WHERE useragent IS NULL OR length(useragent) < ' . $length;
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          my $nbrRes = ($sth->fetchrow_array())[0];
          if ($nbrRes != $nbrEntries) { # There are useragent in database
            $results{ACTs}{$STR{'SDSAI12'}} = $nbrRes;
            $SQLQuery = 'SELECT remoteIP,COUNT(remoteIP) AS Nbr FROM LOG WHERE useragent IS NULL OR length(useragent) < ' .
                        $length . ' GROUP BY remoteIP ORDER BY Nbr DESC LIMIT ' . $$refSearchParams{selIndicators}{$indicator}{limit};
            $sth = $dbh->prepare($SQLQuery);
            $sth->execute();
            my $index = 0;
            while (my $refEntryFields = $sth->fetchrow_arrayref()) {
              if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
                $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
                ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
              } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                      ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
              $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI12'}} = $$refEntryFields[1];
              $index++;
            }
          } else { delete($$refSearchParams{selIndicators}{$indicator}); }
        # Many useragent
        } elsif ($indicator eq $STR{'SDSAI13'}) {
          my $SQLQuery = 'SELECT COUNT(remoteIP) FROM LOG WHERE useragent IS NOT NULL';
          $sth = $dbh->prepare($SQLQuery);
          $sth->execute();
          if (($sth->fetchrow_array())[0] > 0) { # There are useragent in database
            $SQLQuery = 'SELECT remoteIP,COUNT(DISTINCT useragent) AS Nbr FROM LOG WHERE useragent IS NOT NULL GROUP BY remoteIP ' .
                        'HAVING Nbr > 1 ORDER BY Nbr DESC LIMIT ' . $$refSearchParams{selIndicators}{$indicator}{limit};
            $sth = $dbh->prepare($SQLQuery);
            $sth->execute();
            my $index = 0;
            while (my $refEntryFields = $sth->fetchrow_arrayref()) {
              if (exists($results{ByIPs}{$$refEntryFields[0]}) and exists($results{ByIPs}{$$refEntryFields[0]}{score})) {
                $results{ByIPs}{$$refEntryFields[0]}{score} += $$refSearchParams{selIndicators}{$indicator}{score} *
                ($$refSearchParams{selIndicators}{$indicator}{limit} - $index);
              } else { $results{ByIPs}{$$refEntryFields[0]}{score} = $$refSearchParams{selIndicators}{$indicator}{score} *
                      ($$refSearchParams{selIndicators}{$indicator}{limit} - $index); }
              $results{ByIPs}{$$refEntryFields[0]}{$STR{'SDSAI13'}} = $$refEntryFields[1];
              $index++;
            }
          } else { delete($$refSearchParams{selIndicators}{$indicator}); }
        }
        # Update progress
        $count++;
        $winPb->pb->StepIt();
        $winPb->lblCount->Text("$count / $nbrTasks");
      }
      # Results - By IP address
      my $nbrCols = scalar(keys %{$$refSearchParams{selIndicators}});
      $nbrCols++ if $$refSearchParams{incISP};
      $nbrCols++ if $$refSearchParams{incGeoIP};
      $nbrCols += 3;
      # Grid header
      $winSearchSA->gridResultsSA_IPs->SetColumns($nbrCols);
      $winSearchSA->gridResultsSA_IPs->SetCellText(0, 1, $STR{'LFclientIP'});
      $winSearchSA->gridResultsSA_IPs->SetCellText(0, 2, $STR{'Score'} );
      my $j = 3;
      if ($$refSearchParams{incISP}  ) { $winSearchSA->gridResultsSA_IPs->SetCellText(0, $j, $STR{'isp'}    ); $j++; }
      if ($$refSearchParams{incGeoIP}) { $winSearchSA->gridResultsSA_IPs->SetCellText(0, $j, $STR{'GeoIPDB'}); $j++; }
      my %columnNames;
      foreach my $indicator (sort { $$refSearchParams{selIndicators}{$b}{score} <=> $$refSearchParams{selIndicators}{$a}{score} } keys %{$$refSearchParams{selIndicators}}) {
        if ($indicator ne $STR{'Indicator'}) {
          $columnNames{$indicator} = $j;
          $winSearchSA->gridResultsSA_IPs->SetCellText(0, $j, $indicator);
          $j++;
        }
      }
      $j = 0;
      for (0 .. $nbrCols) { $winSearchSA->gridResultsSA_IPs->SetCellFormat(0, $j, 1); $j++; }
      # Insert results
      my $i = 0;
      foreach my $ip (sort { $results{ByIPs}{$b}{score} <=> $results{ByIPs}{$a}{score}} keys %{$results{ByIPs}}) {
        if (my $newLine = $winSearchSA->gridResultsSA_IPs->InsertRow($ip, -1)) {
          $j = 0;
          $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, 0, $newLine); $j++;
          $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, $j, $ip                        ); $j++;
          $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, $j, $results{ByIPs}{$ip}{score}); $j++;
          if ($$refSearchParams{incISP} or $$refSearchParams{incGeoIP}) {
            my ($isp, $geoIP) = $dbh->selectrow_array('SELECT isp,geoIP FROM IP WHERE ip == ?', undef, $ip);
            if ($$refSearchParams{incISP}   and $isp  ) { $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, $j, $isp  ); $j++; }
            if ($$refSearchParams{incGeoIP} and $geoIP) { $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, $j, $geoIP); $j++; }
          }
          foreach my $col (keys %columnNames) {
            if ($results{ByIPs}{$ip}{$col}) {
              $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, $columnNames{$col}, $results{ByIPs}{$ip}{$col});
            }
          }
          $i++;
          last if $i == $$refSearchParams{maxResults};
        }
      }
      for (1 .. $i) { $winSearchSA->gridResultsSA_IPs->SetCellColor($i--, 2, [255,0,0]);}
      # Activities only
      $winSearchSA->gridResultsSA_ACTs->SetColumns(2);
      $winSearchSA->gridResultsSA_ACTs->SetRows(scalar(keys %{$results{ACTs}})+1);
      # Suspicious activities grid header (Activities only)
      $winSearchSA->gridResultsSA_ACTs->SetCellText(0, 0, $STR{'Indicator'} );
      $winSearchSA->gridResultsSA_ACTs->SetCellText(0, 1, $STR{'ResStatsEntries'});
      $winSearchSA->gridResultsSA_ACTs->SetCellText(1, 0, $STR{'SDSAI2b'} );
      $i = 1;
      foreach my $indicator (sort { $results{ACTs}{$b} <=> $results{ACTs}{$a} } keys %{$results{ACTs}}) {
        $winSearchSA->gridResultsSA_ACTs->SetCellText($i, 0, $indicator);
        if ($results{ACTs}{$indicator}) { $winSearchSA->gridResultsSA_ACTs->SetCellText($i, 1, $results{ACTs}{$indicator}); }
        else                            { $winSearchSA->gridResultsSA_ACTs->SetCellText($i, 1, 0);                          }
        $i++;
      }
      $winSearchSA->gridResultsSA_ACTs->Refresh();
      $winSearchSA->gridResultsSA_ACTs->AutoSize();
      $winSearchSA->gridResultsSA_ACTs->ExpandLastColumn();
      $winSearchSA->Show();
      $winPb->Hide();
      $sth->finish();
      $dbh->disconnect();
      $winPb->ChangeCursor($ARROW);
      # Saved Results to JSON files
      $results{reportDir} = $$refSearchParams{reportDir};
      if (open(my $json, '>:encoding(cp1252)', "$REPORTDIR\\CurrentSearchResults-" . $PROCESSID .'.json')) {
        my $jsonObj = JSON->new;
        my $jsonText = $jsonObj->encode(\%results);
        print $json $jsonText;
        close($json);
      }
      threads->exit();
    });
  }
  
}  #--- End searchDB

#--------------------------#
sub createWinSearchSA
#--------------------------#
{
  # Log Analysis - Search Suspicious Activities
  my $winWidth  = 1000;
  my $winHeight = 400;
  my $winPosX   = ($scrnX - $winWidth)  / 2;
  my $winPosY   = ($scrnY - $winHeight) / 2;
  $winSearchSA = Win32::GUI::Window->new( -name        => 'winSearchSA'          ,
                                          -background  => [255, 255, 255]        ,
                                          -text        => $STR{'SearchSA'}       ,
                                          -pos         => [$winPosX, $winPosY]   ,
                                          -size        => [1000, 400]            ,
                                          -hasmaximize => 1                      ,
                                          -hasminimize => 1                      ,
                                          -resizable   => 1                      ,
                                          -dialogui    => 1                      , );
  $winSearchSA->SetIcon($winICO);
  $winSearchSA->AddLabel(       -name         => 'lblLogo'               ,
                                -size         => [128,128]               ,
                                -pos          => [  0, 10]               ,
                                -bitmap       => $logo128Bmp             ,
                                -background   => [255, 255, 255]         , );
  $winSearchSA->AddRadioButton( -name         => 'rbLASearchSA_IPs'      ,
                                -size         => [140, 22]               ,
                                -pos          => [140,  5]               ,
                                -background   => [255, 255, 255]         ,
                                -text         => $STR{'byIPS'}           ,
                                -font         => $font10                 ,
                                -group        => 1                       ,
                                -checked      => 1                       , );
  $winSearchSA->AddRadioButton( -name         => 'rbLASearchSA_ACTs'     ,
                                -size         => [140, 22]               ,
                                -pos          => [285,  5]               ,
                                -background   => [255, 255, 255]         ,
                                -text         => $STR{'Activities'}      ,
                                -font         => $font10                 , );
  $winSearchSA->AddButton(      -name         => 'btnLASearchSA_SaveRes' ,
                                -text         => $STR{'SaveResults'}.'...',
                                -font         => $font10                 ,
                                -size         => [100, 26]               ,
                                -pos          => [500,  5]               , );
  $winSearchSA->AddGrid(        -name         => 'gridResultsSA_IPs'     ,
                                -pos          => [140, 35]               ,
                                -size         => [780,230]               ,
                                -background   => [255, 255, 255]         ,
                                -fixedrows    => 1                       ,
                                -fixedcolumns => 1                       ,
                                -editable     => 0                       , );
  $winSearchSA->gridResultsSA_IPs->SetListMode(1);
  $winSearchSA->AddGrid(        -name         => 'gridResultsSA_ACTs'    ,
                                -pos          => [140, 35]               ,
                                -size         => [780,230]               ,
                                -background   => [255, 255, 255]         ,
                                -fixedrows    => 1                       ,
                                -fixedcolumns => 0                       ,
                                -editable     => 0                       ,
                                -visible      => 0                       , );
  $winSearchSA->gridResultsSA_ACTs->SetListMode(1);
  # Popup menu for Suspicious activities grid (By IP)
  $gridSearchSA_IPsMenu = new Win32::GUI::Menu(
    'gridSearchSA_IPsMenu'        => 'gridSearchSA_IPsMenu',
    "> $STR{'SA_GetRequests'}..." => { -name => 'SA_GetRequests' , -default => 1 },
    "> $STR{'SA_GetUA'}"          => 'SA_GetUA'        ,
    " > -" => 0,
    "> $STR{'SA_ResIPs'}"         => 'SA_ResIPs'       ,
    "> $STR{'SA_GetUnknownIPs'}"  => 'SA_GetUnknownIPs',
    " > -" => 0,
    "> $STR{'selectAll'}"         => 'SA_SelectAll'    ,
    "> $STR{'copySelRow'}"        => 'SA_CopySelRow'   ,
  );
  # Popup menu for Suspicious activities grid (Activities only)
  $gridSearchSA_ACTsMenu = new Win32::GUI::Menu(
    'gridSearchSA_ACTsMenu'       => 'gridSearchSA_ACTsMenu',
    "> $STR{'SA_GetReqInd'}..."   => { -name => 'SA_GetReqInd' , -default => 1 },
  );
  
}  #--- End createWinSearchSA

#--------------------------#
sub winSearchSA_Resize
#--------------------------#
{
  $winSearchSA->btnLASearchSA_SaveRes->Left($winSearchSA->ScaleWidth()-105);
  $winSearchSA->gridResultsSA_IPs->Width($winSearchSA->ScaleWidth()-145);
  $winSearchSA->gridResultsSA_IPs->Height($winSearchSA->ScaleHeight()-40);
  $winSearchSA->gridResultsSA_IPs->AutoSize();
  $winSearchSA->gridResultsSA_IPs->ExpandLastColumn();
  $winSearchSA->gridResultsSA_ACTs->Width($winSearchSA->ScaleWidth()-145);
  $winSearchSA->gridResultsSA_ACTs->Height($winSearchSA->ScaleHeight()-40);
  $winSearchSA->gridResultsSA_ACTs->AutoSize();
  $winSearchSA->gridResultsSA_ACTs->ExpandLastColumn();
  return(0);

}  #--- End winSearchSA_Resize

#--------------------------#
sub btnLASearchSA_SaveRes_Click
#--------------------------#
{
  my $refSearchParams;
  if (open(my $json, "$REPORTDIR\\CurrentSearchParams-" . $PROCESSID .'.json')) {
    my $jsonText = <$json>;
    close($json);
    my $jsonObj      = JSON->new;
    $refSearchParams = $jsonObj->decode($jsonText);
    $$refSearchParams{procID} = $PROCESSID;
  }
  my $filename;
  if ($$refSearchParams{dbFile} =~ /\\([^\\]+)\.db/) { $filename = $1 . '_SA_Results.json';     }
  else                                               { $filename = 'XL-Parser_SA_Results.json'; }
  if (my $resFile = Win32::GUI::GetSaveFileName(-owner     => $winSearchSA,
                                                -title     => $STR{'selFile'}.':',
                                                -file      => $filename,
                                                -filter    => ["JSON files (*.json)", '*.json'] ,
                                                -directory => $REPORTDIR,
                                                -overwriteprompt  => 1,
                                                -explorer  => 1)) {
    $THR = threads->create(sub {
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        $winPb->lblCurr->Text('');
        $winPb->lblCount->Text('');
        $winPb->pb->Hide();
        $winPb->Hide();
        $winPb->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winSearchSA, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      # Progress
      $winPb->Show();
      $winPb->pb->Show();
      $winPb->pb->SetRange(0, 2);
      $winPb->pb->SetPos(0);
      $winPb->pb->SetStep(1);
      $winPb->lblCount->Text('0 / 2');
      $winPb->ChangeCursor($HOURGLASS);
      # Load results
      $winPb->lblCurr->Text($STR{'LoadingResults'}.'...');
      my $refResults;
      if (open(my $json, "$REPORTDIR\\CurrentSearchResults-" . $PROCESSID .'.json')) {
        my $jsonText = <$json>;
        close($json);
        my $jsonObj = JSON->new;
        $refResults = $jsonObj->decode($jsonText);
      }
      $winPb->lblCount->Text('1 / 2');
      $winPb->pb->StepIt();
      $winPb->lblCurr->Text($STR{'SavingResults'}.'...');
      # Saved Results to JSON files
      my %mergedHash = (%$refSearchParams, %$refResults);
      if (open(my $json, '>:encoding(cp1252)', $resFile)) {
        my $jsonObj  = JSON->new;
        my $jsonText = $jsonObj->encode(\%mergedHash);
        print $json $jsonText;
        close($json);
        $winPb->lblCount->Text('2 / 2');
        $winPb->pb->StepIt();
        $winPb->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winSearchSA, "$STR{'ResultsSaved'}!", "XL-Parser $VERSION", 0x40040);
      } else {
        $winPb->lblCount->Text('2 / 2');
        $winPb->pb->StepIt();
        $winPb->ChangeCursor($ARROW);
      }
      # Progress
      $winPb->lblCurr->Text('');
      $winPb->lblCount->Text('');
      $winPb->pb->Hide();
      $winPb->Hide();
    });
  }
  return(1);

}  #--- End btnLASearchSA_SaveRes_Click

#--------------------------#
sub rbLASearchSA_IPs_Click
#--------------------------#
{
  $winSearchSA->gridResultsSA_IPs->Show();
  $winSearchSA->gridResultsSA_ACTs->Hide();

}  #--- End rbLASearchSA_IPs_Click

#--------------------------#
sub rbLASearchSA_ACTs_Click
#--------------------------#
{
  $winSearchSA->gridResultsSA_ACTs->Show();
  $winSearchSA->gridResultsSA_IPs->Hide();

}  #--- End rbLASearchSA_ACTs_Click

#--------------------------#
sub gridResultsSA_IPs_Click
#--------------------------#
{
  # Sort rows
  my ($row, $column) = @_;
  if (!$row) {
    $winSearchSA->gridResultsSA_IPs->SetHeaderSort();
    my $order = $winSearchSA->gridResultsSA_IPs->GetSortAscending();
    my $colHeaderName = $winSearchSA->gridResultsSA_IPs->GetCellText($row, $column);
    # Sort IPs
    if ($colHeaderName eq $STR{'LFclientIP'}) { $winSearchSA->gridResultsSA_IPs->SortCells($column, $order, \&sortIP); }
    # Else, numerical sort
    else { $winSearchSA->gridResultsSA_IPs->SortCells($column, $order, sub { my ($e1, $e2) = @_;
                                                                             $e1 = 0 if !$e1;
                                                                             $e2 = 0 if !$e2;
                                                                             return ($e1 <=> $e2); }); }
    $winSearchSA->gridResultsSA_IPs->Refresh();
    $winSearchSA->gridResultsSA_IPs->AutoSize();
    $winSearchSA->gridResultsSA_IPs->ExpandLastColumn();
    my $currWidth = $winSearchSA->gridResultsSA_IPs->GetColumnWidth($column);
    $winSearchSA->gridResultsSA_IPs->SetColumnWidth($column, $currWidth+10);
  }

}  #--- End gridResultsSA_IPs_Click

#--------------------------#
sub gridResultsSA_IPs_DblClick
#--------------------------#
{
  my ($row, $column) = @_;
  if ($row) { &SA_GetRequests_Click($row, $column); }
  
}   #--- End gridResultsSA_IPs_DblClick

#--------------------------#
sub gridResultsSA_ACTs_DblClick
#--------------------------#
{
  my ($row, $column) = @_;
  if ($row) { &SA_GetReqInd_Click($row, $column); }
  
}   #--- End gridResultsSA_ACTs_DblClick

#--------------------------#
sub gridResultsSA_IPs_RClick
#--------------------------#
{
  # Show popup menu
  my ($row, $column) = @_;
  my (@coord) = $winSearchSA->gridResultsSA_IPs->GetSelectedCellRange();
  # Select the right entry if not selected or select has change
  $winSearchSA->gridResultsSA_IPs->SetSelectedCellRange($row, 0, $row, $winSearchSA->gridResultsSA_IPs->GetColumns()-1)
  if (($coord[0] and ($row < $coord[0])) or ($coord[2] and ($row > $coord[2])) or !$coord[0]);
  my ($X, $Y) = Win32::GUI::GetCursorPos();
  $winSearchSA->TrackPopupMenu($gridSearchSA_IPsMenu->{gridSearchSA_IPsMenu},$X,$Y);

}  #--- End gridResultsSA_IPs_RClick

#--------------------------#
sub gridResultsSA_ACTs_RClick
#--------------------------#
{
  # Show popup menu
  my ($row, $column) = @_;
  my (@coord) = $winSearchSA->gridResultsSA_ACTs->GetSelectedCellRange();
  # Select the right entry if not selected or select has change
  $winSearchSA->gridResultsSA_ACTs->SetSelectedCellRange($row, 0, $row, $winSearchSA->gridResultsSA_ACTs->GetColumns()-1)
  if (($coord[0] and ($row < $coord[0])) or ($coord[2] and ($row > $coord[2])) or !$coord[0]);
  my ($X, $Y) = Win32::GUI::GetCursorPos();
  $winSearchSA->TrackPopupMenu($gridSearchSA_ACTsMenu->{gridSearchSA_ACTsMenu},$X,$Y);

}  #--- End gridResultsSA_ACTs_RClick

#--------------------------#
sub SA_GetRequests_Click
#--------------------------#
{
  # Local variables
  my ($row, $column) = @_;
  my (@coord)        = $winSearchSA->gridResultsSA_IPs->GetSelectedCellRange();
  # Selected IPs
  my @listIPs;
  my $lastSelectedRow; 
  if ($coord[2]) { $lastSelectedRow = $coord[2]; }
  else           { $lastSelectedRow = $coord[0]; }
  for (my $row = $coord[0]; $row <= $lastSelectedRow; $row++) {
    push(@listIPs, $winSearchSA->gridResultsSA_IPs->GetCellText($row, 1)) if $winSearchSA->gridResultsSA_IPs->IsCellSelected($row, 1);
  }
  my $json;
  if (open($json, "$REPORTDIR\\CurrentSearchParams-" . $PROCESSID .'.json') or open($json, $$REF_ARG[3])) {
    my $jsonText = <$json>;
    close($json);
    my $jsonObj = JSON->new;
    my $refSearchParams = $jsonObj->decode($jsonText);
    # Set SQLQuery beginning based on selected columns
    my $SQLQuerySelect;
    $SQLQuerySelect  = 'SELECT ';
    $SQLQuerySelect .= 'DISTINCT ' if $$refSearchParams{DISTINCT};
    my $columns;
    # All columns
    if ($$refSearchParams{cols}{ALL}) {
      if ($$refSearchParams{cols}{COUNT}) { $columns = 'COUNT(*) '; }
      else { $columns = '* '; }
    # Selected columns
    } else {
      foreach (my $i = 1; $i < 13; $i++) {
        if ($$refSearchParams{cols}{$i}) {
          if ($$refSearchParams{cols}{$i}{COUNT}) {
            $columns .= 'COUNT('.$$refSearchParams{cols}{$i}{colName}.'),';
          } else { $columns .= $$refSearchParams{cols}{$i}{colName}.','; }
        }
      }
      if ($columns) {
        chop($columns);
        $columns .= ' ';
      }
    }
    $SQLQuerySelect .= $columns;
    my $SQLQuery     = $SQLQuerySelect . 'FROM (SELECT * FROM LOG WHERE remoteIP REGEXP ' . "'";
    foreach (@listIPs) { $SQLQuery .= $_ . '|'; }
    chop($SQLQuery);
    $$refSearchParams{query} = $SQLQuery . "')";
    my $procID               = time;
    if (open(my $json, '>:encoding(cp1252)', "$REPORTDIR\\CurrentQueryParams-" . $procID .'.json')) {
      my $jsonObj = JSON->new;
      my $jsonText = $jsonObj->encode($refSearchParams);
      print $json $jsonText;
      close($json);
      # Start a new Query Database process
      my $command = 'XL-Parser-process ' . "LADB-Query $procID \"$PROGDIR\" \"$REPORTDIR\" \"$USERDIR\"";
      Win32::Process::Create(my $processObj, $PROGDIR .'\XL-Parser-process.exe', $command, 0, NORMAL_PRIORITY_CLASS, $PROGDIR);
    }
  }
  
}  #--- End SA_GetRequests_Click

#--------------------------#
sub SA_GetUA_Click
#--------------------------#
{
  # Local variables
  my (@coord) = $winSearchSA->gridResultsSA_IPs->GetSelectedCellRange();
  # Selected IPs
  my @listIPs;
  my $lastSelectedRow; 
  if ($coord[2]) { $lastSelectedRow = $coord[2]; }
  else           { $lastSelectedRow = $coord[0]; }
  for (my $row = $coord[0]; $row <= $lastSelectedRow; $row++) {
    push(@listIPs, $winSearchSA->gridResultsSA_IPs->GetCellText($row, 1)) if $winSearchSA->gridResultsSA_IPs->IsCellSelected($row, 1);
  }
  my $json;
  if (open($json, "$REPORTDIR\\CurrentSearchParams-" . $PROCESSID .'.json') or open($json, $$REF_ARG[3])) {
    my $jsonText = <$json>;
    close($json);
    my $jsonObj = JSON->new;
    my $refQueryParams = $jsonObj->decode($jsonText);
    my $SQLQuery = 'SELECT DISTINCT useragent FROM LOG WHERE remoteIP REGEXP ' . "'";
    foreach (@listIPs) { $SQLQuery .= $_ . '|'; }
    chop($SQLQuery);
    $$refQueryParams{query}        = $SQLQuery . "'";
    $$refQueryParams{incUADetails} = 1;
    my $procID                     = time;
    if (open(my $json, '>:encoding(cp1252)', "$REPORTDIR\\CurrentQueryParams-" . $procID .'.json')) {
      my $jsonObj  = JSON->new;
      my $jsonText = $jsonObj->encode($refQueryParams);
      print $json $jsonText;
      close($json);
      # Start a new Query Database process
      my $command = 'XL-Parser-process ' . "LADB-Query $procID \"$PROGDIR\" \"$REPORTDIR\" \"$USERDIR\"";
      Win32::Process::Create(my $processObj, $PROGDIR .'\XL-Parser-process.exe', $command, 0, NORMAL_PRIORITY_CLASS, $PROGDIR);
    }
  }
  
}  #--- End SA_GetUA_Click

#--------------------------#
sub SA_ResIPs_Click
#--------------------------#
{
  my %headers;
  # Get column headers
  for (my $i = 0; $i < $winSearchSA->gridResultsSA_IPs->GetColumns(); $i++) {
    $headers{$winSearchSA->gridResultsSA_IPs->GetCellText(0, $i)} = $i;
  }
  # Insert ISP column if doesn't exist
  if (!exists($headers{$STR{'isp'}})    ) {
    $winSearchSA->gridResultsSA_IPs->InsertColumn($STR{'isp'}, 0, 3);
    $winSearchSA->gridResultsSA_IPs->SetCellFormat(0, 3, 1);
  }
  # Insert GeoIP column if doesn't exist
  if (!exists($headers{$STR{'GeoIPDB'}})) {
    $winSearchSA->gridResultsSA_IPs->InsertColumn($STR{'GeoIPDB'}, 0, 4);
    $winSearchSA->gridResultsSA_IPs->SetCellFormat(0, 4, 1);
  }
  # Populate new columns
  my $json;
  if (open($json, "$REPORTDIR\\CurrentSearchParams-" . $PROCESSID .'.json') or open($json, $$REF_ARG[3])) {
    $THR = threads->create(sub {
      # Local variable
      my %searchParams;
      my $refSearchParams = \%searchParams;
      my $dbhWhoisDB;
      # Thread 'cancellation' signal handler
      $SIG{'KILL'} = sub {
        # Finish statement handle and disconnect database
        $dbhWhoisDB = undef;
        $winSearchSA->ChangeCursor($ARROW);
        threads->exit();
      };
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        # Finish statement handle and disconnect database
        $dbhWhoisDB = undef;
        $winSearchSA->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winPb, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      $winSearchSA->ChangeCursor($HOURGLASS);
      my $jsonText = <$json>;
      close($json);
      my $jsonObj = JSON->new;
      $refSearchParams = $jsonObj->decode($jsonText);
      # Open and load config values
      my ($XLWHOIS_DB_FILE, $GEOIP_DB_FILE);
      if (open(CONFIG, "$USERDIR\\XL-Parser.ini")) {
        while (<CONFIG>) {
          if    (/^XLWHOIS_DB_FILE = ([^\n]+)/) { $XLWHOIS_DB_FILE = $1; }
          elsif (/^GEOIP_DB_FILE = ([^\n]+)/  ) { $GEOIP_DB_FILE   = $1; }
        }
        close(CONFIG);
      }
      # Connect to XL-Whois Database
      if ($XLWHOIS_DB_FILE) {
        $XLWHOIS_DB_FILE = encode('utf8', $XLWHOIS_DB_FILE);
        my $dsn          = "DBI:SQLite:dbname=$XLWHOIS_DB_FILE";
        $dbhWhoisDB = DBI->connect($dsn, undef, undef, { RaiseError => 1, AutoCommit => 1 });
      }
      # Connect to GeoIP Database
      my $geoIPDB;
      $geoIPDB = Geo::IP->open($GEOIP_DB_FILE, GEOIP_MEMORY_CACHE) if $GEOIP_DB_FILE;
      for (my $i = 1; $i < $winSearchSA->gridResultsSA_IPs->GetRows(); $i++) {
        my $ip = $winSearchSA->gridResultsSA_IPs->GetCellText($i, 1);
        if ($dbhWhoisDB) { # Resolve ISP
          my $isp = &resolveISP($ip, \$dbhWhoisDB);
          $isp = 'unknown' if !$isp;
          $winSearchSA->gridResultsSA_IPs->SetCellText($i, 3, $isp  );
        }
        if ($geoIPDB) { # Resolve GeoIP
          my $geoIP = &resolveGeoIP($ip, \$geoIPDB);
          $geoIP = 'unknown' if !$geoIP;
          $winSearchSA->gridResultsSA_IPs->SetCellText($i, 4, $geoIP);
        }
      }
      $dbhWhoisDB = undef;
      $winSearchSA->ChangeCursor($ARROW);
      # Update grid
      $winSearchSA->gridResultsSA_IPs->Refresh();
      $winSearchSA->gridResultsSA_IPs->AutoSize();
      $winSearchSA->gridResultsSA_IPs->ExpandLastColumn();
    });
  } # Couldn't open json

}  #--- End SA_ResIPs_Click

#--------------------------#
sub SA_GetUnknownIPs_Click
#--------------------------#
{
  # ISP column must exist
  if ($winSearchSA->gridResultsSA_IPs->GetCellText(0, 3) eq $STR{'isp'}) {
    # Get unknown IPs list based on unknown ISP(s)
    my $content;
    for (my $i = 1; $i < $winSearchSA->gridResultsSA_IPs->GetRows(); $i++) {
      $content .= $winSearchSA->gridResultsSA_IPs->GetCellText($i, 1) . "\r\n" if $winSearchSA->gridResultsSA_IPs->GetCellText($i, 3) eq 'unknown';
    }
    # If there are unknown ISP(s)
    Win32::Clipboard::Set($content) if $content;
  }
  
}  #--- End SA_GetUnknownIPs_Click

#--------------------------#
sub SA_SelectAll_Click
#--------------------------#
{
  $winSearchSA->gridResultsSA_IPs->OnEditSelectAll();
  return(1);
  
}  #--- End SA_SelectAll_Click

#--------------------------#
sub SA_CopySelRow_Click
#--------------------------#
{
  my (@coord) = $winSearchSA->gridResultsSA_IPs->GetSelectedCellRange();
  my $content;
  # Selected IPs
  my @listIPs;
  my $lastSelectedRow; 
  if ($coord[2]) { $lastSelectedRow = $coord[2]; }
  else           { $lastSelectedRow = $coord[0]; }
  # Header is always inserted
  for (my $col = 0; $col <= $winSearchSA->gridResultsSA_IPs->GetColumns(); $col++) {
    $content .= $winSearchSA->gridResultsSA_IPs->GetCellText(0, $col) . "\t";
  }
  chop($content);
  $content .= "\r\n";
  for (my $row = $coord[0]; $row <= $lastSelectedRow; $row++) {
    if ($winSearchSA->gridResultsSA_IPs->IsCellSelected($row, 1)) {
      for (my $col = 0; $col <= $winSearchSA->gridResultsSA_IPs->GetColumns(); $col++) {
        $content .= $winSearchSA->gridResultsSA_IPs->GetCellText($row, $col) . "\t";
      }
      chop($content);
      $content .= "\r\n";
    }
  }
  Win32::Clipboard::Set($content) if $content;
  return(1);
  
}  #--- End SA_CopySelRow_Click

#--------------------------#
sub SA_GetReqInd_Click
#--------------------------#
{
  # Local variables
  my ($row, $column) = @_;
  my (@coord) = $winSearchSA->gridResultsSA_ACTs->GetSelectedCellRange();
  # Selected indicator
  my @listIndicators;
  my $lastSelectedRow; 
  if ($coord[2]) { $lastSelectedRow = $coord[2]; }
  else           { $lastSelectedRow = $coord[0]; }
  for (my $row = $coord[0]; $row <= $lastSelectedRow; $row++) {
    push(@listIndicators, $winSearchSA->gridResultsSA_ACTs->GetCellText($row, 0)) if $winSearchSA->gridResultsSA_ACTs->IsCellSelected($row, 0);
  }
  my $json;
  if (open($json, "$REPORTDIR\\CurrentSearchParams-" . $PROCESSID .'.json') or open($json, $$REF_ARG[3])) {
    my $jsonText = <$json>;
    close($json);
    my $jsonObj = JSON->new;
    my $refSearchParams = $jsonObj->decode($jsonText);
    # Set SQLQuery beginning based on selected columns (Activities only)
    my $SQLQuerySelect;
    $SQLQuerySelect  = 'SELECT ';
    $SQLQuerySelect .= 'DISTINCT ' if $$refSearchParams{DISTINCT};
    my $columns;
    # All columns
    if ($$refSearchParams{cols}{ALL}) {
      if ($$refSearchParams{cols}{COUNT}) { $columns = 'COUNT(*) '; }
      else { $columns = '* '; }
    # Selected columns
    } else {
      foreach (my $i = 1; $i < 13; $i++) {
        if ($$refSearchParams{cols}{$i}) {
          if ($$refSearchParams{cols}{$i}{COUNT}) {
            $columns .= 'COUNT('.$$refSearchParams{cols}{$i}{colName}.'),';
          } else { $columns .= $$refSearchParams{cols}{$i}{colName}.','; }
        }
      }
      if ($columns) {
        chop($columns);
        $columns .= ' ';
      }
    }
    $SQLQuerySelect .= $columns;
    $$refSearchParams{replReport} = 0 if scalar(@listIndicators) > 1;
    foreach my $indicator (@listIndicators) {
      my $SQLQuery = $SQLQuerySelect;
      if      ($indicator eq $STR{'SDSAI2b'}) { # Request length
        my $minLength = $$refSearchParams{selIndicators}{$indicator}{option};
        $SQLQuery .= 'FROM (SELECT *,length(http_request) AS length FROM LOG GROUP BY remoteIP,length HAVING length > ' .
                      $minLength . ' UNION SELECT *,length(http_params) AS length FROM LOG GROUP BY remoteIP,length HAVING length > ' .
                      $minLength . ')';
      } elsif ($indicator eq $STR{'SDSAI3'}) { # URI Encoding
        my $charList = $$refSearchParams{selIndicators}{$indicator}{option};
        $SQLQuery .= 'FROM (SELECT * FROM LOG WHERE http_request REGEXP ' . "'" . $charList . "'" . 
                     ' UNION SELECT * FROM LOG WHERE http_params REGEXP ' . "'" . $charList . "'" . ')';
      } elsif ($indicator eq $STR{'SDSAI4'}) { # Method
        my $method = $$refSearchParams{selIndicators}{$indicator}{option};
        $SQLQuery .= 'FROM (SELECT * FROM LOG WHERE http_method REGEXP ' . "'" . $method . "'" . ')';
      } elsif ($indicator eq $STR{'SDSAI5'}) { # High number of errors
        my $status = $$refSearchParams{selIndicators}{$indicator}{option};
        $SQLQuery .= 'FROM (SELECT * FROM LOG WHERE http_status REGEXP ' . "'" . $status . "'" . ')';
      } elsif ($indicator eq $STR{'SDSAI6'}) { # SQL queries
        my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
        $SQLQuery .= 'FROM (SELECT * FROM LOG WHERE http_request REGEXP '  . "'" . $keywords . "'" . 
                      ' UNION SELECT * FROM LOG WHERE http_params REGEXP ' . "'" . $keywords . "'" .
                      ' UNION SELECT * FROM LOG WHERE useragent REGEXP '   . "'" . $keywords . "'" .')';
      } elsif ($indicator eq $STR{'SDSAI7'}) { # Use of quotes (or double-quotes)
        my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
        $keywords =~ s/'/''/g;
        $SQLQuery .= 'FROM (SELECT * FROM LOG WHERE http_request REGEXP ' . "'" . $keywords . "'" . 
                     ' UNION SELECT * FROM LOG WHERE http_params REGEXP ' . "'" . $keywords . "'" . ')';
      } elsif ($indicator eq $STR{'SDSAI8'}) { # Directory traversal
        my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
        $SQLQuery .= 'FROM (SELECT * FROM LOG WHERE http_request REGEXP ' . "'" . $keywords . "'" . 
                     ' UNION SELECT * FROM LOG WHERE http_params REGEXP ' . "'" . $keywords . "'" . ')';
      } elsif ($indicator eq $STR{'SDSAI9'}) { # Remote file inclusion
        my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
        $SQLQuery .= 'FROM (SELECT * FROM LOG WHERE http_request REGEXP ' . "'" . $keywords . "'" . 
                     ' UNION SELECT * FROM LOG WHERE http_params REGEXP ' . "'" . $keywords . "'" . ')';
      } elsif ($indicator eq $STR{'SDSAI10'}) { # Admin or login scan
        my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
        $SQLQuery .= 'FROM (SELECT * FROM LOG WHERE http_request REGEXP ' . "'" . $keywords . "'" . 
                     ' UNION SELECT * FROM LOG WHERE http_params REGEXP ' . "'" . $keywords . "'" . ')';
      } elsif ($indicator eq $STR{'SDSAI11'}) { # Web scanner signatures
        my $keywords = $$refSearchParams{selIndicators}{$indicator}{option};
        $SQLQuery .= 'FROM (SELECT * FROM LOG WHERE http_request REGEXP ' . "'" . $keywords . "'" .
                     ' UNION SELECT * FROM LOG WHERE http_params REGEXP ' . "'" . $keywords . "'" .
                     ' UNION SELECT * FROM LOG WHERE useragent REGEXP '   . "'" . $keywords . "'" . ')';
      } elsif ($indicator eq $STR{'SDSAI12'}) { # No useragent
        my $length = $$refSearchParams{selIndicators}{$indicator}{option};
        $SQLQuery .= 'FROM (SELECT * FROM LOG WHERE useragent IS NULL OR length(useragent) < ' . $length . ')';
      }
      $$refSearchParams{query} = $SQLQuery;
      my $procID               = time;
      if (open(my $json, '>:encoding(cp1252)', "$REPORTDIR\\CurrentQueryParams-" . $procID .'.json')) {
        my $jsonObj = JSON->new;
        my $jsonText = $jsonObj->encode($refSearchParams);
        print $json $jsonText;
        close($json);
        # Start a new Query Database process
        my $command = 'XL-Parser-process ' . "LADB-Query $procID \"$PROGDIR\" \"$REPORTDIR\" \"$USERDIR\"";
        Win32::Process::Create(my $processObj, $PROGDIR .'\XL-Parser-process.exe', $command, 0, NORMAL_PRIORITY_CLASS, $PROGDIR);
        $processObj->Wait(1000);
      }
    }
  }
  
}  #--- End SA_GetReqInd_Click

#--------------------------#
sub SAResults
#--------------------------#
{
  &createWinSearchSA();
  $winPb->Hide();
  $winSearchSA->btnLASearchSA_SaveRes->Disable();
  if ($$REF_ARG[3] and open(my $json, $$REF_ARG[3])) {
    $THR = threads->create(sub {
      # Local variable
      my $dbh;
      my %results;
      my $refResults = \%results;
      # Thread 'cancellation' signal handler
      $SIG{'KILL'} = sub {
        undef $dbh;
        threads->exit();
      };
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        undef $dbh;
        Win32::GUI::MessageBox($winSearchSA, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      my $jsonText = <$json>;
      close($json);
      my $jsonObj = JSON->new;
      $refResults = $jsonObj->decode($jsonText);
      # Results - By IP address
      my $nbrCols = scalar(keys %{$$refResults{selIndicators}});
      $nbrCols++ if $$refResults{incISP};
      $nbrCols++ if $$refResults{incGeoIP};
      $nbrCols += 3;
      # Grid header
      $winSearchSA->gridResultsSA_IPs->SetColumns($nbrCols);
      $winSearchSA->gridResultsSA_IPs->SetCellText(0, 1, $STR{'LFclientIP'});
      $winSearchSA->gridResultsSA_IPs->SetCellText(0, 2, $STR{'Score'} );
      my $j = 3;
      if ($$refResults{incISP}  ) { $winSearchSA->gridResultsSA_IPs->SetCellText(0, $j, $STR{'isp'}    ); $j++; }
      if ($$refResults{incGeoIP}) { $winSearchSA->gridResultsSA_IPs->SetCellText(0, $j, $STR{'GeoIPDB'}); $j++; }
      my %columnNames;
      foreach my $indicator (sort keys %{$$refResults{selIndicators}}) {
        if ($indicator ne $STR{'Indicator'}) {
          $columnNames{$indicator} = $j;
          $winSearchSA->gridResultsSA_IPs->SetCellText(0, $j, $indicator);
          $j++;
        }
      }
      $j = 0;
      for (0 .. $nbrCols) { $winSearchSA->gridResultsSA_IPs->SetCellFormat(0, $j, 1); $j++; }
      # Connect to log database
      if ($$refResults{incISP} or $$refResults{incGeoIP}) {
        my $dsn = "DBI:SQLite:dbname=$$refResults{dbFile}";
        $dbh = DBI->connect($dsn, undef, undef, { RaiseError => 1});
      }
      # Insert results
      my $i = 0;
      foreach my $ip (sort { $$refResults{ByIPs}{$b}{score} <=> $$refResults{ByIPs}{$a}{score}} keys %{$$refResults{ByIPs}}) {
        if (my $newLine = $winSearchSA->gridResultsSA_IPs->InsertRow($ip, -1)) {
          $j = 0;
          $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, 0, $newLine); $j++;
          $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, $j, $ip                            ); $j++;
          $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, $j, $$refResults{ByIPs}{$ip}{score}); $j++;
          if ($$refResults{incISP} or $$refResults{incGeoIP}) {
            my ($isp, $geoIP) = $dbh->selectrow_array('SELECT isp,geoIP FROM IP WHERE ip == ?', undef, $ip);
            if ($$refResults{incISP}  ) { $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, $j, $isp  ); $j++; }
            if ($$refResults{incGeoIP}) { $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, $j, $geoIP); $j++; }
          }
          foreach my $col (keys %columnNames) {
            if ($$refResults{ByIPs}{$ip}{$col}) {
              $winSearchSA->gridResultsSA_IPs->SetCellText($newLine, $columnNames{$col}, $$refResults{ByIPs}{$ip}{$col});
            }
          }
          $i++;
          last if $i == $$refResults{maxResults};
        }
      }
      undef $dbh;
      for (1 .. $i) { $winSearchSA->gridResultsSA_IPs->SetCellColor($i--, 2, [255,0,0]);}
      # Activities only
      $winSearchSA->gridResultsSA_ACTs->SetColumns(2);
      $winSearchSA->gridResultsSA_ACTs->SetRows(scalar(keys %{$$refResults{ACTs}})+1);
      # Suspicious activities grid header (Activities only)
      $winSearchSA->gridResultsSA_ACTs->SetCellText(0, 0, $STR{'Indicator'} );
      $winSearchSA->gridResultsSA_ACTs->SetCellText(0, 1, $STR{'ResStatsEntries'});
      $winSearchSA->gridResultsSA_ACTs->SetCellText(1, 0, $STR{'SDSAI2b'} );
      $i = 1;
      foreach my $indicator (sort { $$refResults{ACTs}{$b} <=> $$refResults{ACTs}{$a} } keys %{$$refResults{ACTs}}) {
        $winSearchSA->gridResultsSA_ACTs->SetCellText($i, 0, $indicator);
        if ($$refResults{ACTs}{$indicator}) { $winSearchSA->gridResultsSA_ACTs->SetCellText($i, 1, $$refResults{ACTs}{$indicator}); }
        else                                { $winSearchSA->gridResultsSA_ACTs->SetCellText($i, 1, 0);                          }
        $i++;
      }
      $winSearchSA->gridResultsSA_ACTs->Refresh();
      $winSearchSA->gridResultsSA_ACTs->AutoSize();
      $winSearchSA->gridResultsSA_ACTs->ExpandLastColumn();
      $winSearchSA->Show();
      threads->exit();
    });
  }
  
}  #--- End SAResults

#--------------------------#
sub winSearchSA_Terminate
#--------------------------#
{
  $THR->kill('KILL')->detach() if $THR and $THR->is_running();
  # Delete temp file
  unlink("$REPORTDIR\\CurrentSearchParams-" . $PROCESSID .'.json')  if -e "$REPORTDIR\\CurrentSearchParams-" . $PROCESSID .'.json';
  unlink("$REPORTDIR\\CurrentSearchResults-" . $PROCESSID .'.json') if -e "$REPORTDIR\\CurrentSearchResults-" . $PROCESSID .'.json';
  -1; # Close program
  
}  #--- End winSearchSA_Terminate

#--------------------------#
sub winAdvPb_Terminate
#--------------------------#
{
  -1; # Close program
  
}  #--- End winAdvPb_Terminate

#--------------------------#
sub btnCancelLA_Click
#--------------------------#
{
  # Stop requests
  if ($THR) {
    $winAdvPb->lblPbCurr1->Text("$STR{'Process'} $STR{'cancelled'}...");
    $winAdvPb->lblPbCurr2->Text('');
    $winAdvPb->btnCancelLA->Hide();
    $winAdvPb->btnCloseWinAdvPb->Show();
    $THR->kill('KILL')->detach() if $THR->is_running();
    $winAdvPb->ChangeCursor($ARROW);
  }
  return(1);

}  #--- End btnCancelLA_Click

#--------------------------#
sub btnCloseWinAdvPb_Click { -1; } # Close program
#--------------------------#

#--------------------------#
sub createLADB
#--------------------------#
{
  my $destDB = encode('cp1252', $$REF_ARG[3]);
  if ($destDB and $destDB =~ /\.db/) {
    $THR = threads->create(sub {
      my ($nbrLogEntries, $id, $dbhWhoisDB, $geoIPDB, $XLWHOIS_DB_FILE, $GEOIP_DB_FILE);
      my $refDbh;
      my %fileINFO;
      my %databaseINFO;
      # Thread 'cancellation' signal handler
      $SIG{'KILL'} = sub {
        if ($$refDbh) {
          # Update FILES table
          &updateFILES($refDbh, \%fileINFO);
          # Update INFO table
          $databaseINFO{lastEndryId}    = ($id - 1);
          $databaseINFO{nbrLogEntries}  = $nbrLogEntries;
          $databaseINFO{lastUpdateTime} = time;
          $databaseINFO{version}        = $VERSION;
          &updateLADB_INFO($refDbh, \%databaseINFO) if $$refDbh;
          $$refDbh->commit();
          undef $$refDbh;
        }
        $winAdvPb->ChangeCursor($ARROW);
        threads->exit();
      };
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        die @_ if $_[0] =~ /Parse\/HTTP\/UserAgent/;
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        undef $$refDbh if $refDbh;
        $winAdvPb->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winAdvPb, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      if ($refDbh = &validLADB($destDB)) {
        $winAdvPb->Show();
        $winAdvPb->ChangeCursor($HOURGLASS);
        $winAdvPb->lblPbCurr1->Text("$STR{'PreProcessing'}");
        my $dbFile = $$REF_ARG[3];
        my $dbDir  = $dbFile;
        while (chop($dbDir) ne "\\") { } # Dir only
        # Get database info
        my $sthINFO    = $$refDbh->prepare('SELECT key,value FROM INFO');
        $sthINFO->execute();
        my $refAllRows = $sthINFO->fetchall_arrayref();
        foreach my $refRow (@{$refAllRows}) { $databaseINFO{$$refRow[0]} = $$refRow[1]; }
        $sthINFO->finish();
        # Set process options
        my %fieldOrder;
        my %hashLFRE   = ('expr' => '^'.$databaseINFO{LFRegex}, 'regex' => 1);
        my (@LFFields) = split(/ /, $databaseINFO{LFPattern});
        my $i = 0;
        foreach my $field (@LFFields) {
          if    ($field =~ /remoteIP/     ) { $fieldOrder{remoteIP}      = $i++; }
          elsif ($field =~ /datetime/     ) { $fieldOrder{datetime}      = $i++; }
          elsif ($field =~ /http_method/  ) { $fieldOrder{http_method}   = $i++; }
          elsif ($field =~ /http_request/ ) { $fieldOrder{http_request}  = $i++; }
          elsif ($field =~ /http_params/  ) { $fieldOrder{http_params}   = $i++; }
          elsif ($field =~ /http_protocol/) { $fieldOrder{http_protocol} = $i++; }
          elsif ($field =~ /http_status/  ) { $fieldOrder{http_status}   = $i++; }
          elsif ($field =~ /size/         ) { $fieldOrder{size}          = $i++; }
          elsif ($field =~ /referer/      ) { $fieldOrder{referer}       = $i++; }
          elsif ($field =~ /useragent/    ) { $fieldOrder{useragent}     = $i++; }
        }
        # Connect to XL-Whois/GeoIP databases
        if (($databaseINFO{filterISP} or $databaseINFO{filterGeoIP}) and open(CONFIG, "$USERDIR\\XL-Parser.ini")) {
          while (<CONFIG>) {
            if    (/^XLWHOIS_DB_FILE = ([^\n]+)/) { $XLWHOIS_DB_FILE = $1; }
            elsif (/^GEOIP_DB_FILE = ([^\n]+)/  ) { $GEOIP_DB_FILE   = $1; }
          }
          close(CONFIG);
          if ($databaseINFO{filterISP} and $XLWHOIS_DB_FILE) { # Connect to XL-Whois Database
            $XLWHOIS_DB_FILE = encode('utf8', $XLWHOIS_DB_FILE);
            my $dsn          = "DBI:SQLite:dbname=$XLWHOIS_DB_FILE";
            $dbhWhoisDB = DBI->connect($dsn, undef, undef, { RaiseError => 1, AutoCommit => 1 });
          }
          if ($databaseINFO{filterGeoIP} and $GEOIP_DB_FILE) { # Connect to GeoIP Database
            $geoIPDB = Geo::IP->open($GEOIP_DB_FILE, GEOIP_MEMORY_CACHE);
          }
        }
        # Get Filters
        my $refFilterSets;
        my $fhFiltered;
        if ($databaseINFO{nbrFilterSets} and open(my $json, "$dbDir\\CurrentProjectSelFilters-" . $PROCESSID .'.json')) {
          my $jsonText = <$json>;
          close($json);
          my $jsonObj = JSON->new;
          $refFilterSets = $jsonObj->decode($jsonText);
          # Open filtered lines file
          if ($$REF_ARG[0] ne 'update' or !(-e "$dbFile.FilteredLines.log")) {
            unlink("$dbFile.FilteredLines.log") if -f "$dbFile.FilteredLines.log";
            if ($databaseINFO{logFiltered}) {
              open($fhFiltered, ">$dbFile.FilteredLines.log");
              close($fhFiltered);
            }
          }
        # No filters, but the file exists, delete it
        } elsif (-f "$dbFile.FilteredLines.log" and $$REF_ARG[0] eq 'create') { unlink("$dbFile.FilteredLines.log"); }
        # It's an update, get next entry
        my $totalLinesLeft = 0;
        my $totalLines     = 0;
        my $totalSize      = 0;
        my ($startByFile, $startByLine, $fhRejected);
        if ($$REF_ARG[0] eq 'LADB-Update') {
          $totalLines    = $databaseINFO{parsedLines};
          $totalSize     = $databaseINFO{parsedSize};
          $nbrLogEntries = $$refDbh->selectrow_array('SELECT COUNT(id) FROM LOG');
          $id            = $databaseINFO{lastEndryId};
          $id = $nbrLogEntries if $nbrLogEntries and !$id;
          $id++;
          # Get file and line to start with
          my $sthFiles   = $$refDbh->prepare('SELECT id,lines,entries,rejected,filtered,firstEntry FROM FILES');
          $sthFiles->execute();
          while (my $refRow = $sthFiles->fetchrow_arrayref()) {
            my $nbrLinesLeft = $$refRow[1];                # Total number of lines for file
            $nbrLinesLeft   -= $$refRow[2] if $$refRow[2]; # - number of entries
            $nbrLinesLeft   -= $$refRow[3] if $$refRow[3]; # - number of rejected
            $nbrLinesLeft   -= $$refRow[4] if $$refRow[4]; # - number of filtered
            if ($nbrLinesLeft) { # File has not been completely parsed
              if (!$startByFile) {
                $startByFile  = $$refRow[0];
                # Start by line
                $startByLine  = $$refRow[2];                # number of entries
                $startByLine += $$refRow[3] if $$refRow[3]; # + number of rejected
                $startByLine += $$refRow[4] if $$refRow[4]; # + number of filtered
              }
              $totalLinesLeft += $nbrLinesLeft;
            } else { $totalLinesLeft += $$refRow[1]; }
          }
          $sthFiles->finish();
          # Create rejected lines file
          if ($$REF_ARG[0] ne 'LADB-Update' or !(-e "$dbFile.RejectedLines.log")) {
            unlink("$dbFile.RejectedLines.log") if -f "$dbFile.RejectedLines.log";
            if ($databaseINFO{logRejected}) {
              open($fhRejected, ">$dbFile.RejectedLines.log");
              close($fhRejected);
            }
          }
        } else {
          $totalLinesLeft = $$refDbh->selectrow_array('SELECT sum(lines) FROM FILES');
          $nbrLogEntries = 0;
          $id            = 1;
          $startByFile   = 1;
          $startByLine   = 0;
          # Create rejected lines file
          unlink("$dbFile.RejectedLines.log") if -f "$dbFile.RejectedLines.log";
          if ($databaseINFO{logRejected}) {
            open($fhRejected, ">$dbFile.RejectedLines.log");
            close($fhRejected);
          }
        }
        # Prepare SQL queries
        my $sth      = $$refDbh->prepare('INSERT INTO LOG (id, remoteIP, remoteIPInt, datetimeInt, timeOfDay, weekday, http_method, http_request, http_params,
                                         http_protocol, http_status, size, referer, useragent, file) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)');
        my $sthFiles = $$refDbh->prepare('SELECT id, path, lines, entries, rejected, filtered FROM FILES');
        my $nbrFiles = $$refDbh->selectrow_array('SELECT count(id) FROM FILES');
        # Prepare stats
        my $countFiles = $startByFile - 1;
        $databaseINFO{nbrRejected} = 0 if !exists($databaseINFO{nbrRejected});
        $databaseINFO{nbrFiltered} = 0 if !exists($databaseINFO{nbrFiltered});
        $winAdvPb->btnCancelLA->Show();
        $winAdvPb->btnCloseWinAdvPb->Hide();
        $winAdvPb->pbWinPb1->SetRange(0, $nbrFiles);
        $winAdvPb->pbWinPb1->SetPos($countFiles);
        $winAdvPb->pbWinPb1->SetStep(1);
        $winAdvPb->lblCount1->Text("$countFiles / $nbrFiles");
        $winAdvPb->lblPbCurr1->Text("$STR{'Process'} $STR{'Started'}");
        $winAdvPb->pbWinPb2->Show();
        $winAdvPb->lblResStatsFilesVal->Text($countFiles);
        $winAdvPb->lblResStatsLinesVal->Text($totalLines);
        my $sizeStr = &formatFileSize($totalSize);
        $winAdvPb->lblResStatsSizeVal->Text($sizeStr);
        $winAdvPb->lblResStatsEntriesVal->Text($nbrLogEntries);
        $databaseINFO{nbrRejected}    = 0 if !$databaseINFO{nbrRejected};
        $databaseINFO{nbrFiltered}    = 0 if !$databaseINFO{nbrFiltered};
        $databaseINFO{nbrResWeekdays} = 0 if !$databaseINFO{nbrResWeekdays};
        $databaseINFO{nbrResISP}      = 0 if !$databaseINFO{nbrResISP};
        $databaseINFO{nbrResGeoIP}    = 0 if !$databaseINFO{nbrResGeoIP};
        $databaseINFO{nbrResUAs}      = 0 if !$databaseINFO{nbrResUAs};
        $winAdvPb->lblResStatsRejectedVal->Text($databaseINFO{nbrRejected});
        $winAdvPb->lblResStatsFilteredVal->Text($databaseINFO{nbrFiltered});
        $winAdvPb->lblResStatsResWDVal->Text($databaseINFO{nbrResWeekdays});
        $winAdvPb->lblResStatsResISPVal->Text($databaseINFO{nbrResISP});
        $winAdvPb->lblResStatsResGeoIPVal->Text($databaseINFO{nbrResGeoIP});
        $winAdvPb->lblResStatsResUAVal->Text($databaseINFO{nbrResUAs});
        my $currTotalLines = 0;
        my $startTime      = time;
        # Parse the logs and feed the database
        $sthFiles->execute();
        while (my $refFile = $sthFiles->fetchrow_arrayref()) {
          $fileINFO{id}          = $$refFile[0];
          $fileINFO{firstEntry}  = $id;
          $fileINFO{nbrLines}    = $$refFile[2];
          $fileINFO{nbrEntries}  = $$refFile[3];
          $fileINFO{nbrRejected} = $$refFile[4];
          $fileINFO{nbrFiltered} = $$refFile[5];
          my $nbrLinesLeft = $fileINFO{nbrLines};                              # Total number of lines for file
          $nbrLinesLeft   -= $fileINFO{nbrEntries}  if $fileINFO{nbrEntries};  # - number of entries
          $nbrLinesLeft   -= $fileINFO{nbrRejected} if $fileINFO{nbrRejected}; # - number of rejected
          $nbrLinesLeft   -= $fileINFO{nbrFiltered} if $fileINFO{nbrFiltered}; # - number of filtered
          my $countLines   = 0;
          if ($fileINFO{id} >= $startByFile) {
            $winAdvPb->lblPbCurr1->Text("$STR{'Processing'} $$refFile[1]...");
            $winAdvPb->pbWinPb2->SetRange(0, $fileINFO{nbrLines});
            $winAdvPb->pbWinPb2->SetPos(0);
            $winAdvPb->pbWinPb2->SetStep(1);
            $winAdvPb->lblCount2->Text("0 / $fileINFO{nbrLines}");
            $startByLine = 0 if $fileINFO{id} > $startByFile;
            if ($nbrLinesLeft) {
              if ($databaseINFO{nbrFilterSets}) { # With filters
                &createLADBParseFileF($$refFile[1], $refDbh, \$sth, $countLines, $startByLine, \$totalLines, \$totalLinesLeft,
                                      \$totalSize, \$currTotalLines, $startTime, \$id, \$nbrLogEntries, \%fileINFO, $refFilterSets,
                                      \%hashLFRE, $dbFile, \%fieldOrder, \%databaseINFO, \$dbhWhoisDB, \$geoIPDB);
              } else { # No Filter
                &createLADBParseFile($$refFile[1], $refDbh, \$sth, $countLines, $startByLine, \$totalLines, \$totalLinesLeft,
                                     \$totalSize, \$currTotalLines, $startTime, \$id, \$nbrLogEntries, \%fileINFO, \%hashLFRE,
                                     $dbFile, \%fieldOrder, \%databaseINFO, \$dbhWhoisDB, \$geoIPDB);
              }
            }
            $countFiles++;
            $winAdvPb->pbWinPb1->StepIt();
            $winAdvPb->lblCount1->Text("$countFiles / $nbrFiles");
            $winAdvPb->lblResStatsFilesVal->Text($countFiles);
          }
        }
        $sthFiles->finish();
        if ($databaseINFO{resISP} or $databaseINFO{resGeoIP} or $databaseINFO{resUA}) {
          $winAdvPb->lblCount1->Text('');
          my $nbrTask = 0;
          my $count   = 0;
          $nbrTask++ if $databaseINFO{resISP} or $databaseINFO{resGeoIP};
          $nbrTask++ if $databaseINFO{resUA};
          $winAdvPb->pbWinPb1->SetRange(0, $nbrTask);
          $winAdvPb->pbWinPb1->SetPos(0);
          $winAdvPb->pbWinPb1->SetStep(1);
          $winAdvPb->lblCount1->Text("$count / $nbrTask");
          # Resolve ISP/GeoIP
          if ($databaseINFO{resISP} or $databaseINFO{resGeoIP}) {
            $winAdvPb->lblPbCurr1->Text("$STR{'curTask'}: $STR{'SO_IPAddr_XLWhoisDB'}/$STR{'SO_GeoIP'}");
            $winAdvPb->lblPbCurr2->Text('');
            $winAdvPb->pbWinPb2->SetPos(0);
            $winAdvPb->lblCount2->Text('');
            &resISPGeoIP_DB($refDbh, $databaseINFO{resISP}, $databaseINFO{resGeoIP}, $USERDIR, $startTime);
            $databaseINFO{nbrResISP}   = $$refDbh->selectrow_array('SELECT count(isp) FROM IP WHERE isp IS NOT NULL');
            $databaseINFO{nbrResGeoIP} = $$refDbh->selectrow_array('SELECT count(geoIP) FROM IP WHERE geoIP IS NOT NULL');
            $count++;
            $winAdvPb->pbWinPb1->StepIt();
            $winAdvPb->lblCount1->Text("$count / $nbrTask");
          }
          # Resolve Useragent
          if ($databaseINFO{resUA}) {
            $winAdvPb->lblPbCurr1->Text("$STR{'curTask'}: $STR{'resUA'}");
            $winAdvPb->lblPbCurr2->Text('');
            $winAdvPb->pbWinPb2->SetPos(0);
            $winAdvPb->lblCount2->Text('');
            &resUA_DB($refDbh, $startTime);
            $databaseINFO{nbrResUAs} = $$refDbh->selectrow_array('SELECT count(ua) FROM UA');
            $count++;
            $winAdvPb->pbWinPb1->StepIt();
            $winAdvPb->lblCount1->Text("$count / $nbrTask");
          }
        }
        # Update INFO table
        $databaseINFO{parsedSize}     = $totalSize;
        $databaseINFO{parsedLines}    = $totalLines;
        $databaseINFO{lastEndryId}    = ($id - 1);
        $databaseINFO{nbrLogEntries}  = $nbrLogEntries;
        $databaseINFO{lastUpdateTime} = time;
        $databaseINFO{version}        = $VERSION;
        &updateLADB_INFO($refDbh, \%databaseINFO);
        $$refDbh->commit();
        # Update progress window
        unlink("$USERDIR\\tmpCurrentProcess.txt");
        my $currTime = time;
        my $diffTime = $currTime - $startTime;
        my ($diffD, $diffH, $diffM, $diffS) = (gmtime $diffTime)[7,2,1,0];
        my $duration;
        $duration .= "$diffD days, " if $diffD;
        $duration .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
        $winAdvPb->lblResStatsDurationVal->Text($duration);
        $winAdvPb->lblResStatsTimeLeftVal->Text(0);
        $winAdvPb->lblPbCurr1->Text("$STR{'Process'} $STR{'Finished'}...");
        $winAdvPb->lblPbCurr2->Text('');
        $winAdvPb->pbWinPb2->Hide();
        $winAdvPb->lblCount1->Text('');
        $winAdvPb->lblCount2->Text('');
        $winAdvPb->btnCancelLA->Hide();
        $winAdvPb->btnCloseWinAdvPb->Show();
        $winAdvPb->ChangeCursor($ARROW);
        # Disconnect Database
        $$refDbh->disconnect();
        $dbhWhoisDB->disconnect() if $dbhWhoisDB;
        # Delete empty files
        unlink("$dbDir\\CurrentProjectSelFilters-" . $PROCESSID .'.json') if "$dbDir\\CurrentProjectSelFilters-" . $PROCESSID .'.json';
        unlink("$dbFile.RejectedLines.log")             if -e "$dbFile.RejectedLines.log" and -z "$dbFile.RejectedLines.log";
        unlink("$dbFile.FilteredLines.log")             if -e "$dbFile.FilteredLines.log" and -z "$dbFile.FilteredLines.log";
      }
    });
  }
  
}  #--- End createLADB

#------------------------------------------------------------------------------#
sub createLADBParseFile
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refDbh, $refSth, $countLines, $startByLine, $refTotalLines, $refTotalLinesLeft, $refTotalSize,
      $refCurrTotalLines, $startTime, $refID, $refNbrLogEntries, $refFileINFO, $refHashLFRE, $dbFile,
      $refFieldOrder, $refDatabaseINFO, $refDbhWhoisDB, $refGeoIPDB) = @_;
  if (open(my $fh, $file)) {
    my $fhRejected;
    open($fhRejected, ">>$dbFile.RejectedLines.log") if $$refDatabaseINFO{logRejected};
    $winAdvPb->lblPbCurr2->Text("$STR{'Processing'} $STR{'lines'}...");
    while (<$fh>) {
      my $lineSize = 0;
      if ($countLines >= $startByLine) {
        $lineSize = length($_);
        s/[\n\r]//g;
        $$refCurrTotalLines++;
        $$refTotalLines++;
        $$refTotalLinesLeft--;
        $$refTotalSize += $lineSize;
        my ($result, $nbrRes, $refListRes) = &textExprAll($_, $refHashLFRE);
        if ($result) {
          my %newEntry;
          $newEntry{remoteIP}      = undef;
          $newEntry{remoteIPInt}   = undef;
          $newEntry{datetimeInt}   = undef;
          $newEntry{timeOfDay}     = undef;
          $newEntry{weekday}       = undef;
          $newEntry{http_method}   = undef;
          $newEntry{http_request}  = undef;
          $newEntry{http_params}   = undef;
          $newEntry{http_protocol} = undef;
          $newEntry{http_status}   = undef;
          $newEntry{size}          = undef;
          $newEntry{referer}       = undef;
          $newEntry{useragent}     = undef;
          # Set values
          my @listRes = split(/\t/, $$refListRes[0]);
          shift(@listRes);
          # If http_protocol don't exist, insert the value for 0.9
          splice(@listRes, $$refFieldOrder{http_protocol}, 0, 'HTTP/0.9') if $$refFieldOrder{http_protocol} and
                                                                             $listRes[$$refFieldOrder{http_protocol}] !~ /HTTP/;
          foreach my $field (keys %{$refFieldOrder}) {
            my $ind = $$refFieldOrder{$field};
            # Remote IP
            if ($field eq 'remoteIP') {
              $newEntry{remoteIP} = $listRes[$ind];
              $newEntry{remoteIPInt} = unpack 'N', pack 'C4', split '\.', $listRes[$ind] if $newEntry{remoteIP} =~ /\./; # IPv4
            }
            # Datetime
            elsif ($field eq 'datetime') { $newEntry{datetime} = $listRes[$ind]; }
            # Useragent
            elsif ($field eq 'useragent') {
              $newEntry{'useragent'} = $listRes[$ind];
              $newEntry{'useragent'} =~ s/\+/ /g if !$$refDatabaseINFO{uaWithSpace} and $newEntry{'useragent'};
            }
            # Other field
            elsif ($field eq 'http_method'  ) { $newEntry{http_method}   = $listRes[$ind]; }
            elsif ($field eq 'http_request' ) { $newEntry{http_request}  = $listRes[$ind]; }
            elsif ($field eq 'http_params'  ) { $newEntry{http_params}   = $listRes[$ind]; }
            elsif ($field eq 'http_protocol') { $newEntry{http_protocol} = $listRes[$ind]; }
            elsif ($field eq 'http_status'  ) { $newEntry{http_status}   = $listRes[$ind]; }
            elsif ($field eq 'size'         ) { $newEntry{size}          = $listRes[$ind]; }
            elsif ($field eq 'referer'      ) { $newEntry{referer}       = $listRes[$ind]; }
          }
          # New entry
          if ($newEntry{remoteIP} and $newEntry{datetime} and $newEntry{http_method} and $newEntry{http_request} and
              $newEntry{http_status}) { # Minimal fields
            # Datetime
            my $strp = DateTime::Format::Strptime->new(pattern => $$refDatabaseINFO{DTPattern});
            if (my $dt = $strp->parse_datetime($newEntry{datetime})) {
              $dt->set_time_zone('UTC');
              $newEntry{datetimeInt} = $dt->epoch();
              # Time of the day
              my $dateOnlyDT = $dt->clone();
              $dateOnlyDT->set_hour(0);
              $dateOnlyDT->set_minute(0);
              $dateOnlyDT->set_second(0);
              $newEntry{timeOfDay} = $dt->epoch() - $dateOnlyDT->epoch();
              # Resolve Weekday
              if ($$refDatabaseINFO{resWeekday}) {
                $newEntry{weekday} = $dt->strftime('%w');
                $$refDatabaseINFO{nbrResWeekdays}++;
                $winAdvPb->lblResStatsResWDVal->Text($$refDatabaseINFO{nbrResWeekdays});
              }
            }
            # Add entry to log table
            $$refSth->execute($$refID, $newEntry{remoteIP}, $newEntry{remoteIPInt}, $newEntry{datetimeInt}, $newEntry{timeOfDay},
                              $newEntry{weekday}, $newEntry{http_method}, $newEntry{http_request}, $newEntry{http_params},
                              $newEntry{http_protocol}, $newEntry{http_status}, $newEntry{size}, $newEntry{referer},
                              $newEntry{useragent}, $$refFileINFO{id});
            $$refSth->finish();
            $$refDatabaseINFO{firstDT} = $newEntry{datetimeInt} if !exists($$refDatabaseINFO{firstDT});
            $$refDatabaseINFO{lastDT}  = $newEntry{datetimeInt};
            $$refID++;
            $$refFileINFO{nbrEntries}++;
            $$refNbrLogEntries++;
            $winAdvPb->lblResStatsEntriesVal->Text($$refNbrLogEntries);
          }
          # Update stats
          $winAdvPb->lblResStatsLinesVal->Text($$refTotalLines);
          my $sizeStr = &formatFileSize($$refTotalSize);
          $winAdvPb->lblResStatsSizeVal->Text($sizeStr);
          # Update time elapsed
          my $currTime = time;
          my $diffTime = $currTime - $startTime;
          my ($diffD, $diffH, $diffM, $diffS) = (gmtime $diffTime)[7,2,1,0];
          my $duration;
          $duration .= "$diffD days, " if $diffD;
          $duration .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
          $winAdvPb->lblResStatsDurationVal->Text($duration);
          # Update time left estimation after each 1000 processed requests
          if ($$refCurrTotalLines % 1000 == 0) {
            $$refDbh->commit();
            $$refDbh->do('PRAGMA shrink_memory');
            # Update Estimated time left
            my $timeByLine     = $diffTime / $$refCurrTotalLines;
            my $estTimeLeftSec = int($timeByLine * $$refTotalLinesLeft);
            ($diffD, $diffH, $diffM, $diffS) = (gmtime $estTimeLeftSec)[7,2,1,0];
            my $estTimeLeft;
            $estTimeLeft .= "$diffD days, " if $diffD;
            $estTimeLeft .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
            $winAdvPb->lblResStatsTimeLeftVal->Text($estTimeLeft);
          }
        # Print rejected line (doesn't match log format regex)
        } else {
          print $fhRejected $_ . "\n" if $fhRejected and (!$$refDatabaseINFO{ignoreComments} or $_ !~ /^#/);
          $$refFileINFO{nbrRejected}++;
          $$refDatabaseINFO{nbrRejected}++;
          $winAdvPb->lblResStatsRejectedVal->Text($$refDatabaseINFO{nbrRejected});
        }
      }
      $countLines++;
      $winAdvPb->pbWinPb2->StepIt();
      $winAdvPb->lblCount2->Text("$countLines / $$refFileINFO{nbrLines}");
    }
    close($fh);
    close($fhRejected) if $fhRejected;
    # Update FILES table
    &updateFILES($refDbh, $refFileINFO);
    $$refDbh->commit();
  }
  
}  #--- End createLADBParseFile

#------------------------------------------------------------------------------#
sub createLADBParseFileF
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($file, $refDbh, $refSth, $countLines, $startByLine, $refTotalLines, $refTotalLinesLeft, $refTotalSize,
      $refCurrTotalLines, $startTime, $refID, $refNbrLogEntries, $refFileINFO, $refFilterSets, $refHashLFRE,
      $dbFile, $refFieldOrder, $refDatabaseINFO, $refDbhWhoisDB, $refGeoIPDB) = @_;
  if (open(my $fh, $file)) {
    my $fhRejected;
    my $fhFiltered;
    open($fhRejected, ">>$dbFile.RejectedLines.log") if $$refDatabaseINFO{logRejected};
    open($fhFiltered, ">>$dbFile.FilteredLines.log") if $$refDatabaseINFO{logFiltered};
    $winAdvPb->lblPbCurr2->Text("$STR{'Processing'} $STR{'lines'}...");
    while (<$fh>) {
      my $lineSize = 0;
      if ($countLines >= $startByLine) {
        my $line  = $_;
        $lineSize = length($line);
        s/[\n\r]//g;
        $$refCurrTotalLines++;
        $$refTotalLines++;
        $$refTotalLinesLeft--;
        $$refTotalSize += $lineSize;
        my ($result, $nbrRes, $refListRes) = &textExprAll($line, $refHashLFRE);
        if ($result) {
          my %newEntry;
          $newEntry{remoteIP}      = undef;
          $newEntry{remoteIPInt}   = undef;
          $newEntry{datetimeInt}   = undef;
          $newEntry{timeOfDay}     = undef;
          $newEntry{weekday}       = undef;
          $newEntry{http_method}   = undef;
          $newEntry{http_request}  = undef;
          $newEntry{http_params}   = undef;
          $newEntry{http_protocol} = undef;
          $newEntry{http_status}   = undef;
          $newEntry{size}          = undef;
          $newEntry{referer}       = undef;
          $newEntry{useragent}     = undef;
          # Set values
          my @listRes = split(/\t/, $$refListRes[0]);
          shift(@listRes);
          # If http_protocol don't exist, insert the value for 0.9
          splice(@listRes, $$refFieldOrder{http_protocol}, 0, 'HTTP/0.9') if $$refFieldOrder{http_protocol} and
                                                                             $listRes[$$refFieldOrder{http_protocol}] !~ /HTTP/;
          foreach my $field (keys %{$refFieldOrder}) {
            my $ind = $$refFieldOrder{$field};
            # Remote IP
            if ($field eq 'remoteIP') {
              $newEntry{remoteIP} = $listRes[$ind];
              $newEntry{remoteIPInt} = unpack 'N', pack 'C4', split '\.', $listRes[$ind] if $newEntry{remoteIP} =~ /\./; # IPv4
            }
            # Datetime
            elsif ($field eq 'datetime') {
              $newEntry{datetime} = $listRes[$ind];
              # Resolve datetime before filtering
              if ($$refDatabaseINFO{filterWeekday}) {
                my $strp = DateTime::Format::Strptime->new(pattern => $$refDatabaseINFO{DTPattern});
                if (my $dt = $strp->parse_datetime($newEntry{datetime})) {
                  $dt->set_time_zone('UTC');
                  $newEntry{datetimeInt} = $dt->epoch();
                  # Time of the day
                  my $dateOnlyDT = $dt->clone();
                  $dateOnlyDT->set_hour(0);
                  $dateOnlyDT->set_minute(0);
                  $dateOnlyDT->set_second(0);
                  $newEntry{timeOfDay} = $dt->epoch() - $dateOnlyDT->epoch();
                  $newEntry{weekday}   = $dt->strftime('%w'); # Resolve Weekday
                }
              }
            }
            # Useragent
            elsif ($field eq 'useragent') {
              $newEntry{'useragent'} = $listRes[$ind];
              $newEntry{'useragent'} =~ s/\+/ /g if !$$refDatabaseINFO{uaWithSpace} and $newEntry{'useragent'};
            }
            # Other field
            elsif ($field eq 'http_method'  ) { $newEntry{http_method}   = $listRes[$ind]; }
            elsif ($field eq 'http_request' ) { $newEntry{http_request}  = $listRes[$ind]; }
            elsif ($field eq 'http_params'  ) { $newEntry{http_params}   = $listRes[$ind]; }
            elsif ($field eq 'http_protocol') { $newEntry{http_protocol} = $listRes[$ind]; }
            elsif ($field eq 'http_status'  ) { $newEntry{http_status}   = $listRes[$ind]; }
            elsif ($field eq 'size'         ) { $newEntry{size}          = $listRes[$ind]; }
            elsif ($field eq 'referer'      ) { $newEntry{referer}       = $listRes[$ind]; }
          }
          # New entry
          if ($newEntry{remoteIP} and ($newEntry{datetime} or $newEntry{datetimeInt}) and $newEntry{http_method} and
              $newEntry{http_request} and $newEntry{http_status}) { # Minimal fields
            if ($$refDatabaseINFO{filterISP} or $$refDatabaseINFO{filterGeoIP} or $$refDatabaseINFO{filterUA}) {
              # Resolve ISP or GeoIP before filtering
              $newEntry{isp}   = undef;
              $newEntry{geoIP} = undef;
              # Already resolved
              if (my @IPEntry = $$refDbh->selectrow_array('SELECT * FROM IP WHERE ip == ? COLLATE NOCASE', undef, $newEntry{remoteIP})) {
                $newEntry{isp}   = $IPEntry[1] if $IPEntry[1];
                $newEntry{geoIP} = $IPEntry[2] if $IPEntry[2];
              # Resolve
              } else {
                if ($$refDatabaseINFO{filterISP} and $$refDbhWhoisDB) { # Resolve ISP before filtering
                  $newEntry{isp} = &resolveISP($newEntry{remoteIP}, $refDbhWhoisDB);
                  $newEntry{isp} = 'unknown' if !$newEntry{isp};
                }
                if ($$refDatabaseINFO{filterGeoIP} and $$refGeoIPDB) { # Resolve GeoIP before filtering
                  $newEntry{geoIP} = &resolveGeoIP($newEntry{remoteIP}, $refGeoIPDB);
                  $newEntry{geoIP} = 'unknown' if !$newEntry{geoIP};
                }
              }
              # Resolve Useragent before filtering
              if ($$refDatabaseINFO{filterUA} and $newEntry{useragent}) {
                $newEntry{type}    = undef;
                $newEntry{os}      = undef;
                $newEntry{browser} = undef;
                $newEntry{device}  = undef;
                $newEntry{lang}    = undef;
                # Already resolved
                if (my @UAEntry = $$refDbh->selectrow_array('SELECT * FROM UA WHERE ua == ? COLLATE NOCASE', undef, $newEntry{'useragent'})) {
                  $newEntry{type}    = $UAEntry[1] if $UAEntry[1];
                  $newEntry{os}      = $UAEntry[2] if $UAEntry[2];
                  $newEntry{browser} = $UAEntry[3] if $UAEntry[3];
                  $newEntry{device}  = $UAEntry[4] if $UAEntry[4];
                  $newEntry{lang}    = $UAEntry[5] if $UAEntry[5];
                # Resolve
                } else { &parseUA($newEntry{useragent}, \%newEntry); }
              }
            }
            # Filters
            my $addData = 1;
            # Test filters
            $addData = &LAFilterData($refFilterSets, $$refDatabaseINFO{nbrFilterSets}, $$refDatabaseINFO{whiteList}, \%newEntry,
                                     $$refDatabaseINFO{timezone}) if $$refDatabaseINFO{nbrFilterSets};
            if ($addData) {
              # Datetime
              if (!$$refDatabaseINFO{filterWeekday} and $newEntry{datetime}) { # Datetime must be resolved
                my $strp = DateTime::Format::Strptime->new(pattern => $$refDatabaseINFO{DTPattern});
                if (my $dt = $strp->parse_datetime($newEntry{datetime})) {
                  $dt->set_time_zone('UTC');
                  $newEntry{datetimeInt} = $dt->epoch();
                  # Time of the day
                  my $dateOnlyDT = $dt->clone();
                  $dateOnlyDT->set_hour(0);
                  $dateOnlyDT->set_minute(0);
                  $dateOnlyDT->set_second(0);
                  $newEntry{timeOfDay} = $dt->epoch() - $dateOnlyDT->epoch();
                  # Resolve Weekday
                  if ($$refDatabaseINFO{resWeekday}) {
                    $newEntry{weekday} = $dt->strftime('%w');
                    $$refDatabaseINFO{nbrResWeekdays}++;
                    $winAdvPb->lblResStatsResWDVal->Text($$refDatabaseINFO{nbrResWeekdays});
                  }
                }
              } elsif ($$refDatabaseINFO{resWeekday} and $newEntry{weekday}) { # Weekday has already been resolved
                $$refDatabaseINFO{nbrResWeekdays}++;
                $winAdvPb->lblResStatsResWDVal->Text($$refDatabaseINFO{nbrResWeekdays});
              }
              # Add entry to log table
              $$refSth->execute($$refID, $newEntry{remoteIP}, $newEntry{remoteIPInt}, $newEntry{datetimeInt}, $newEntry{timeOfDay},
                                $newEntry{weekday}, $newEntry{http_method}, $newEntry{http_request}, $newEntry{http_params},
                                $newEntry{http_protocol}, $newEntry{http_status}, $newEntry{size}, $newEntry{referer},
                                $newEntry{useragent}, $$refFileINFO{id});
              $$refSth->finish();
              $$refDatabaseINFO{firstDT} = $newEntry{datetimeInt} if !exists($$refDatabaseINFO{firstDT});
              $$refDatabaseINFO{lastDT}  = $newEntry{datetimeInt};
              $$refID++;
              $$refFileINFO{nbrEntries}++;
              $$refNbrLogEntries++;
              $winAdvPb->lblResStatsEntriesVal->Text($$refNbrLogEntries);
            } else {
              print $fhFiltered $line if $fhFiltered;
              $$refFileINFO{nbrFiltered}++;
              $$refDatabaseINFO{nbrFiltered}++;
              $winAdvPb->lblResStatsFilteredVal->Text($$refDatabaseINFO{nbrFiltered});
            }
          }
          # Update stats
          $winAdvPb->lblResStatsLinesVal->Text($$refTotalLines);
          my $sizeStr = &formatFileSize($$refTotalSize);
          $winAdvPb->lblResStatsSizeVal->Text($sizeStr);
          # Update time elapsed
          my $currTime = time;
          my $diffTime = $currTime - $startTime;
          my ($diffD, $diffH, $diffM, $diffS) = (gmtime $diffTime)[7,2,1,0];
          my $duration;
          $duration .= "$diffD days, " if $diffD;
          $duration .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
          $winAdvPb->lblResStatsDurationVal->Text($duration);
          # Update time left estimation after each 1000 processed requests
          if ($$refCurrTotalLines % 1000 == 0) {
            $$refDbh->commit();
            $$refDbh->do('PRAGMA shrink_memory');
            # Update Estimated time left
            my $timeByLine     = $diffTime / $$refCurrTotalLines;
            my $estTimeLeftSec = int($timeByLine * $$refTotalLinesLeft);
            ($diffD, $diffH, $diffM, $diffS) = (gmtime $estTimeLeftSec)[7,2,1,0];
            my $estTimeLeft;
            $estTimeLeft .= "$diffD days, " if $diffD;
            $estTimeLeft .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
            $winAdvPb->lblResStatsTimeLeftVal->Text($estTimeLeft);
          }
        # Print rejected line (doesn't match log format regex)
        } else {
          print $fhRejected $line if $fhRejected and (!$$refDatabaseINFO{ignoreComments} or $line !~ /^#/);
          $$refFileINFO{nbrRejected}++;
          $$refDatabaseINFO{nbrRejected}++;
          $winAdvPb->lblResStatsRejectedVal->Text($$refDatabaseINFO{nbrRejected});
        }
      }
      $countLines++;
      $winAdvPb->pbWinPb2->StepIt();
      $winAdvPb->lblCount2->Text("$countLines / $$refFileINFO{nbrLines}");
    }
    close($fh);
    close($fhRejected) if $fhRejected;
    close($fhFiltered) if $fhFiltered;
    # Update FILES table
    &updateFILES($refDbh, $refFileINFO);
    $$refDbh->commit();
  }
  
}  #--- End createLADBParseFileF
  
#------------------------------------------------------------------------------#
sub updateLADB
#------------------------------------------------------------------------------#
{
  # Local variables
  my %updateParams;
  my %databaseINFO;
  my $refUpdateParams = \%updateParams;
  my ($dbh, $sth, $nbrIPsRes, $nbrUAsRes, $nbrWDsRes);
  $winAdvPb->Show();
  $winAdvPb->pbWinPb2->Hide();
  if (open(my $json, "$REPORTDIR\\CurrentUpdateParams-" . $PROCESSID .'.json')) {
    $THR = threads->create(sub {
      # Thread 'cancellation' signal handler
      $SIG{'KILL'} = sub {
        # Update INFO table
        $databaseINFO{lastUpdateTime} = time;
        $databaseINFO{version}        = $VERSION;
        &updateLADB_INFO(\$dbh, \%databaseINFO) if $dbh;;
        # Finish statement handle and disconnect database
        undef $dbh;
        $winAdvPb->ChangeCursor($ARROW);
        threads->exit();
      };
      # Thread 'die' signal handler
      $SIG{__DIE__} = sub {
        die @_ if $_[0] =~ /Parse\/HTTP\/UserAgent/;
        my $errMsg = (split(/ at /, $_[0]))[0];
        $errMsg =~ s/[\t\r\n]/ /g;
        # Update INFO table
        $databaseINFO{lastUpdateTime} = time;
        $databaseINFO{version}        = $VERSION;
        &updateLADB_INFO(\$dbh, \%databaseINFO) if $dbh;;
        # Finish statement handle and disconnect database
        undef $dbh;
        $winAdvPb->ChangeCursor($ARROW);
        Win32::GUI::MessageBox($winAdvPb, "$STR{'errorMsg'}: $errMsg", $STR{'error'}, 0x40010);
        threads->exit();
      };
      $winAdvPb->ChangeCursor($HOURGLASS);
      $winAdvPb->lblPbCurr1->Text("$STR{'PreProcessing'}");
      my $jsonText = <$json>;
      close($json);
      my $jsonObj = JSON->new;
      $refUpdateParams = $jsonObj->decode($jsonText);
      # Connect to log database
      my $dsn = "DBI:SQLite:dbname=$$refUpdateParams{dbFile}";
      $dbh    = DBI->connect($dsn, undef, undef, { RaiseError => 1, AutoCommit => 0}) or return(0);
      # Get database info
      my $sthINFO = $dbh->prepare('SELECT key,value FROM INFO');
      $sthINFO->execute();
      my $refAllRows = $sthINFO->fetchall_arrayref();
      foreach my $refRow (@{$refAllRows}) { $databaseINFO{$$refRow[0]} = $$refRow[1]; }
      $sthINFO->finish();
      # Prepare stats
      $winAdvPb->btnCancelLA->Show();
      $winAdvPb->btnCloseWinAdvPb->Hide();
      my $nbrFiles                  = $dbh->selectrow_array('SELECT COUNT(id) FROM FILES');
      $databaseINFO{nbrRejected}    = 0 if !exists($databaseINFO{nbrRejected}) or !$databaseINFO{nbrRejected};
      $databaseINFO{nbrFiltered}    = 0 if !exists($databaseINFO{nbrFiltered}) or !$databaseINFO{nbrFiltered};
      $databaseINFO{nbrResWeekdays} = 0 if !$databaseINFO{nbrResWeekdays};
      $databaseINFO{nbrResISP}      = 0 if !$databaseINFO{nbrResISP};
      $databaseINFO{nbrResGeoIP}    = 0 if !$databaseINFO{nbrResGeoIP};
      $databaseINFO{nbrResUAs}      = 0 if !$databaseINFO{nbrResUAs};
      $winAdvPb->lblResStatsFilesVal->Text($nbrFiles);
      $winAdvPb->lblResStatsEntriesVal->Text($databaseINFO{nbrLogEntries});
      $winAdvPb->lblResStatsLinesVal->Text($databaseINFO{nbrLogEntries});
      my $sizeStr = &formatFileSize((stat(encode('cp1252', $$refUpdateParams{dbFile})))[7]);
      $winAdvPb->lblResStatsSizeVal->Text($sizeStr);
      $winAdvPb->lblResStatsDurationVal->Text(0);
      $winAdvPb->lblResStatsRejectedVal->Text($databaseINFO{nbrRejected});
      $winAdvPb->lblResStatsFilteredVal->Text($databaseINFO{nbrFiltered});
      $winAdvPb->lblResStatsResWDVal->Text($databaseINFO{nbrResWeekdays});
      $winAdvPb->lblResStatsResISPVal->Text($databaseINFO{nbrResISP});
      $winAdvPb->lblResStatsResGeoIPVal->Text($databaseINFO{nbrResGeoIP});
      $winAdvPb->lblResStatsResUAVal->Text($databaseINFO{nbrResUAs});
      my $startTime = time;
      # Get Filters
      my $refFilterSets;
      if ($$refUpdateParams{nbrFilterSets} and open(my $json, "$REPORTDIR\\CurrentProjectSelFilters-" . $PROCESSID .'.json')) {
        my $jsonText = <$json>;
        close($json);
        my $jsonObj = JSON->new;
        $refFilterSets = $jsonObj->decode($jsonText);
      }
      # Set task list
      my @taskList;
      # If filters
      if ($$refUpdateParams{nbrFilterSets}) {
        # Resolve first
        if ($$refUpdateParams{filterISP} or $$refUpdateParams{filterGeoIP} or $$refUpdateParams{filterUA} or $$refUpdateParams{filterWeekday}) {
          push(@taskList, "$STR{'SO_IPAddr_XLWhoisDB'}/$STR{'SO_GeoIP'}") if $$refUpdateParams{resISP} or $$refUpdateParams{resGeoIP};
          push(@taskList, $STR{'resUA'})      if $$refUpdateParams{resUA};
          push(@taskList, $STR{'resWeekday'}) if $$refUpdateParams{resWeekday};
          push(@taskList, $STR{'applyFilters'});
        } else {
          push(@taskList, $STR{'applyFilters'});
          push(@taskList, "$STR{'SO_IPAddr_XLWhoisDB'}/$STR{'SO_GeoIP'}") if $$refUpdateParams{resISP} or $$refUpdateParams{resGeoIP};
          push(@taskList, $STR{'resUA'})      if $$refUpdateParams{resUA};
          push(@taskList, $STR{'resWeekday'}) if $$refUpdateParams{resWeekday};
        }
      # No filter
      } else {
        push(@taskList, "$STR{'SO_IPAddr_XLWhoisDB'}/$STR{'SO_GeoIP'}") if $$refUpdateParams{resISP} or $$refUpdateParams{resGeoIP};
        push(@taskList, $STR{'resUA'})      if $$refUpdateParams{resUA};
        push(@taskList, $STR{'resWeekday'}) if $$refUpdateParams{resWeekday};
      }
      push(@taskList, $STR{'updDBInfos'});
      my $nbrTasks = scalar(@taskList);
      my $done     = 0;
      $nbrTasks++ if $$refUpdateParams{createNew}; # Add a task (copy)
      $dbh->disconnect();
      # Set progress bar
      $winAdvPb->pbWinPb1->SetRange(0, $nbrTasks);
      $winAdvPb->pbWinPb1->SetPos(0);
      $winAdvPb->pbWinPb1->SetStep(1);
      $winAdvPb->lblCount1->Text("0 / $nbrTasks");
      $winAdvPb->lblPbCurr1->Text("$STR{'Process'} $STR{'Started'}");
      # Copy first
      my $dbFile;
      my $statusCopy = 1;
      my $copyMsg;
      if ($$refUpdateParams{createNew}) {
        $winAdvPb->lblPbCurr1->Text("$STR{'curTask'}: $STR{'copyDB'}");
        if (Win32::CopyFile(encode('cp1252', $$refUpdateParams{dbFile}), encode('cp1252', $$refUpdateParams{newDbFile}), 0)) {
          $dbFile = $$refUpdateParams{newDbFile};
          $done++;
          $winAdvPb->pbWinPb1->StepIt();
          $winAdvPb->lblCount1->Text("$done / $nbrTasks");
        } else { $statusCopy = 0; $copyMsg = $!; }
      } else { $dbFile = $$refUpdateParams{dbFile}; }
      if ($statusCopy) {
        $dsn = "DBI:SQLite:dbname=$dbFile";
        $dbh = DBI->connect($dsn, undef, undef, { RaiseError => 1, AutoCommit => 0}) or return(0);
        # Perform each task
        foreach my $task (@taskList) {
          $winAdvPb->lblPbCurr1->Text("$STR{'curTask'}: $task");
          # Resolve IPs
          if ($task eq "$STR{'SO_IPAddr_XLWhoisDB'}/$STR{'SO_GeoIP'}") {
            $winAdvPb->pbWinPb2->Show();
            &resISPGeoIP_DB(\$dbh, $$refUpdateParams{resISP}, $$refUpdateParams{resGeoIP}, $USERDIR, $startTime);
            $winAdvPb->pbWinPb2->Hide();
            $winAdvPb->lblCount2->Text('');
          # Resolve Useragents
          } elsif ($task eq $STR{'resUA'}   ) {
            $winAdvPb->pbWinPb2->Show();
            &resUA_DB(\$dbh, $startTime);
            $winAdvPb->pbWinPb2->Hide();
            $winAdvPb->lblCount2->Text('');
          }
          # Resolve Weekday
          elsif ($task eq $STR{'resWeekday'}) {
            $winAdvPb->pbWinPb2->Show();
            &resWeekday_DB(\$dbh);
            $winAdvPb->pbWinPb2->Hide();
            $winAdvPb->lblCount2->Text('');
          }
          # Apply filters
          elsif ($task eq $STR{'applyFilters'}) {
            $dbh->{AutoCommit} = 1;
            # Remove all entries that matches if whitelist, or doesn't match if regular filters
            my $SQLStr;
            my $sthDelete;
            if ($$refUpdateParams{whiteList}) {
              $SQLStr    = &filtersAsSQLStr($refFilterSets, 'DELETE FROM LOG WHERE '   , $$refUpdateParams{timezone});
              $sthDelete = $dbh->prepare($SQLStr);
            } else {
              $SQLStr    = &filtersAsSQLStr($refFilterSets, 'SELECT id FROM LOG WHERE ', $$refUpdateParams{timezone});
              $sthDelete = $dbh->prepare("DELETE FROM LOG WHERE id NOT IN ($SQLStr)");
            }
            $sthDelete->execute();
            $sthDelete->finish();
            # Deleted IP if doesn't exist in LOG but exists in IP
            $sthDelete = $dbh->prepare('DELETE FROM IP WHERE ip NOT IN (SELECT DISTINCT remoteIP FROM LOG)');
            $sthDelete->execute();
            $sthDelete->finish();
            # Delete UA if doesn't exist in LOG but exists in UA
            $sthDelete = $dbh->prepare('DELETE FROM UA WHERE ua NOT IN (SELECT DISTINCT useragent FROM LOG)');
            $sthDelete->execute();
            $sthDelete->finish();
            $dbh->do('VACUUM'); # Free space to reduce database file size
            $dbh->{AutoCommit} = 0;
            # Update total of item
            $databaseINFO{nbrLogEntries} = $dbh->selectrow_array('SELECT COUNT(id) FROM LOG');
            $winAdvPb->lblResStatsEntriesVal->Text($databaseINFO{nbrLogEntries});
            $winAdvPb->lblResStatsLinesVal->Text($databaseINFO{nbrLogEntries});
          # Update INFO table
          } elsif ($task eq $STR{'updDBInfos'}) {
            # If database has been filtered, some infos have changed
            if ($$refUpdateParams{nbrFilterSets}) {
              $databaseINFO{filtered}      = 1;
              my $currNbrEntries           = $dbh->selectrow_array('SELECT COUNT(id) FROM LOG');
              $databaseINFO{nbrFiltered}   = $databaseINFO{nbrLogEntries} - $currNbrEntries;
              $databaseINFO{nbrLogEntries} = $currNbrEntries;
              $databaseINFO{nbrFilterSets} = $$refUpdateParams{nbrFilterSets};
              $databaseINFO{filterISP}     = 1 if $$refUpdateParams{filterISP};
              $databaseINFO{filterGeoIP}   = 1 if $$refUpdateParams{filterGeoIP};
              $databaseINFO{filterUA}      = 1 if $$refUpdateParams{filterUA};
              $databaseINFO{filterWeekday} = 1 if $$refUpdateParams{filterWeekday};
              $databaseINFO{whiteList}     = 1 if $$refUpdateParams{whiteList};
              $databaseINFO{listFilters}  .= ', ' if exists($databaseINFO{listFilters});
              foreach my $cat (keys %{$refFilterSets}) {
                foreach my $filter (keys %{$$refFilterSets{$cat}}) { $databaseINFO{listFilters} .= "$cat - $filter, "; }
              }
              chop($databaseINFO{listFilters}); chop($databaseINFO{listFilters});
              my $sth = $dbh->prepare('SELECT datetimeInt FROM LOG');
              $sth->execute();
              my @firstRow = $sth->fetchrow_array;
              $databaseINFO{firstDT}     = $firstRow[0];
              $databaseINFO{lastEndryId} = $dbh->selectrow_array('SELECT MAX(id) FROM LOG');
              $databaseINFO{lastDT}      = $dbh->selectrow_array('SELECT datetimeInt FROM LOG WHERE id == ?', undef, $databaseINFO{lastEndryId});
              # Update FILES
              my $sthFiles = $dbh->prepare('SELECT id, entries, filtered FROM FILES');
              $sthFiles->execute();
              while (my $refFile = $sthFiles->fetchrow_arrayref()) {
                my $newNbrEntries  = $dbh->selectrow_array('SELECT COUNT(id) FROM LOG WHERE file == ?', undef, $$refFile[0]);
                my $nbrFiltered    = $$refFile[1] - $newNbrEntries;
                $nbrFiltered      += $$refFile[2] if $$refFile[2];
                my $fileFirstEntry = $dbh->selectrow_array('SELECT MIN(id) FROM LOG WHERE file == ?', undef, $$refFile[0]);
                # Update FILES table
                &updateFilteredFILES(\$dbh, $$refFile[0], $newNbrEntries, $nbrFiltered, $fileFirstEntry);
                $dbh->commit();
              }
            }
            $databaseINFO{resISP}         = 1 if $$refUpdateParams{resISP}     or $databaseINFO{resISP};
            $databaseINFO{resGeoIP}       = 1 if $$refUpdateParams{resGeoIP}   or $databaseINFO{resGeoIP};
            $databaseINFO{resUA}          = 1 if $$refUpdateParams{resUA}      or $databaseINFO{resUA};
            $databaseINFO{resWeekday}     = 1 if $$refUpdateParams{resWeekday} or $databaseINFO{resWeekday};
            $databaseINFO{nbrResISP}      = $dbh->selectrow_array('SELECT count(isp) FROM IP WHERE isp IS NOT NULL');
            $databaseINFO{nbrResGeoIP}    = $dbh->selectrow_array('SELECT count(geoIP) FROM IP WHERE geoIP IS NOT NULL');
            $databaseINFO{nbrResUAs}      = $dbh->selectrow_array('SELECT count(ua) FROM UA');
            $databaseINFO{nbrResWeekdays} = $dbh->selectrow_array('SELECT count(weekday) FROM LOG WHERE weekday IS NOT NULL');
            $databaseINFO{lastUpdateTime} = time;
            $databaseINFO{version}        = $VERSION;
            &updateLADB_INFO(\$dbh, \%databaseINFO);
          }
          $done++;
          $winAdvPb->pbWinPb1->StepIt();
          $winAdvPb->lblCount1->Text("$done / $nbrTasks");
        }
        $winAdvPb->lblPbCurr1->Text("$STR{'Process'} $STR{'Finished'}...");
        $dbh->commit();
        $dbh->disconnect();
        # Update progress window
        my $currTime = time;
        my $diffTime = $currTime - $startTime;
        my ($diffD, $diffH, $diffM, $diffS) = (gmtime $diffTime)[7,2,1,0];
        my $duration;
        $duration .= "$diffD days, " if $diffD;
        $duration .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
        $winAdvPb->lblResStatsDurationVal->Text($duration);
        $winAdvPb->lblResStatsTimeLeftVal->Text(0);
        $winAdvPb->lblPbCurr1->Text("$STR{'Process'} $STR{'Finished'}...");
        $winAdvPb->lblPbCurr2->Text('');
        $winAdvPb->pbWinPb2->Hide();
        $winAdvPb->lblCount2->Text('');
        $winAdvPb->btnCancelLA->Hide();
        $winAdvPb->btnCloseWinAdvPb->Show();
        $winAdvPb->ChangeCursor($ARROW);
        # Delete process files
        unlink("$REPORTDIR\\CurrentUpdateParams-" . $PROCESSID .'.json')      if -e "$REPORTDIR\\CurrentUpdateParams-" . $PROCESSID .'.json';
        unlink("$REPORTDIR\\CurrentProjectSelFilters-" . $PROCESSID .'.json') if -e "$REPORTDIR\\CurrentProjectSelFilters-" . $PROCESSID .'.json';
      # Error copying database
      } else { Win32::GUI::MessageBox($winResults, "$STR{'errorCopying'} $STR{'rbInputDatabase'}: $copyMsg", $STR{'error'}, 0x40010); }
    });
  }
  
}  #--- End updateLADB

#--------------------------#
sub resISPGeoIP_DB
#--------------------------#
{
  # Local variables
  my ($refDbh, $resISP, $resGeoIP, $USERDIR, $startTime) = @_;
  my ($dbhWhoisDB, $geoIPDB, $XLWHOIS_DB_FILE, $GEOIP_DB_FILE);
  # Open and load config values
  if (open(CONFIG, "$USERDIR\\XL-Parser.ini")) {
    while (<CONFIG>) {
      if    (/^XLWHOIS_DB_FILE = ([^\n]+)/) { $XLWHOIS_DB_FILE = $1; }
      elsif (/^GEOIP_DB_FILE = ([^\n]+)/  ) { $GEOIP_DB_FILE   = $1; }
    }
    close(CONFIG);
    # Connect to XL-Whois Database
    if ($resISP) {
      $XLWHOIS_DB_FILE = encode('utf8', $XLWHOIS_DB_FILE);
      my $dsn          = "DBI:SQLite:dbname=$XLWHOIS_DB_FILE";
      if ($dbhWhoisDB = DBI->connect($dsn, undef, undef, { RaiseError => 1 })) {}
      else {
        Win32::GUI::MessageBox($winAdvPb, $STR{'errorConnectDB'} . ' (XL-Whois DB)', $STR{'error'}, 0x40010);
        return(0);
      }
    }
    # Connect to GeoIP Database
    if ($resGeoIP) {
      if ($geoIPDB = Geo::IP->open($GEOIP_DB_FILE, GEOIP_MEMORY_CACHE)) {}
      else {
        Win32::GUI::MessageBox($winAdvPb, $STR{'errorConnectDB'} . ' (GeoIP)', $STR{'error'}, 0x40010);
        return(0);
      }
    }
  }
  # Set progress bar
  my $nbrIPs     = $$refDbh->selectrow_array('SELECT COUNT(DISTINCT remoteIP) FROM LOG');
  my $nbrIPsLeft = $nbrIPs;
  my $taskStartTime = time;
  $winAdvPb->pbWinPb2->SetRange(0, $nbrIPs);
  $winAdvPb->pbWinPb2->SetPos(0);
  $winAdvPb->pbWinPb2->SetStep(1);
  $winAdvPb->lblCount2->Text("0 / $nbrIPs");
  # Select all IP addresses
  my $sth      = $$refDbh->prepare('SELECT DISTINCT remoteIP FROM LOG');
  $sth->execute();
  my $sthIPAdd = $$refDbh->prepare('INSERT OR REPLACE INTO IP (ip, isp, geoIP) VALUES(?,?,?)');
  # Resolve each IP
  my $nbrResISP   = 0;
  my $nbrResGeoIP = 0;
  my $count       = 0;
  while (my $refEntryFields = $sth->fetchrow_arrayref()) {
    my $isp         = undef;
    my $geoIP       = undef;
    my $ISPExists   = 0;
    my $GeoIPExists = 0;
    # Already resolved
    if (my @IPEntry = $$refDbh->selectrow_array('SELECT * FROM IP WHERE ip == ? COLLATE NOCASE', undef, $$refEntryFields[0])) {
      if ($IPEntry[1]) { $isp   = $IPEntry[1]; $ISPExists   = 1; }
      if ($IPEntry[2]) { $geoIP = $IPEntry[2]; $GeoIPExists = 1; }
    }
    # Resolve or update
    if ($resISP and $dbhWhoisDB) { # Resolve ISP ?
      $isp = &resolveISP($$refEntryFields[0], \$dbhWhoisDB);
      $isp = 'unknown' if !$isp;
      $nbrResISP++;
      $winAdvPb->lblResStatsResISPVal->Text($nbrResISP);
    }
    if ($resGeoIP and $geoIPDB) { # Resolve GeoIP ?
      $geoIP = &resolveGeoIP($$refEntryFields[0], \$geoIPDB);
      $geoIP = 'unknown' if !$geoIP;
      $nbrResGeoIP++;
      $winAdvPb->lblResStatsResGeoIPVal->Text($nbrResGeoIP);
    }
    # Add entry to IP table
    if (($isp and (!$ISPExists or $resISP)) or ($geoIP and (!$GeoIPExists or $resGeoIP))) {
      $sthIPAdd->execute($$refEntryFields[0], $isp, $geoIP);
    }
    $count++;
    $nbrIPsLeft--;
    if ($count % 1000 == 0) { # Commit after each 1000
      $$refDbh->commit();
      $$refDbh->do('PRAGMA shrink_memory');
      # Update time elapsed
      my $currTime = time;
      my $diffTime = $currTime - $startTime;
      my ($diffD, $diffH, $diffM, $diffS) = (gmtime $diffTime)[7,2,1,0];
      my $duration;
      $duration .= "$diffD days, " if $diffD;
      $duration .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
      $winAdvPb->lblResStatsDurationVal->Text($duration);
      # Update Estimated time left
      $diffTime          = $currTime - $taskStartTime; # Time elapsed for the task only
      my $timeByItem     = $diffTime / $count;
      my $estTimeLeftSec = int($timeByItem * $nbrIPsLeft);
      ($diffD, $diffH, $diffM, $diffS) = (gmtime $estTimeLeftSec)[7,2,1,0];
      my $estTimeLeft;
      $estTimeLeft .= "$diffD days, " if $diffD;
      $estTimeLeft .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
      $winAdvPb->lblResStatsTimeLeftVal->Text($estTimeLeft);
    }
    $winAdvPb->pbWinPb2->StepIt();
    $winAdvPb->lblCount2->Text("$count / $nbrIPs");
  }
  $$refDbh->commit();
  $$refDbh->do('PRAGMA shrink_memory');
  $dbhWhoisDB->disconnect();
  
}  #--- End resISPGeoIP_DB

#--------------------------#
sub resUA_DB
#--------------------------#
{
  # Local variables
  my ($refDbh, $startTime) = @_;
  # Set progress bar
  my $nbrUAs     = $$refDbh->selectrow_array('SELECT COUNT(DISTINCT useragent) FROM LOG');
  my $nbrUAsLeft = $nbrUAs;
  my $taskStartTime = time;
  $winAdvPb->pbWinPb2->SetRange(0, $nbrUAs);
  $winAdvPb->pbWinPb2->SetPos(0);
  $winAdvPb->pbWinPb2->SetStep(1);
  $winAdvPb->lblCount2->Text("0 / $nbrUAs");
  # Select all User-agents
  my $sth = $$refDbh->prepare('SELECT DISTINCT useragent FROM LOG');
  $sth->execute();
  my $sthUAAdd = $$refDbh->prepare('INSERT OR REPLACE INTO UA (ua, type, os, browser, device, lang) VALUES(?,?,?,?,?,?)');
  # Resolve each User-agent
  my $nbrUAsRes  = 0;
  my $count      = 0;
  while (my $refEntryFields = $sth->fetchrow_arrayref()) {
    my %entry;
    $entry{type}    = undef;
    $entry{os}      = undef;
    $entry{browser} = undef;
    $entry{device}  = undef;
    $entry{lang}    = undef;
    my $UAExists    = 0;
    # Already resolved
    if (my @UAEntry = $$refDbh->selectrow_array('SELECT * FROM UA WHERE ua == ? COLLATE NOCASE', undef, $$refEntryFields[0])) {
      $UAExists = 1;
    # Resolve or update
    } elsif ($$refEntryFields[0]) {
      &parseUA($$refEntryFields[0], \%entry);
      $nbrUAsRes++;
      $winAdvPb->lblResStatsResUAVal->Text($nbrUAsRes);
    }
    # Add entry to UA table
    if ($$refEntryFields[0] and !$UAExists) {
      $sthUAAdd->execute($$refEntryFields[0], $entry{type}, $entry{os}, $entry{browser}, $entry{device}, $entry{lang});
    }
    $count++;
    $nbrUAsLeft--;
    if ($count % 1000 == 0) { # Commit after each 1000
      $$refDbh->commit();
      $$refDbh->do('PRAGMA shrink_memory');
      # Update time elapsed
      my $currTime = time;
      my $diffTime = $currTime - $startTime;
      my ($diffD, $diffH, $diffM, $diffS) = (gmtime $diffTime)[7,2,1,0];
      my $duration;
      $duration .= "$diffD days, " if $diffD;
      $duration .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
      $winAdvPb->lblResStatsDurationVal->Text($duration);
      # Update Estimated time left
      $diffTime          = $currTime - $taskStartTime; # Time elapsed for the task only
      my $timeByItem     = $diffTime / $count;
      my $estTimeLeftSec = int($timeByItem * $nbrUAsLeft);
      ($diffD, $diffH, $diffM, $diffS) = (gmtime $estTimeLeftSec)[7,2,1,0];
      my $estTimeLeft;
      $estTimeLeft .= "$diffD days, " if $diffD;
      $estTimeLeft .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
      $winAdvPb->lblResStatsTimeLeftVal->Text($estTimeLeft);
    }
    $winAdvPb->pbWinPb2->StepIt();
    $winAdvPb->lblCount2->Text("$count / $nbrUAs");
  }
  $$refDbh->commit();
  $$refDbh->do('PRAGMA shrink_memory');
  
}  #--- End resUA_DB

#--------------------------#
sub resWeekday_DB
#--------------------------#
{
  # Local variables
  my $refDbh = shift;
  # Set progress bar
  my $nbrDates     = $$refDbh->selectrow_array('SELECT COUNT(id) FROM LOG');
  my $nbrDatesLeft = $nbrDates;
  my $startTime    = time;
  $winAdvPb->pbWinPb2->SetRange(0, $nbrDates);
  $winAdvPb->pbWinPb2->SetPos(0);
  $winAdvPb->pbWinPb2->SetStep(1);
  $winAdvPb->lblCount2->Text("0 / $nbrDates");
  # Select all datetime
  my $sth = $$refDbh->prepare('SELECT id,datetimeInt FROM LOG');
  $sth->execute();
  my $sthWeekdayUpd = $$refDbh->prepare('UPDATE LOG SET weekday = ? WHERE id == ?');
  # Resolve Weekday
  my $count  = 0;
  my $nbrRes = 0;
  while (my $refEntryFields = $sth->fetchrow_arrayref()) {
    if (my $dt = DateTime->from_epoch(epoch => $$refEntryFields[1])) {
      $sthWeekdayUpd->execute($dt->strftime('%w'), $$refEntryFields[0]);
      $nbrRes++;
    }
    $count++;
    $nbrDatesLeft--;
    if ($nbrRes % 1000 == 0) { # Commit after each 1000
      $winAdvPb->lblCount2->Text("$count / $nbrDates");
      $winAdvPb->lblResStatsResWDVal->Text($nbrRes);
      $$refDbh->commit();
      $$refDbh->do('PRAGMA shrink_memory');
      # Update time elapsed
      my $currTime = time;
      my $diffTime = $currTime - $startTime;
      my ($diffD, $diffH, $diffM, $diffS) = (gmtime $diffTime)[7,2,1,0];
      my $duration;
      $duration .= "$diffD days, " if $diffD;
      $duration .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
      $winAdvPb->lblResStatsDurationVal->Text($duration);
      # Update Estimated time left
      my $timeByItem     = $diffTime / $nbrRes;
      my $estTimeLeftSec = int($timeByItem * $nbrDatesLeft);
      ($diffD, $diffH, $diffM, $diffS) = (gmtime $estTimeLeftSec)[7,2,1,0];
      my $estTimeLeft;
      $estTimeLeft .= "$diffD days, " if $diffD;
      $estTimeLeft .= sprintf("%02d:%02d:%02d\n", $diffH, $diffM, $diffS);
      $winAdvPb->lblResStatsTimeLeftVal->Text($estTimeLeft);
    }
    $winAdvPb->pbWinPb2->StepIt();
  }
  $winAdvPb->lblCount2->Text("$count / $nbrDates");
  $winAdvPb->lblResStatsResWDVal->Text($nbrRes);
  $$refDbh->commit();
  $$refDbh->do('PRAGMA shrink_memory');
  
}  #--- End resWeekday_DB

#--------------------------#
sub validLADB
#--------------------------#
{
  # Local variables
  my $LADB = shift;
  if (-f $LADB) {
    # Connect to DB
    $LADB   = encode('utf8', $LADB);
    my $dsn = "DBI:SQLite:dbname=$LADB";
    if (my $dbh = DBI->connect($dsn, undef, undef, { RaiseError => 1, AutoCommit => 0 })) {
      my $sth;
      eval { $sth = $dbh->table_info(undef, undef, '%', 'TABLE'); };
      return(0) if $@;
      # If table LOG exists, database is valid
      my $refAllRows = $sth->fetchall_arrayref();
      $sth->finish();
      foreach my $refRow (@{$refAllRows}) { return(\$dbh) if $$refRow[2] eq 'FILES'; }
    }
  }
  return(0);
  
}  #--- End validLADB

#------------------------------------------------------------------------------#
sub updateLADB_INFO
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($refDbh, $refINFO) = @_;
  my $sthUptInfo = $$refDbh->prepare('INSERT OR REPLACE INTO INFO (key, value) VALUES(?,?)');
  foreach my $key (keys %{$refINFO}) { $sthUptInfo->execute($key, $$refINFO{$key}); }
  # Resolved ISP
  if (my $nbrResISP = $$refDbh->selectrow_array('SELECT COUNT(ip) FROM IP WHERE isp IS NOT NULL')) {
    $sthUptInfo->execute('nbrResISP', $nbrResISP);
  } else { $sthUptInfo->execute('nbrResISP', 0); }
  # Resolved GeoIP
  if (my $nbrResGeoIP = $$refDbh->selectrow_array('SELECT COUNT(ip) FROM IP WHERE geoIP IS NOT NULL')) {
    $sthUptInfo->execute('nbrResGeoIP', $nbrResGeoIP);
  } else { $sthUptInfo->execute('nbrResGeoIP', 0); }
  # Resolved UAs
  if (my $nbrResUAs = $$refDbh->selectrow_array('SELECT COUNT(ua) FROM UA')) { $sthUptInfo->execute('nbrResUAs', $nbrResUAs); }
  else                                                                       { $sthUptInfo->execute('nbrResUAs', 0);          }
  # Resolved Weekday
  if (my $nbrResWeekdays = $$refDbh->selectrow_array('SELECT COUNT(weekday) FROM LOG WHERE weekday IS NOT NULL')) {
    $sthUptInfo->execute('nbrResWeekdays', $nbrResWeekdays);
  } else { $sthUptInfo->execute('nbrResWeekdays', 0); }
  $sthUptInfo->finish();
  $$refDbh->commit();
  
}  #--- End updateLADB_INFO

#--------------------------#
sub updateFILES
#--------------------------#
{
  # Local variables
  my ($refDbh, $refFileINFO) = @_;
  # Update entry in FILES
  my $sthFiles = $$refDbh->prepare('UPDATE FILES SET lines = ?, entries = ?, rejected = ?, filtered = ?, firstEntry = ? WHERE id == ?');
  $sthFiles->execute($$refFileINFO{nbrLines}, $$refFileINFO{nbrEntries}, $$refFileINFO{nbrRejected}, $$refFileINFO{nbrFiltered},
                     $$refFileINFO{firstEntry}, $$refFileINFO{id});
  $sthFiles->finish();
  
}  #--- End updateFILES

#--------------------------#
sub updateFilteredFILES
#--------------------------#
{
  # Local variables
  my ($refDbh, $fileId, $entries, $filtered, $firstEntry) = @_;
  # Update entry in FILES
  my $sthFiles = $$refDbh->prepare('UPDATE FILES SET entries = ?, filtered = ?, firstEntry = ? WHERE id == ?');
  $sthFiles->execute($entries, $filtered, $firstEntry, $fileId);
  $sthFiles->finish();
  
}  #--- End updateFilteredFILES

#------------------------------------------------------------------------------#
sub LAFilterData
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($refFilterSets, $nbrFilterSets, $whiteList, $refNewEntry, $timezone) = @_;
  my $addData = 0;
  # Compare each filter sets
  foreach my $cat (keys %{$refFilterSets}) {
    foreach my $filterSet (keys %{$$refFilterSets{$cat}}) {
      my $AND = $$refFilterSets{$cat}{$filterSet}{'AND'};
      # $AND = the number of AND
      # Test filters while it matches
      for (my $index = 1; $index <= $$refFilterSets{$cat}{$filterSet}{NBR_FILTERS}; $index++) {
        my $matches = 0;
        # $index is the position of the filter in the list
        # If it's the first filter to test, or if the last filter had no result and operator is OR
        if (($$refFilterSets{$cat}{$filterSet}{FILTERS}{$index}{operator} eq $STR{'OR'} and !$addData) or
            $$refFilterSets{$cat}{$filterSet}{FILTERS}{$index}{'operator'} eq '-') {
          $matches = &testFieldFilter($refNewEntry, $$refFilterSets{$cat}{$filterSet}{FILTERS}{$index}, $timezone);
        # If last filter had result and operator is OR
        } elsif ($$refFilterSets{$cat}{$filterSet}{FILTERS}{$index}{operator} eq $STR{'OR'} and $addData) {
          if ($AND) { next; } # There are AND left, we continue
          else      { last; } # No more AND, no need to continue
        # If operator is AND
        } elsif ($$refFilterSets{$cat}{$filterSet}{FILTERS}{$index}{operator} eq $STR{'AND'}) {
          $AND--;
          # Last filter had result, we continue
          if ($addData) {
            $matches = 0;
            $matches = &testFieldFilter($refNewEntry, $$refFilterSets{$cat}{$filterSet}{FILTERS}{$index}, $timezone);
          # Last filter had no result, no need to continue
          } else { return(0); }
        }
        # If filter has results and it's the last filter
        if ($matches) { $addData = 1; }
        # No result, operator is AND and it's the last filter, no need to continue
        elsif ($$refFilterSets{$cat}{$filterSet}{FILTERS}{$index}{operator} eq $STR{'AND'} and
               $index == $$refFilterSets{$cat}{$filterSet}{NBR_FILTERS}) { return(0); }
        # No result, but there is another filter
        elsif (!$matches and $index != $$refFilterSets{$cat}{$filterSet}{NBR_FILTERS}) { $addData = 0; }
      }
      # Evaluate end of the process
      if ($addData) {
        if ($whiteList) { return(0); } # Line matches a white list filter set, line must be ignored
        else            { return(1); } # Line matches a regular filter set
      }
    }
  }
  # No match
  return(1) if $whiteList;
  return(0)

}  #--- End LAFilterData

#------------------------------------------------------------------------------#
sub testFieldFilter
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($refNewEntry, $refFilters, $timezone) = @_;
  my $field     = $$refFilters{field};
  my $condition = $$refFilters{condition};
  my $value     = $$refFilters{value};
  # Datetime
  if ($field eq $STR{'DTDB'}) {
    # Date and time
    if ($$refFilters{'int'}) {
      if    ($condition eq $STR{'is'}         and $$refNewEntry{datetimeInt} == $$refFilters{int}) { return(1); }
      elsif ($condition eq $STR{'isNot'}      and $$refNewEntry{datetimeInt} != $$refFilters{int}) { return(1); }
      elsif ($condition eq lc($STR{'Before'}) and $$refNewEntry{datetimeInt}  < $$refFilters{int}) { return(1); }
      elsif ($condition eq lc($STR{'After'})  and $$refNewEntry{datetimeInt}  > $$refFilters{int}) { return(1); }
    # Date only
    } elsif ($$refFilters{'date'}) {
      my $refFilterDT = $$refFilters{date};
      my $newEntryDT = DateTime->from_epoch(epoch => $$refNewEntry{datetimeInt});
      $newEntryDT->set_time_zone($timezone);
      $newEntryDT->set_hour(0);
      $newEntryDT->set_minute(0);
      $newEntryDT->set_second(0);
      my $cmp = DateTime->compare($newEntryDT, $$refFilterDT);
      if    ($condition eq $STR{'is'}         and !$cmp)       { return(1); }
      elsif ($condition eq $STR{'isNot'}      and  $cmp)       { return(1); }
      elsif ($condition eq lc($STR{'Before'}) and  $cmp == -1) { return(1); }
      elsif ($condition eq lc($STR{'After'})  and  $cmp ==  1) { return(1); }
    # Time only
    } elsif ($$refFilters{time}) {
      my $refFilterDT  = $$refFilters{time};
      my $newEntryDT   = DateTime->from_epoch(epoch => $$refNewEntry{datetimeInt});
      $newEntryDT->set_time_zone($timezone);
      my $newEntryTime = DateTime->new(year => 1, hour => $newEntryDT->hour(), minute => $newEntryDT->minute(), second => $newEntryDT->second());
      my $cmp = DateTime->compare($newEntryTime, $$refFilterDT);
      if    ($condition eq $STR{'is'}         and !$cmp)       { return(1); }
      elsif ($condition eq $STR{'isNot'}      and  $cmp)       { return(1); }
      elsif ($condition eq lc($STR{'Before'}) and  $cmp == -1) { return(1); }
      elsif ($condition eq lc($STR{'After'})  and  $cmp ==  1) { return(1); }
    }
    else { return(0); }
  # Weekday
  } elsif ($field eq $STR{'Weekday'}) {
    if    ($condition eq $STR{'is'}    and $$refNewEntry{weekday} == $value) { return(1); }
    elsif ($condition eq $STR{'isNot'} and $$refNewEntry{weekday} != $value) { return(1); }
  # HTTPstatus
  } elsif ($field eq $STR{'LFHTTPstatus'}) {
    if    ($condition eq $STR{'is'}         and $$refNewEntry{http_status} == $value) { return(1); }
    elsif ($condition eq $STR{'isNot'}      and $$refNewEntry{http_status} != $value) { return(1); }
    elsif ($condition eq lc(STR{'Smaller'}) and $$refNewEntry{http_status}  < $value) { return(1); }
    elsif ($condition eq lc(STR{'Bigger'})  and $$refNewEntry{http_status}  > $value) { return(1); }
    else { return(0); }
  # Size
  } elsif ($field eq $STR{'LFsize'} and $$refNewEntry{size} and $$refNewEntry{size} =~ /^\d+$/) {
    if    ($condition eq $STR{'is'}          and $$refNewEntry{size} == $value) { return(1); }
    elsif ($condition eq $STR{'isNot'}       and $$refNewEntry{size} != $value) { return(1); }
    elsif ($condition eq lc($STR{'Smaller'}) and $$refNewEntry{size}  < $value) { return(1); }
    elsif ($condition eq lc($STR{'Bigger'})  and $$refNewEntry{size}  > $value) { return(1); }
    else { return(0); }
  # All other fields are text
  } else {
    my $valueInLog;
    if    ($field eq $STR{'LFclientIP'}                                  ) { $valueInLog = $$refNewEntry{remoteIP};      }
    elsif ($field eq $STR{'Weekday'}     and $$refNewEntry{Weekday}      ) { $valueInLog = $$refNewEntry{Weekday};       }
    elsif ($field eq $STR{'LFHTTPmethod'}                                ) { $valueInLog = $$refNewEntry{http_method};   }
    elsif ($field eq $STR{'LFHTTPreq'}                                   ) { $valueInLog = $$refNewEntry{http_request};  }
    elsif ($field eq $STR{'LFHTTPparam'} and $$refNewEntry{http_params}  ) { $valueInLog = $$refNewEntry{http_params};   }
    elsif ($field eq $STR{'LFHTTPprot'}  and $$refNewEntry{http_protocol}) { $valueInLog = $$refNewEntry{http_protocol}; }
    elsif ($field eq $STR{'LFReferer'}   and $$refNewEntry{referer}      ) { $valueInLog = $$refNewEntry{referer};       }
    elsif ($field eq $STR{'LFUA'}        and $$refNewEntry{useragent}    ) { $valueInLog = $$refNewEntry{useragent};     }
    if    ($field eq $STR{'isp'}         and $$refNewEntry{isp}          ) { $valueInLog = $$refNewEntry{isp};           }
    if    ($field eq $STR{'GeoIPDB'}     and $$refNewEntry{GeoIPDB}      ) { $valueInLog = $$refNewEntry{GeoIPDB};       }
    elsif ($field eq $STR{'LFUA-t'}      and $$refNewEntry{type}         ) { $valueInLog = $$refNewEntry{type};          }
    elsif ($field eq $STR{'LFUA-os'}     and $$refNewEntry{os}           ) { $valueInLog = $$refNewEntry{os};            }
    elsif ($field eq $STR{'LFUA-b'}      and $$refNewEntry{browser}      ) { $valueInLog = $$refNewEntry{browser};       }
    elsif ($field eq $STR{'LFUA-d'}      and $$refNewEntry{device}       ) { $valueInLog = $$refNewEntry{device};        }
    elsif ($field eq $STR{'LFUA-l'}      and $$refNewEntry{lang}         ) { $valueInLog = $$refNewEntry{lang};          }
    if ($valueInLog) {
      # Is
      if      ($condition eq $STR{'is'}) {
        if    ( $$refFilters{case} and    $valueInLog  eq    $value)  { return(1); }
        elsif (!$$refFilters{case} and lc($valueInLog) eq lc($value)) { return(1); }
        else { return(0); }
      # Is not
      } elsif ($condition eq $STR{'isNot'}) {
        if    ( $$refFilters{case} and    $valueInLog  ne    $value)  { return(1); }
        elsif (!$$refFilters{case} and lc($valueInLog) ne lc($value)) { return(1); }
        else { return(0); }
      # Contains
      } elsif ($condition eq lc($STR{'Contains'})) {
        $value = quotemeta($value) if !$$refFilters{regex};
        if    ( $$refFilters{case} and $valueInLog =~ /$value/ ) { return(1); }
        elsif (!$$refFilters{case} and $valueInLog =~ /$value/i) { return(1); }
        else { return(0); }
      # Does not contain
      } elsif ($condition eq $STR{'notContain'}) {
        $value = quotemeta($value) if !$$refFilters{regex};
        if    ( $$refFilters{case} and $valueInLog !~ /$value/ ) { return(1); }
        elsif (!$$refFilters{case} and $valueInLog !~ /$value/i) { return(1); }
        else { return(0); }
      } else { return(0); }
    }
    elsif ($condition eq $STR{'isNot'} or $condition eq $STR{'notContain'}) { return(1); }
    else { return(0); }
  }
  
}  #--- End testFieldFilter

#--------------------------#
sub parseUA
#--------------------------#
{
  # Local variables
  my ($uaStr, $refNewEntry) = @_;
  # Parse User-Agent String
  my $refUA = Woothee->parse($uaStr); # Ex.: {'name'=>"Internet Explorer", 'category'=>"pc", 'os'=>"Windows 7", 'version'=>"8.0", 'vendor'=>"Microsoft"}
  # Detect type
  if (!$$refUA{category} or $$refUA{category} =~ /UNKNOWN/) {
    if (my $uaType = HTTP::BrowserDetect->new($uaStr)) {
      if    ($uaType->robot())  { $$refNewEntry{type} = 'crawler';    }
      elsif ($uaType->mobile()) { $$refNewEntry{type} = 'smartphone'; }
      elsif ($uaType->tablet()) { $$refNewEntry{type} = 'tablet';     }
      else                      { $$refNewEntry{type} = 'pc';         }
    }
  } elsif ($$refUA{category}) { $$refNewEntry{type} = $$refUA{category}; }
  $$refNewEntry{type} = 'unknown' if !$$refNewEntry{type};
  # PC or smartphone
  if ($$refNewEntry{type} ne 'crawler' and $$refNewEntry{type} ne 'unknown') {
    # Detect OS
    my $os;
    if    ($uaStr =~ /Windows NT 5.2/i) { $os = 'Windows XP Professional x64'; }
    elsif ($uaStr =~ /Ubuntu/i        ) { $os = 'Linux Ubuntu'; }
    elsif ($uaStr =~ /Iceweasel/i     ) { $os = 'Linux Debian'; }
    # Unknown, use another parser
    elsif (!$$refUA{os} or $$refUA{os} =~ /UNKNOWN/) {
      my $uaOS;
      eval { my $uaOS = Parse::HTTP::UserAgent->new($uaStr); };
      $os = $uaOS->os if !$@ and $uaOS and $uaOS->os;
    } else {
      $os = $$refUA{os} if ($$refUA{os});
      # Add version for MAC OS X
      $os .= " $$refUA{os_version}" if $os and $os =~ /Mac OSX/i and $$refUA{os_version} and $$refUA{os_version} !~ /UNKNOWN/;
    }
    $$refNewEntry{os} = $os if $os;
    # Detect browser
    my $browser;
    $browser  = $$refUA{name}          if $$refUA{name}       and $$refUA{name} !~ /UNKNOWN/;
    $browser  = 'Iceweasel'            if $uaStr =~ /Iceweasel/i;
    $browser  = 'Mobile Safari'        if $uaStr =~ /Mobile/i and $uaStr =~ /Safari/;
    $browser .= ' '.$$refUA{version}   if $$refUA{version}    and $$refUA{version} !~ /UNKNOWN/; # Add Version
    $$refNewEntry{browser} .= $browser if $browser;
    # Detect Device
    if (my $uaDevice = HTTP::BrowserDetect->new($uaStr)) {
      my $device;
      $device = $uaDevice->device_name() if $uaDevice->device_name();
      $$refNewEntry{device} .= $device   if $device;
    }
    # Detect Lang
    if (my $uaLang = HTML::ParseBrowser->new($uaStr)) {
      my $lang;
      $lang = $uaLang->language if $uaLang->language;
      # See https://msdn.microsoft.com/en-us/library/ms533052%28v=vs.85%29.aspx
      $$refNewEntry{lang} .= $lang if $lang;
    }
  }

}  #--- End parseUA

#------------------------------------------------------------------------------#
sub filtersAsSQLStr
#------------------------------------------------------------------------------#
{
  # Local variables
  my ($refFilterSets, $SQLStr, $timezone) = @_;
  my $firstFilter = 1;
  foreach my $filterSetCat (keys %{$refFilterSets}) {
    foreach my $filterSetName ((keys %{$$refFilterSets{$filterSetCat}})) {
      my $partSQLStr;
      for (my $index = 1; $index <= $$refFilterSets{$filterSetCat}{$filterSetName}{NBR_FILTERS}; $index++) {
        if ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{operator}) {
          # Operator
          if ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{operator} eq '-') {
            if ($firstFilter) { $firstFilter = 0; }
            else              { $partSQLStr .= $STR{'OR'}.' '; }
          } else { $partSQLStr .= $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{operator}.' '; }
          # Field
          if ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'DTDB'}) {
            $partSQLStr .= 'datetimeInt ';
          } else {
            if ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'isp'} or
                $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'GeoIPDB'}) {
              $partSQLStr .= 'remoteIP IN (SELECT ip FROM IP WHERE ';
              $partSQLStr .= $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field}.' ';
            } elsif ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'LFUA-t'}  or
                     $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'LFUA-os'} or
                     $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'LFUA-b'}  or
                     $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'LFUA-d'}  or
                     $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'LFUA-l'}) {
              my %colNames = ($STR{'LFUA-t'} => 'Type'  , $STR{'LFUA-os'} => 'os', $STR{'LFUA-b'} => 'browser',
                              $STR{'LFUA-d'} => 'device', $STR{'LFUA-l'}  => 'lang');
              $partSQLStr .= 'useragent IN (SELECT ua FROM UA WHERE ';
              $partSQLStr .= $colNames{$$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field}}.' ';
            } else {
              $partSQLStr .= $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field}.' ';
            }
          }
          # Condition
          my $condition;
          if ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{condition} eq lc($STR{'Contains'})) {
            if    ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{regex}) { $condition = 'REGEXP'; }
            elsif ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{case} ) { $condition = 'GLOB';   } # Case sensitive
            else                                                                           { $condition = 'LIKE';   } # Case insensitive
          } elsif ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{condition} eq lc($STR{'notContain'})) {
            if ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{case}) { $condition = 'NOT GLOB';   } # Case sensitive
            else                                                                       { $condition = 'NOT LIKE';   } # Case insensitive
          } elsif ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{condition} eq lc($STR{'Before'}) or
                   $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{condition} eq lc($STR{'Smaller'})) { $condition = '<'; }
          elsif ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{condition}   eq lc($STR{'After'} ) or
                 $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{condition}   eq lc($STR{'Bigger'}) ) { $condition = '>'; }
          else {
            if    ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{condition} eq $STR{'is'}   ) { $condition = '=';  }
            elsif ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{condition} eq $STR{'isNot'}) { $condition = '!='; }
            else { $condition = $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{condition}; }
          }
          $partSQLStr .= $condition.' ';
          # Value
          if      ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{int} ) {
            $partSQLStr .= $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{int}.' ';
          } elsif ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{date}) {
            $partSQLStr =~ s/$condition $//;
            my $strp = DateTime::Format::Strptime->new(pattern => '%F');
            my $dt   = $strp->parse_datetime($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{date});
            $dt->set_hour(0);
            $dt->set_minute(0);
            $dt->set_second(0);
            $dt->set_time_zone($timezone);
            $partSQLStr .= '>= '.$dt->epoch().' and datetimeInt < '.($dt->epoch()+86400).' ';
          } elsif ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{time}) {
            $partSQLStr =~ s/datetimeInt $condition $//;
            my ($h,$m,$s) = split(/:/, $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{time});
            my $refTime   = DateTime->now(time_zone => $timezone);
            $refTime->set_hour($h);
            $refTime->set_minute($m);
            $refTime->set_second($s);
            $refTime->set_time_zone('UTC');
            my $refTime2  = $refTime->clone();
            $refTime2->set_hour(0);
            $refTime2->set_minute(0);
            $refTime2->set_second(0);
            my $timeInSeconds = $refTime->epoch()-$refTime2->epoch();
            if ($partSQLStr =~ /timeOfDay > (\d+) AND/) { $partSQLStr =~ s/AND $/OR / if $1 > $timeInSeconds; }
            $partSQLStr .= 'timeOfDay '.$condition.' '.$timeInSeconds.' ';
          } else {
            $partSQLStr .= "'";
            if    ($condition eq 'GLOB' or $condition eq 'NOT GLOB') { $partSQLStr .= '*'; }
            elsif ($condition eq 'LIKE' or $condition eq 'NOT LIKE') { $partSQLStr .= '%'; }
            my $value = $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{value};
            # Escape special chars
            $value =~ s/'/''/g;
            if (($condition eq 'LIKE' or $condition eq 'NOT LIKE') and ($value =~ /\%/ or $value =~ /_/)) {
              $value =~ s/%/\\%/g;
              $value =~ s/_/\\_/g;
            }
            $partSQLStr .= $value;
            if    ($condition eq 'GLOB' or $condition eq 'NOT GLOB') { $partSQLStr .= '*'; }
            elsif ($condition eq 'LIKE' or $condition eq 'NOT LIKE') {
              $partSQLStr .= '%';
            }
            $partSQLStr .= "' ";
            if ($condition eq 'LIKE' and
                ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{value} =~ /\%/ or
                 $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{value} =~ /_/)) {
              $partSQLStr .= "ESCAPE \'\\\' ";
            }
          }
        }
        if ($$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'isp'}     or
            $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'GeoIPDB'} or
            $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'LFUA-t'}  or
            $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'LFUA-os'} or
            $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'LFUA-b'}  or
            $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'LFUA-d'}  or
            $$refFilterSets{$filterSetCat}{$filterSetName}{FILTERS}{$index}{field} eq $STR{'LFUA-l'}) {
          chop($partSQLStr);
          $partSQLStr .= ') ';
        }
      }
      $SQLStr .= $partSQLStr;
    }
  }
  chop($SQLStr);
  return($SQLStr);
  
}  #--- End filtersAsSQLStr

#--------------------------#
sub sortIP
#--------------------------#
{
  # Split IP addresses
  my ($a, $b) = @_;
  # Both IPv4
  if ($a and $b and $a !~ /\:/ and $b !~ /\:/) {
    my ($a1, $a2, $a3, $a4) = split(/\./, $a);
    my ($b1, $b2, $b3, $b4) = split(/\./, $b);
    # Compare each part
    if ($a1 == $b1) {
      if ($a2 == $b2) {
        if ($a3 == $b3) {
          return $a4 <=> $b4;
        } else { return $a3 <=> $b3; }
      } else { return $a2 <=> $b2; }
    } else { return $a1 <=> $b1; }
  # If one of the address is IPv6, compare first number only
  } else { return (split(/[\.\:]/, $a))[0] <=> (split(/[\.\:]/, $b))[0]; }
  
}  #--- End sortIP

#--------------------------#
sub nsLookup
#--------------------------#
{
  # Local variables
  my $item    = shift;
  my $timeOut = shift;
  # $item is an IP address
  if ($item =~ /(?:[^0-9]|^)((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))(?:[^0-9\.]|$)/ or $item =~ /($IPv6_re)/) {
    my $res = Net::DNS::Resolver->new;
    $res->tcp_timeout($timeOut);
    $res->udp_timeout($timeOut);
    my $packet = $res->query($1, "PTR", "IN");
    if ($packet) {
      my @addrs  = $packet->answer;
      my $hostname = '';
      foreach (@addrs) { $hostname .= $_->ptrdname.", " if $_->type eq 'PTR' and $_->ptrdname; }
      if ($hostname) { chop($hostname); chop($hostname); return($hostname); }
    }
  }
  # $item is a hostname or domain name
  elsif ($item =~ /((?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.){2,}[a-zA-Z]{2,})(?:[^a-zA-Z]|$)/ or # Hostname
         $item =~ /((?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z]{2,})(?:[^\w\.\-]|$)/) {    # Domain name
    my $res = Net::DNS::Resolver->new;
    $res->tcp_timeout($timeOut);
    $res->udp_timeout($timeOut);
    my $packet = $res->query($1);
    if ($packet) {
      my @addrs  = $packet->answer;
      my $addr = '';
      foreach (@addrs) { $addr .= $_->address.", " if ($_->type eq 'A' or $_->type eq 'AAAA') and $_->address; }
      if ($addr) { chop($addr); chop($addr); return($addr); }
    }
  }
  
}  # Fin nsLookup

#------------------------------------------------------------------------------#
